import pandas as pd
import numpy as np
import pyupbit
import datetime
import requests
import random
import time
import os
import json
from langchain.text_splitter import RecursiveCharacterTextSplitter
# 기존 import들과 함께 추가
from trading_parser import TradingDecisionParser
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import matplotlib.pyplot as plt
from tqdm import tqdm
import statistics  # 표준 라이브러리에서 statistics 모듈 가져오기
import time  # 시간 측정을 위한 모듈

# 셀레니움 관련 라이브러리 추가
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException

class AIBacktester:
    def __init__(self, llama_model_path, n_gpu_layers=20, news_api_key=None, 
             news_datasets=None, use_selenium=False, headless=True, timeframe='1h'):
        """
        Initialize the AI backtesting system with LLM and news integration
        """
        self.model_path = llama_model_path
        self.n_gpu_layers = n_gpu_layers
        self.news_api_key = news_api_key
        self.document_store = []
        self.vectorizer = TfidfVectorizer()
        self.vectors = None

        # 새로 추가: timeframe 설정
        self.timeframe = timeframe

         # 뉴스 데이터베이스 초기화 (오류 방지)
        self.news_database = {}
        self.news_correlations = {}

         # RAG 시스템용 초기화
        self.pattern_correlations = {}  # 패턴 상관관계 저장

        self.trailing_stop_price = None  # 트레일링 스탑 가격 추적용
        self.test_mode = True  # 테스트 모드 플래그
        
        # ===== 중요 추가: historical_data 초기화 =====
        self.historical_data = []  # 백테스트 진행 중 누적되는 과거 데이터
        self.backtest_results = []  # 백테스트 결과 저장
        
        # 뉴스 데이터 관련 설정
        self.news_datasets = news_datasets or []
        self.use_selenium = use_selenium
        self.selenium_driver = None
        

        # 중요: 처리된 타임스탬프 집합을 인스턴스 변수로 명시적 초기화
        self.processed_timestamps = set()


        # 셀레니움 캐시 디렉토리 설정
        self.news_cache_dir = "news_cache"
        os.makedirs(self.news_cache_dir, exist_ok=True)
        
        # TradingDecisionParser 초기화 (추가)
        try:
            self.trading_parser = TradingDecisionParser(
                model_name="korean",  # Ollama 모델명
                host="localhost",
                port=11434
            )
            print("TradingDecisionParser 성공적으로 초기화됨")
        except Exception as e:
            print(f"Warning: TradingDecisionParser 초기화 실패: {str(e)}")
            print("파서 없이 진행하지만 LLM 파싱 품질이 낮아질 수 있습니다.")
            self.trading_parser = None
        
        # 다중 뉴스 데이터셋 핸들러 초기화 (형식 자동 감지)
        self.news_handlers = []
        print(f"Initialized with {len(self.news_datasets)} datasets")
        for dataset in self.news_datasets:
            print(f"Attempting to load dataset: {dataset}")

        for dataset_path in self.news_datasets:
            try:
                print(f"Loading dataset from: {dataset_path}")
                handler = NewsDatasetHandler(dataset_path)
                self.news_handlers.append(handler)
                print(f"News dataset loaded: {dataset_path} (Format: {handler.format_config['type']})")
            except Exception as e:
                print(f"Failed to load dataset {dataset_path}: {str(e)}")
        
        # 셀레니움 드라이버 초기화 (뉴스 검색에 사용)
        if self.use_selenium:
            try:
                chrome_options = Options()
                if headless:
                    chrome_options.add_argument("--headless")
                chrome_options.add_argument("--no-sandbox")
                chrome_options.add_argument("--disable-dev-shm-usage")
                chrome_options.add_argument("--disable-gpu")
                chrome_options.add_argument("--window-size=1920,1080")
                chrome_options.add_argument("--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36")
                
                # 고유한 user-data-dir 사용
                import tempfile
                temp_dir = tempfile.mkdtemp()
                chrome_options.add_argument(f"--user-data-dir={temp_dir}")
                chrome_options.add_argument("--disable-web-security")
                chrome_options.add_argument("--disable-features=VizDisplayCompositor")
                chrome_options.add_argument("--remote-debugging-port=0")
                
                self.selenium_driver = webdriver.Chrome(options=chrome_options)
                print("Selenium driver successfully initialized!")
            except Exception as e:
                print(f"Error initializing Selenium driver: {str(e)}")
                self.selenium_driver = None
                self.use_selenium = False
        
        # Initialize LLM
        try:
            from llama_cpp import Llama
            self.llm = Llama(
                model_path=self.model_path,
                n_gpu_layers=self.n_gpu_layers,
                n_ctx=8192
            )
            print("LLM successfully initialized!")
        except Exception as e:
            print(f"Error initializing LLM: {str(e)}")
            self.llm = None
    
    

    def calculate_opportunity_score(self, tech_indicators, price, current_news):
        """RAG 기반 투자 기회 점수 계산 (0-100점)"""
        
        # 유사 패턴 검색
        similar_patterns = self.find_similar_patterns(tech_indicators, success_weight=True, time_decay=True)
        
        if not similar_patterns:
            return 0, "패턴 데이터 부족"
        
        # 완료된 거래만 필터링
        completed_patterns = [p for p in similar_patterns if p.get('trade_result', {}).get('completed', False)]
        
        if len(completed_patterns) < 3:
            return 25, f"패턴 부족 ({len(completed_patterns)}개)"
        
        # 성공률 계산
        successful = [p for p in completed_patterns if p.get('trade_result', {}).get('success', False)]
        success_rate = len(successful) / len(completed_patterns)
        
        # 평균 수익률 계산  
        avg_profit = sum(p.get('trade_result', {}).get('profit_pct', 0) for p in successful) / len(successful) if successful else 0
        
        # 뉴스 감성 보정
        news_sentiment = self.analyze_news_sentiment(current_news)
        news_boost = 0
        if news_sentiment['sentiment_score'] > 0.3:
            news_boost = 10
        elif news_sentiment['sentiment_score'] < -0.3:
            news_boost = -10
        
        # 최종 점수 계산
        base_score = (success_rate * 60) + (min(avg_profit, 10) * 4)  # 최대 100점
        final_score = max(0, min(100, base_score + news_boost))
        
        reason = f"승률 {success_rate:.0%}, 평균수익 {avg_profit:.1f}%, 패턴 {len(completed_patterns)}개"
        
        return final_score, reason
    


    
    def rag_based_trigger_check(self, price, timestamp, tech_indicators, current_news):
        """RAG 기반 AI 호출 여부 결정"""
        
        # 1. 기본 트리거 체크 (기존 로직)
        basic_trigger = self.check_volatility_breakout_trigger(price, timestamp, 0)
        
        if not basic_trigger:
            return False, "기본 트리거 미달성"
        
        # 2. RAG 기회 점수 계산
        opportunity_score, reason = self.calculate_opportunity_score(tech_indicators, price, current_news)
        
        # 3. 임계점 체크 (🚨 여기 수정!)
        if opportunity_score >= 75:  # 70 → 85로 상향
            return True, f"고확률 시점 (점수: {opportunity_score}점, {reason})"
        
        elif opportunity_score >= 65:  # 50 → 75로 상향
            # 중간 점수는 추가 조건 체크
            support_analysis = self._check_near_support_level_enhanced("KRW-BTC", price)
            if support_analysis.get('is_near_support') and support_analysis.get('strength', 0) > 0.7:  # 0.7 → 0.8로 상향
                return True, f"중확률+강지지 (점수: {opportunity_score}점)"
        
        return False, f"확률 부족 (점수: {opportunity_score}점, {reason})"
    
    def integrated_decision_system(self, ai_result, pattern_advice, news_sentiment, market_trend, confluence_signals):
        """5가지 요소 통합 의사결정"""
        
        decision_score = 0
        reasons = []
        
        # 1. AI 신호 (35%)
        if ai_result['signal'] == 'BUY':
            ai_contribution = ai_result['confidence'] * 0.35
            decision_score += ai_contribution
            reasons.append(f"AI매수 {ai_result['confidence']:.2f}")
        
        # 2. RAG 패턴 (30%) - 핵심!
        if pattern_advice['recommendation'] == 'BUY':
            rag_contribution = pattern_advice['confidence'] * 0.30
            decision_score += rag_contribution
            reasons.append(f"RAG매수 승률{pattern_advice.get('win_rate', 0):.0%}")
            
            # 기대수익 보너스
            if pattern_advice.get('profit_expectation', 0) > 3:
                decision_score += 0.05
        
        # 3. 뉴스 감성 (15%)
        if news_sentiment.get('sentiment_score', 0) > 0.3:
            news_contribution = news_sentiment['sentiment_score'] * 0.15
            decision_score += news_contribution
            reasons.append(f"뉴스긍정 {news_sentiment['sentiment_score']:.2f}")
        
        # 4. 시장 추세 (10%)
        if "uptrend" in market_trend.lower():
            decision_score += 0.10
            reasons.append("상승추세")
        
        # 5. 기술적 신호 (10%)
        tech_score = confluence_signals.get('total_score', 0) / 100  # 0-1로 정규화
        decision_score += tech_score * 0.10
        
        # 최종 판단
        should_buy = decision_score >= 0.65  # 65% 이상
        
        return {
            'should_buy': should_buy,
            'total_score': decision_score,
            'reasons': reasons,
            'details': f"종합점수 {decision_score:.2f} ({'매수' if should_buy else '대기'})"
        }











    def _check_bounce_pattern(self, current_price):
        """
        지지선에서 반등 패턴 확인
        """
        if len(self.historical_data) < 3:
            return False
        
        # 최근 3개 가격 확인
        recent_prices = [item['price'] for item in self.historical_data[-3:]]
        recent_prices.append(current_price)
        
        # 하락 후 상승 패턴 확인 (V자 반등)
        if len(recent_prices) >= 3:
            if recent_prices[-3] > recent_prices[-2] < recent_prices[-1]:
                print(f"🔄 V자 반등 패턴 감지: {recent_prices[-3]:,.0f} > {recent_prices[-2]:,.0f} < {recent_prices[-1]:,.0f}")
                return True
        
        return False

    def check_strong_buy_signal_enhanced(self, price, tech_indicators, market_trend, 
                                    confidence, news_sentiment, pattern_advice, 
                                    fear_greed_index=50):
        """강화된 매수 신호 검증 (패턴 + 심리 지수 통합)"""
        
        buy_score = 0
        reasons = []
        
        print(f"🔍 강화된 매수 신호 분석 - 가격: ₩{price:,.0f}")
        
        # 1. 기본 시장 추세 확인
        if "uptrend" in market_trend.lower() or "bullish" in market_trend.lower():
            buy_score += 3
            reasons.append("✅ 상승추세 확인 (+3점)")
        elif "strong downtrend" in market_trend.lower():
            print("❌ 강한 하락추세 - 매수 금지")
            return False, ["강한 하락추세 - 매수 금지"]
        elif "downtrend" in market_trend.lower():
            buy_score -= 1
            reasons.append("⚠️ 하락추세 주의 (-1점)")
        
        # 2. 지지선 + 반등 확인
        support_analysis = self._check_near_support_level_enhanced("KRW-BTC", price)
        
        if support_analysis['is_near_support'] and support_analysis['strength'] >= 0.6:
            if self._check_bounce_pattern(price):
                buy_score += 4
                reasons.append(f"✅ 강한 지지선 반등 (+4점, 강도: {support_analysis['strength']:.2f})")
            else:
                buy_score += 2
                reasons.append(f"✅ 지지선 근처 (+2점, 강도: {support_analysis['strength']:.2f})")
        elif support_analysis['is_near_support']:
            buy_score += 1
            reasons.append(f"🔸 약한 지지선 (+1점, 강도: {support_analysis['strength']:.2f})")
        
        # 3. RSI 분석 (다이버전스 감지 추가)
        rsi = None
        if 'RSI(14)' in tech_indicators:
            try:
                rsi = float(str(tech_indicators['RSI(14)']).replace(',', ''))
            except:
                pass
        
        if rsi is not None:
            if rsi < 25:
                buy_score += 4
                reasons.append(f"✅ 극도 과매도 (+4점, RSI: {rsi:.1f})")
            elif rsi < 35:
                buy_score += 3
                reasons.append(f"✅ 과매도 (+3점, RSI: {rsi:.1f})")
            elif rsi > 75:
                buy_score -= 3
                reasons.append(f"❌ 극도 과매수 (-3점, RSI: {rsi:.1f})")
            elif rsi > 65:
                buy_score -= 1
                reasons.append(f"⚠️ 과매수 주의 (-1점, RSI: {rsi:.1f})")
            else:
                reasons.append(f"🔸 RSI 중립 (0점, RSI: {rsi:.1f})")
        
        # 4. MACD 신호 확인
        macd = tech_indicators.get('MACD', '')
        if 'Bullish crossover' in str(macd):
            buy_score += 4
            reasons.append("✅ MACD 골든크로스 (+4점)")
        elif 'Bullish' in str(macd):
            buy_score += 2
            reasons.append("✅ MACD 상승 (+2점)")
        elif 'Bearish crossover' in str(macd):
            buy_score -= 4
            reasons.append("❌ MACD 데드크로스 (-4점)")
        elif 'Bearish' in str(macd):
            buy_score -= 2
            reasons.append("⚠️ MACD 하락 (-2점)")
        
        # 5. 뉴스 감성 확인
        sentiment_score = news_sentiment.get('sentiment_score', 0)
        if sentiment_score > 0.5:
            buy_score += 3
            reasons.append(f"✅ 매우 긍정적 뉴스 (+3점, 점수: {sentiment_score:.2f})")
        elif sentiment_score > 0.3:
            buy_score += 2
            reasons.append(f"✅ 긍정적 뉴스 (+2점, 점수: {sentiment_score:.2f})")
        elif sentiment_score < -0.5:
            buy_score -= 3
            reasons.append(f"❌ 매우 부정적 뉴스 (-3점, 점수: {sentiment_score:.2f})")
        elif sentiment_score < -0.3:
            buy_score -= 2
            reasons.append(f"❌ 부정적 뉴스 (-2점, 점수: {sentiment_score:.2f})")
        
        # 6. AI 신뢰도 확인
        if confidence >= 0.8:
            buy_score += 3
            reasons.append(f"✅ 높은 AI 신뢰도 (+3점, {confidence:.2f})")
        elif confidence >= 0.6:
            buy_score += 2
            reasons.append(f"✅ 중간 AI 신뢰도 (+2점, {confidence:.2f})")
        elif confidence < 0.4:
            buy_score -= 2
            reasons.append(f"⚠️ 낮은 AI 신뢰도 (-2점, {confidence:.2f})")
        
        # 7. 패턴 기반 조언 반영 (핵심 추가!)
        if pattern_advice.get('recommendation') == 'BUY':
            pattern_confidence = pattern_advice.get('confidence', 0)
            expected_profit = pattern_advice.get('profit_expectation', 0)
            win_rate = pattern_advice.get('win_rate', 0)
            
            # 패턴 점수 계산
            pattern_score = (pattern_confidence * 2) + (expected_profit / 3) + (win_rate * 5)
            pattern_score = min(5, pattern_score)  # 최대 5점
            
            buy_score += pattern_score
            reasons.append(f"✅ 성공 패턴 매칭 (+{pattern_score:.1f}점)")
            reasons.append(f"   └─ 신뢰도: {pattern_confidence:.2f}, 기대수익: {expected_profit:.1f}%, 승률: {win_rate:.0%}")
        
        # 8. Fear & Greed Index 반영 (역발상 투자)
        if fear_greed_index <= 20:  # 극단적 공포
            buy_score += 4
            reasons.append(f"✅ 극단적 공포 상태 - 역발상 매수 기회 (+4점, FGI: {fear_greed_index})")
        elif fear_greed_index <= 35:  # 공포
            buy_score += 2
            reasons.append(f"✅ 공포 상태 - 매수 기회 (+2점, FGI: {fear_greed_index})")
        elif fear_greed_index >= 80:  # 극단적 탐욕
            buy_score -= 3
            reasons.append(f"❌ 극단적 탐욕 - 과열 위험 (-3점, FGI: {fear_greed_index})")
        elif fear_greed_index >= 65:  # 탐욕
            buy_score -= 1
            reasons.append(f"⚠️ 탐욕 상태 - 주의 (-1점, FGI: {fear_greed_index})")
        
        # 9. 볼린저 밴드 위치
        bb = tech_indicators.get('Bollinger Bands', '')
        if 'lower' in str(bb).lower():
            buy_score += 3
            reasons.append("✅ 볼린저밴드 하단 (+3점)")
        elif 'upper' in str(bb).lower():
            buy_score -= 2
            reasons.append("⚠️ 볼린저밴드 상단 (-2점)")
        
        # 최종 판단 (임계값 조정: 8점 → 6점)
        print(f"📊 강화된 매수 신호 점수: {buy_score}점")
        for reason in reasons:
            print(f"  {reason}")
        
        if buy_score >= 10:
            final_reasons = reasons + [f"🚀 매우 강한 매수 신호 (총 {buy_score}점)"]
            print(f"🚀 결론: 매우 강한 매수 신호 - 총 {buy_score}점")
            return True, final_reasons
        elif buy_score >= 3:  # 임계값 완화
            final_reasons = reasons + [f"📈 강한 매수 신호 (총 {buy_score}점)"]
            print(f"📈 결론: 강한 매수 신호 - 총 {buy_score}점")
            return True, final_reasons
        else:
            final_reasons = reasons + [f"❌ 매수 조건 미달 (총 {buy_score}점)"]
            print(f"❌ 결론: 매수 조건 미달 - 총 {buy_score}점 (최소 6점 필요)")
            return False, final_reasons


    def _process_news_for_storage(self, news_data):
        """RAG 저장용 뉴스 데이터 처리"""
        processed_news = []
        for news in news_data[:5]:  # 최신 5개만 저장
            processed_news.append({
                'title': news.get('title', '')[:200],  # 제목 200자 제한
                'description': news.get('description', '')[:500],  # 내용 500자 제한
                'source': news.get('source', ''),
                'publishedAt': news.get('publishedAt', ''),
                'url': news.get('url', '')
            })
        return processed_news

    def _create_news_summary(self, news_data):
        """뉴스 요약 생성"""
        if not news_data:
            return ""
        
        titles = [news.get('title', '') for news in news_data[:3]]
        return " | ".join(titles)




    def store_enhanced_market_pattern(self, tech_indicators, price, ai_decision, actual_decision, 
                                confidence, market_trend, news_sentiment, pattern_advice, 
                                timestamp, rejection_reason=None, news_data=None):
        """가상 거래 결과까지 추적하는 강화된 패턴 저장"""
        
        pattern_id = f"{timestamp.strftime('%Y%m%d%H%M%S')}_{hash(str(tech_indicators))}"
        
        # 기본 패턴 정보
        base_pattern = {
            'pattern_id': pattern_id,
            'date': timestamp.strftime('%Y-%m-%d'),
            'timestamp': timestamp,
            'indicators': tech_indicators,
            'price': price,
            'ai_decision': ai_decision,
            'actual_decision': actual_decision,
            'confidence': confidence,
            'market_trend': market_trend,
            'news_sentiment': news_sentiment,
            'pattern_advice': pattern_advice,
            'support_analysis': self._check_near_support_level_enhanced("KRW-BTC", price),
            'rejection_reason': rejection_reason,
            # ↓ 뉴스 정보 추가
            'news_data': self._process_news_for_storage(news_data) if news_data else [],
            'news_summary': self._create_news_summary(news_data) if news_data else "",
            'news_count': len(news_data) if news_data else 0,
            'news_timestamp': timestamp.strftime('%Y-%m-%d %H:%M:%S')
        }
        
        # 실제 거래 결과 추적
        if actual_decision == 'BUY':
            base_pattern['trade_result'] = {
                'type': 'actual_trade',
                'completed': False,
                'entry_price': price,
                'exit_price': None,
                'profit_pct': None,
                'success': None,
                'exit_reason': None
            }
        
        # 가상 거래 결과 추적 설정
        elif ai_decision == 'BUY' and actual_decision != 'BUY':
            base_pattern['hypothetical_trade'] = {
                'type': 'hypothetical_trade',
                'would_have_bought': True,
                'hypothetical_entry_price': price,
                'tracking_start_date': timestamp.strftime('%Y-%m-%d'),
                'tracking_days': 0,
                'max_tracking_days': 7,  # 7일간 추적
                'daily_prices': [price],
                'completed': False
            }
        
        # HOLD 결정의 기회비용 추적
        elif ai_decision == 'HOLD':
            base_pattern['opportunity_cost_tracking'] = {
                'type': 'opportunity_cost',
                'hold_decision_price': price,
                'tracking_start_date': timestamp.strftime('%Y-%m-%d'),
                'tracking_days': 0,
                'max_tracking_days': 5,  # 5일간 추적
                'daily_prices': [price],
                'completed': False
            }
        
        # 패턴 메트릭 초기화
        base_pattern['pattern_metrics'] = {
            'success_count': 0,
            'failure_count': 0,
            'total_profit': 0,
            'avg_profit': 0,
            'success_rate': 0,
            'hypothetical_success_count': 0,
            'hypothetical_failure_count': 0,
            'hypothetical_total_profit': 0,
            'opportunity_cost_total': 0,
            'last_update': timestamp.strftime('%Y-%m-%d'),
            'usage_count': 0
        }
        
        # document_store에 추가
        if not hasattr(self, 'document_store'):
            self.document_store = []
        
        self.document_store.append(base_pattern)
        
        print(f"💾 강화된 패턴 저장: {pattern_id}")
        print(f"  ├─ AI 결정: {ai_decision}")
        print(f"  ├─ 실제 결정: {actual_decision}")
        if rejection_reason:
            print(f"  ├─ 거부 이유: {rejection_reason}")
        
        return pattern_id

    def track_hypothetical_trades(self, current_price, current_date):
        """모든 가상 거래 및 기회비용 추적"""
        
        if not hasattr(self, 'document_store'):
            return
        
        updated_patterns = 0
        
        for pattern in self.document_store:
            # 가상 거래 추적
            if 'hypothetical_trade' in pattern and not pattern['hypothetical_trade']['completed']:
                hypo_trade = pattern['hypothetical_trade']
                
                # 추적 기간 체크
                hypo_trade['tracking_days'] += 1
                hypo_trade['daily_prices'].append(current_price)
                
                # 7일 추적 완료 또는 큰 변화 발생시 결과 계산
                if (hypo_trade['tracking_days'] >= hypo_trade['max_tracking_days'] or 
                    abs((current_price / hypo_trade['hypothetical_entry_price']) - 1) > 0.1):  # 10% 변화
                    
                    entry_price = hypo_trade['hypothetical_entry_price']
                    profit_pct = ((current_price / entry_price) - 1) * 100
                    
                    # 가상 거래 결과 기록
                    hypo_trade.update({
                        'completed': True,
                        'hypothetical_exit_price': current_price,
                        'hypothetical_profit_pct': profit_pct,
                        'hypothetical_success': profit_pct > 0.5,  # 수수료 고려 0.5% 이상
                        'completion_date': current_date,
                        'lesson_learned': self._generate_lesson(pattern['ai_decision'], 
                                                            pattern['actual_decision'], 
                                                            profit_pct)
                    })
                    
                    # 패턴 메트릭 업데이트
                    if profit_pct > 0.5:
                        pattern['pattern_metrics']['hypothetical_success_count'] += 1
                    else:
                        pattern['pattern_metrics']['hypothetical_failure_count'] += 1
                    
                    pattern['pattern_metrics']['hypothetical_total_profit'] += profit_pct
                    
                    updated_patterns += 1
                    
                    print(f"📊 가상 거래 완료: {pattern['pattern_id'][:10]}...")
                    print(f"  └─ 놓친 기회: {profit_pct:+.2f}% ({'수익' if profit_pct > 0.5 else '손실'})")
            
            # 기회비용 추적
            elif 'opportunity_cost_tracking' in pattern and not pattern['opportunity_cost_tracking']['completed']:
                opp_track = pattern['opportunity_cost_tracking']
                
                opp_track['tracking_days'] += 1
                opp_track['daily_prices'].append(current_price)
                
                # 5일 추적 완료
                if opp_track['tracking_days'] >= opp_track['max_tracking_days']:
                    hold_price = opp_track['hold_decision_price']
                    opportunity_cost = ((current_price / hold_price) - 1) * 100
                    
                    opp_track.update({
                        'completed': True,
                        'final_price': current_price,
                        'opportunity_cost_pct': opportunity_cost,
                        'was_good_hold': opportunity_cost < 0,  # 하락했으면 좋은 HOLD
                        'completion_date': current_date
                    })
                    
                    pattern['pattern_metrics']['opportunity_cost_total'] += opportunity_cost
                    updated_patterns += 1
                    
                    if abs(opportunity_cost) > 2.0:  # 2% 이상 변화시만 로깅
                        print(f"📊 기회비용 추적 완료: {pattern['pattern_id'][:10]}...")
                        print(f"  └─ HOLD 결과: {opportunity_cost:+.2f}% ({'아쉬운 HOLD' if opportunity_cost > 3 else '올바른 HOLD'})")
        
        if updated_patterns > 0:
            print(f"💾 {updated_patterns}개 패턴의 가상 결과 업데이트됨")

    def _generate_lesson(self, ai_decision, actual_decision, result_pct):
        """결과 기반 교훈 생성"""
        
        if ai_decision == 'BUY' and actual_decision != 'BUY':
            if result_pct > 3.0:
                return f"매수 거부로 {result_pct:.1f}% 기회 상실 - 다음엔 더 적극적 고려 필요"
            elif result_pct < -2.0:
                return f"매수 거부로 {abs(result_pct):.1f}% 손실 회피 성공 - 올바른 판단"
            else:
                return f"매수 거부 결과 {result_pct:.1f}% - 중립적 결과"
        
        return "결과 분석 중"
    




    def calculate_dynamic_stop_loss(self, entry_price, market_volatility, support_strength):
        """
        시장 상황에 따른 동적 손절매 계산
        """
        base_stop_loss = -3.0
        
        # 변동성에 따른 조정
        if market_volatility > 0.08:  # 고변동성
            stop_loss = -5.0
            volatility_reason = "고변동성"
        elif market_volatility > 0.05:  # 중변동성  
            stop_loss = -4.0
            volatility_reason = "중변동성"
        elif market_volatility < 0.03:  # 저변동성
            stop_loss = -2.5
            volatility_reason = "저변동성"
        else:
            stop_loss = base_stop_loss
            volatility_reason = "보통변동성"
        
        # 지지선 강도에 따른 조정
        if support_strength >= 0.8:  # 매우 강한 지지선
            stop_loss *= 0.7  # 30% 완화
            support_reason = "매우 강한 지지선 (30% 완화)"
        elif support_strength >= 0.6:  # 강한 지지선
            stop_loss *= 0.85  # 15% 완화
            support_reason = "강한 지지선 (15% 완화)"
        else:
            support_reason = "일반 지지선"
        
        print(f"🛡️ 동적 손절매 계산: {stop_loss:.1f}% ({volatility_reason}, {support_reason})")
        return stop_loss

    def calculate_dynamic_profit_target(self, market_trend, confidence, pattern_quality):
        """
        시장 상황에 따른 동적 익절 목표
        """
        base_profit = 5.0
        
        # 시장 추세에 따른 조정
        if "strong uptrend" in market_trend.lower():
            profit_target = 8.0
            trend_reason = "강한 상승장"
        elif "uptrend" in market_trend.lower():
            profit_target = 6.0
            trend_reason = "상승장"
        elif "downtrend" in market_trend.lower():
            profit_target = 3.0
            trend_reason = "하락장에서 빠른 실현"
        else:
            profit_target = base_profit
            trend_reason = "중립장"
        
        # AI 신뢰도에 따른 조정
        confidence_multiplier = 1.0
        if confidence >= 0.8:
            confidence_multiplier = 1.2
            confidence_reason = "높은 신뢰도 (20% 증가)"
        elif confidence < 0.5:
            confidence_multiplier = 0.8
            confidence_reason = "낮은 신뢰도 (20% 감소)"
        else:
            confidence_reason = "보통 신뢰도"
        
        profit_target *= confidence_multiplier
        
        # 패턴 품질에 따른 조정
        if pattern_quality >= 70:
            profit_target *= 1.1
            pattern_reason = "고품질 패턴 (10% 증가)"
        else:
            pattern_reason = "일반 패턴"
        
        print(f"🎯 동적 익절 목표 계산: {profit_target:.1f}% ({trend_reason}, {confidence_reason}, {pattern_reason})")
        return profit_target

    
    
    def improved_exit_strategy_enhanced(self, current_price, entry_price, entry_date, current_date, 
                                    market_trend, profit_target, stop_loss, confidence,
                                    position_adjustments=None):
        """강화된 청산 전략 - 본전 보장 + 부분 익절"""
        
        profit_pct = ((current_price / entry_price) - 1) * 100
        
        # 포지션 조정 정보 반영
        if position_adjustments:
            profit_target += position_adjustments.get('profit_target_adjustment', 0)
            stop_loss += position_adjustments.get('stop_loss_adjustment', 0)
        
        # 🚨 수정 1: 기본 손절매 확인 (최우선)
        if profit_pct <= stop_loss:
            return "SELL_STOPLOSS", f"손절매 실행 ({profit_pct:.2f}% <= {stop_loss:.1f}%)"
        
        # 🚨 수정 2: 간단한 익절 우선 적용
        if profit_pct >= profit_target:
            return "SELL_PROFIT", f"목표 수익 달성 ({profit_pct:.2f}% >= {profit_target:.1f}%)"
        
        # 🚨 수정 3: 플래그 체크 변경
        breakeven_active = getattr(self, 'breakeven_protection_active', False)
        partial_taken = getattr(self, 'partial_profit_taken', False)
        
        # 2. 본전 보장 트레일링 스탑 (2.5% 수익 시 활성화)
        if profit_pct >= 2.5 and not breakeven_active:
            breakeven_price = entry_price * 1.001  # 수수료 0.1% 고려
            self.trailing_stop_price = max(
                getattr(self, 'trailing_stop_price', 0), 
                breakeven_price
            )
            self.breakeven_protection_active = True
            print(f"💎 본전 보장 활성화: ₩{breakeven_price:,.0f}")
        
        # 3. 부분 익절 시스템 (목표 수익의 70% 달성시)
        partial_profit_threshold = profit_target * 0.7
        if profit_pct >= partial_profit_threshold and not partial_taken:
            self.partial_profit_taken = True
            return "SELL_PARTIAL_PROFIT", f"부분 익절 (50%) - {profit_pct:.2f}% >= {partial_profit_threshold:.1f}%"
        
        # 🚨 수정 4: 간단한 시간 기반 청산 추가
        try:
            # 간단한 날짜 계산으로 대체
            entry_dt = pd.to_datetime(entry_date)
            current_dt = pd.to_datetime(current_date)
            holding_days = (current_dt - entry_dt).days
            
            # 7일 이상 보유 시 무조건 청산
            if holding_days >= 7:
                return "SELL_TIMEOUT", f"장기 보유로 청산 ({holding_days}일, {profit_pct:.2f}%)"
                
        except Exception as e:
            print(f"날짜 계산 오류: {str(e)}")
            # 날짜 계산 실패시에도 다른 조건들 체크
        
        # 7. 트레일링 스탑 확인
        trailing_price = getattr(self, 'trailing_stop_price', 0)
        if trailing_price > 0 and current_price <= trailing_price:
            return "SELL_TRAILING", f"트레일링 스탑 실행 ({profit_pct:.2f}%)"
        
        return "HOLD", f"보유 계속 ({profit_pct:.2f}%)"


    def simple_exit_strategy(self, current_price, entry_price, entry_date, current_date, 
                            market_trend, profit_target, stop_loss, confidence,
                            position_adjustments=None):
        """초간단 매도 로직 - 테스트용"""
        
        profit_pct = ((current_price / entry_price) - 1) * 100
        
        # 🚨 무조건 작동하는 매도 조건들
        if profit_pct <= -2.0:  # 손절 -2%
            return "SELL_STOPLOSS", f"손절매 ({profit_pct:.2f}%)"
        
        if profit_pct >= 5.0:   # 익절 +5%
            return "SELL_PROFIT", f"익절 ({profit_pct:.2f}%)"
        
        # 간단한 시간 청산 (3일)
        try:
            entry_dt = pd.to_datetime(entry_date)
            current_dt = pd.to_datetime(current_date)
            if (current_dt - entry_dt).days >= 3:
                return "SELL_TIMEOUT", f"3일 경과 청산 ({profit_pct:.2f}%)"
        except:
            pass
        
        return "HOLD", f"보유 ({profit_pct:.2f}%)"






    def calculate_position_size(self, price, stop_loss_pct, balance=None, risk_level=1.0, confidence=0.5, market_trend="neutral", pattern_quality=0):
        """
        개선된 포지션 크기 계산 - 기본 투자 비율 + 시장 상황 조정
        
        Args:
            price: 현재 가격
            stop_loss_pct: 손절매 비율 (사용 안함)
            balance: 계좌 잔고
            risk_level: 리스크 수준 (사용 안함)
            confidence: AI 신뢰도 (0.0~1.0)
            market_trend: 시장 추세
            pattern_quality: 패턴 품질 점수
            
        Returns:
            tuple: (코인 수량, 투자 금액, 투자 비율)
        """
        # 기본 잔고 설정
        if balance is None:
            balance = getattr(self, 'current_balance', getattr(self, 'initial_balance', 10000000))
        
        # 🎯 기본 투자 비율: 50%
        base_investment_ratio = 0.05
        
        # 📊 시장 상황별 비율 조정
        market_adjustment = 0.0
        
        # 1. 시장 추세에 따른 조정
        if "strong uptrend" in market_trend.lower() or "bullish" in market_trend.lower():
            market_adjustment += 0.10  # +10%
        elif "uptrend" in market_trend.lower():
            market_adjustment += 0.05  # +5%
        elif "strong downtrend" in market_trend.lower() or "bearish" in market_trend.lower():
            market_adjustment -= 0.10  # -10%
        elif "downtrend" in market_trend.lower():
            market_adjustment -= 0.05  # -5%
        
        # 2. AI 신뢰도에 따른 조정
        if confidence >= 0.8:
            market_adjustment += 0.10  # +10% (매우 높은 신뢰도)
        elif confidence >= 0.7:
            market_adjustment += 0.05  # +5% (높은 신뢰도)
        elif confidence < 0.4:
            market_adjustment -= 0.10  # -10% (낮은 신뢰도)
        elif confidence < 0.5:
            market_adjustment -= 0.05  # -5% (중간 신뢰도)
        
        # 3. 패턴 품질에 따른 조정
        if pattern_quality >= 70:
            market_adjustment += 0.05  # +5% (고품질 패턴)
        elif pattern_quality >= 50:
            market_adjustment += 0.02  # +2% (중품질 패턴)
        elif pattern_quality < 30:
            market_adjustment -= 0.05  # -5% (저품질 패턴)
        
        # 4. 연속 성공/실패에 따른 조정
        consecutive_wins = getattr(self, 'consecutive_wins', 0)
        consecutive_losses = getattr(self, 'consecutive_losses', 0)
        
        if consecutive_wins >= 3:
            market_adjustment += 0.05  # +5% (연속 성공)
        elif consecutive_losses >= 3:
            market_adjustment -= 0.10  # -10% (연속 실패)
        elif consecutive_losses >= 2:
            market_adjustment -= 0.05  # -5% (연속 실패)
        
        # 최종 투자 비율 계산 (40%~60% 범위 제한)
        final_investment_ratio = base_investment_ratio + market_adjustment
        final_investment_ratio = max(0.04, min(0.06, final_investment_ratio))
        
        # 💰 실제 투자 금액 계산
        investment_amount = balance * final_investment_ratio
        
        # 수수료 고려 (0.05%)
        fee_rate = 0.0005
        net_investment = investment_amount / (1 + fee_rate)
        
        # 코인 수량 계산
        coin_amount = net_investment / price
        
        # 최소 투자 금액 체크 (1000원 이상)
        if investment_amount < 1000:
            print(f"⚠️ 잔고 부족: ₩{balance:,.0f} → 투자 불가")
            return 0, 0, 0
        
        # 결과 로깅
        print(f"💰 포지션 크기 계산:")
        print(f"  ├─ 기본 투자 비율: {base_investment_ratio*100:.0f}%")
        print(f"  ├─ 시장 조정: {market_adjustment*100:+.0f}%")
        print(f"  ├─ 최종 투자 비율: {final_investment_ratio*100:.1f}%")
        print(f"  ├─ 투자 금액: ₩{investment_amount:,.0f}")
        print(f"  ├─ 코인 수량: {coin_amount:.8f} BTC")
        print(f"  └─ 남은 잔고: ₩{balance - investment_amount:,.0f}")
        
        # 조정 이유 로깅
        reasons = []
        if abs(market_adjustment) > 0.01:
            if market_adjustment > 0:
                reasons.append(f"상승 조정 +{market_adjustment*100:.1f}%")
            else:
                reasons.append(f"하락 조정 {market_adjustment*100:.1f}%")
        
        if reasons:
            print(f"  📊 조정 이유: {', '.join(reasons)}")
        
        return coin_amount, investment_amount, final_investment_ratio


    def check_risk_limits(self, current_date, backtest_results):
        """
        패턴 학습용 리스크 체크 - 쿨다운 없음
        
        Args:
            current_date: 현재 날짜
            backtest_results: 백테스트 결과 목록
            
        Returns:
            bool: 항상 True (패턴 학습을 위해 거래 계속)
        """
        # 패턴 학습 모드: 손실 상태만 모니터링하고 거래는 계속
        daily_loss_limit = getattr(self, 'daily_loss_limit', -10.0)  # 모니터링용
        weekly_loss_limit = getattr(self, 'weekly_loss_limit', -20.0)  # 모니터링용
        monthly_loss_limit = getattr(self, 'monthly_loss_limit', -30.0)  # 모니터링용
        
        # 현재 날짜 확인
        if isinstance(current_date, str):
            current_date = pd.to_datetime(current_date)
        
        # 일일 손실 계산
        daily_pnl = 0.0
        for result in reversed(backtest_results):
            result_date = result.get('datetime', result.get('date', None))
            if isinstance(result_date, str):
                result_date = pd.to_datetime(result_date)
            
            if result_date and result_date.date() == current_date.date():
                profit_pct = result.get('profit_pct', 0)
                if profit_pct != 0 and result.get('actual_decision') in ['SELL', 'SELL_PROFIT', 'SELL_STOPLOSS', 'SELL_TRAILING']:
                    daily_pnl += profit_pct
        
        # 주간 손실 계산
        week_start = current_date - datetime.timedelta(days=7)
        weekly_pnl = 0.0
        for result in reversed(backtest_results):
            result_date = result.get('datetime', result.get('date', None))
            if isinstance(result_date, str):
                result_date = pd.to_datetime(result_date)
            
            if result_date and week_start.date() <= result_date.date() <= current_date.date():
                profit_pct = result.get('profit_pct', 0)
                if profit_pct != 0 and result.get('actual_decision') in ['SELL', 'SELL_PROFIT', 'SELL_STOPLOSS', 'SELL_TRAILING']:
                    weekly_pnl += profit_pct
        
        # 월간 손실 계산
        month_start = current_date - datetime.timedelta(days=30)
        monthly_pnl = 0.0
        for result in reversed(backtest_results):
            result_date = result.get('datetime', result.get('date', None))
            if isinstance(result_date, str):
                result_date = pd.to_datetime(result_date)
            
            if result_date and month_start.date() <= result_date.date() <= current_date.date():
                profit_pct = result.get('profit_pct', 0)
                if profit_pct != 0 and result.get('actual_decision') in ['SELL', 'SELL_PROFIT', 'SELL_STOPLOSS', 'SELL_TRAILING']:
                    monthly_pnl += profit_pct
        
        # 패턴 학습 모드: 손실 상태만 로깅, 거래는 계속
        if daily_pnl <= daily_loss_limit:
            print(f"📊 패턴학습: 일일 대손실 {daily_pnl:.2f}% 발생 - 계속 학습 중")
        
        if weekly_pnl <= weekly_loss_limit:
            print(f"📊 패턴학습: 주간 대손실 {weekly_pnl:.2f}% 발생 - 계속 학습 중")
        
        if monthly_pnl <= monthly_loss_limit:
            print(f"📊 패턴학습: 월간 대손실 {monthly_pnl:.2f}% 발생 - 계속 학습 중")
        
        # 현재 손실 상태 로깅
        if abs(daily_pnl) > 1.0 or abs(weekly_pnl) > 2.0:
            print(f"📊 패턴학습 손익 상태 - 일일: {daily_pnl:.2f}%, 주간: {weekly_pnl:.2f}%, 월간: {monthly_pnl:.2f}%")
        
        # 패턴 학습을 위해 항상 거래 허용
        return True


    def manage_adaptive_risk(self, profit_pct, consecutive_wins=0, consecutive_losses=0):
        """
        연속 성공/실패에 따른 리스크 수준 동적 조정
        
        Args:
            profit_pct: 현재 거래의 손익률
            consecutive_wins: 연속 성공 횟수
            consecutive_losses: 연속 실패 횟수
            
        Returns:
            float: 조정된 리스크 수준 (0.5~2.0)
        """
        # 기본 리스크 수준
        base_risk_level = 1.0
        
        # 연속 승/패에 따른 리스크 조정
        if not hasattr(self, 'consecutive_wins'):
            self.consecutive_wins = 0
        
        if not hasattr(self, 'consecutive_losses'):
            self.consecutive_losses = 0
        
        # 현재 거래 결과 반영
        if profit_pct > 0:
            self.consecutive_wins += 1
            self.consecutive_losses = 0
        elif profit_pct < 0:
            self.consecutive_losses += 1
            self.consecutive_wins = 0
        
        # 연속 성공 시 리스크 점진적 증가 (최대 2.0배)
        if self.consecutive_wins >= 3:
            risk_multiplier = min(2.0, 1.0 + (self.consecutive_wins - 2) * 0.1)
        # 연속 실패 시 리스크 점진적 감소 (최소 0.5배)
        elif self.consecutive_losses >= 2:
            risk_multiplier = max(0.5, 1.0 - (self.consecutive_losses - 1) * 0.1)
        else:
            risk_multiplier = 1.0
        
        # 최종 리스크 수준 계산
        adjusted_risk = base_risk_level * risk_multiplier
        
        # 추가 조정 로직 (예: 변동성에 따른 미세 조정 등)
        market_volatility = getattr(self, 'market_volatility', 0.05)  # 기본값 5%
        
        # 높은 변동성에서는 리스크 축소
        if market_volatility > 0.08:  # 8% 이상 변동성
            volatility_factor = 0.9
        # 낮은 변동성에서는 리스크 소폭 증가
        elif market_volatility < 0.03:  # 3% 미만 변동성
            volatility_factor = 1.1
        else:
            volatility_factor = 1.0
        
        final_risk = adjusted_risk * volatility_factor
        
        # 최종 리스크 수준 제한 (0.5~2.0 범위 유지)
        final_risk = max(0.5, min(2.0, final_risk))
        
        print(f"리스크 수준 조정: {final_risk:.2f}x (연속 성공: {self.consecutive_wins}, 연속 실패: {self.consecutive_losses})")
        
        return final_risk
    
    def calculate_pattern_quality_score(self, pattern):
        """
        개선된 패턴의 품질 점수 계산
        
        Args:
            pattern: 패턴 객체
            
        Returns:
            float: 0-100 사이의 품질 점수
        """
        if not pattern:
            return 0
        
        # 1. 성공률 점수 (40점 만점으로 축소)
        success_rate_score = 0
        
        if 'pattern_metrics' in pattern:
            metrics = pattern['pattern_metrics']
            success_count = metrics.get('success_count', 0)
            failure_count = metrics.get('failure_count', 0)
            total_count = success_count + failure_count
            
            if total_count > 0:
                success_rate = success_count / total_count
                # 성공률 점수 (0% -> 0점, 50% -> 20점, 100% -> 40점)
                success_rate_score = success_rate * 40
                
                # 최소 거래 횟수 페널티 완화
                if total_count < 3:  # 5 -> 3으로 완화
                    min_trades_penalty = (3 - total_count) * 2  # 거래당 2점 감소로 완화
                    success_rate_score = max(0, success_rate_score - min_trades_penalty)
        
        # 2. 샘플 크기 점수 (20점 만점)
        sample_size_score = 0
        
        if 'pattern_metrics' in pattern:
            metrics = pattern['pattern_metrics']
            success_count = metrics.get('success_count', 0)
            failure_count = metrics.get('failure_count', 0)
            total_count = success_count + failure_count
            
            # 샘플 크기 기준 완화
            if total_count >= 8:  # 10 -> 8로 완화
                sample_size_score = 20
            elif total_count >= 5:
                sample_size_score = 16  # 15 -> 16으로 증가
            elif total_count >= 3:
                sample_size_score = 12  # 10 -> 12로 증가
            elif total_count >= 2:  # 1 -> 2로 변경
                sample_size_score = 8   # 5 -> 8로 증가
            elif total_count >= 1:
                sample_size_score = 4   # 새로 추가
        
        # 3. 시장 환경 유사도 점수 (25점 만점으로 증가)
        market_similarity_score = 0
        
        pattern_trend = pattern.get('market_trend', '')
        current_trend = ''
        if hasattr(self, 'backtest_results') and self.backtest_results:
            recent_results = self.backtest_results[-5:]  # 10 -> 5로 축소
            for result in reversed(recent_results):
                if 'market_trend' in result:
                    current_trend = result['market_trend']
                    break
        
        # 추세 유사도 점수 (더 관대하게)
        if current_trend and pattern_trend:
            if current_trend == pattern_trend:
                market_similarity_score = 25
            elif ("uptrend" in current_trend and "uptrend" in pattern_trend) or \
                ("downtrend" in current_trend and "downtrend" in pattern_trend):
                market_similarity_score = 20  # 15 -> 20으로 증가
            elif ("neutral" in current_trend and ("weak" in pattern_trend or "consolidation" in pattern_trend)) or \
                (("weak" in current_trend or "consolidation" in current_trend) and "neutral" in pattern_trend):
                market_similarity_score = 15  # 10 -> 15로 증가
            else:
                market_similarity_score = 5   # 0 -> 5로 증가 (완전히 다른 추세도 약간의 점수)
        
        # 4. 최근성 점수 (15점 만점으로 증가)
        recency_score = 0
        
        pattern_date = None
        if 'timestamp' in pattern:
            pattern_date = pattern['timestamp']
        elif 'date' in pattern:
            pattern_date = pd.to_datetime(pattern['date'])
        
        current_date = datetime.datetime.now()
        
        if pattern_date:
            try:
                days_diff = (current_date - pattern_date).days
                
                # 최근성 기준 완화
                if days_diff <= 60:  # 30 -> 60일로 확대
                    recency_score = 15
                elif days_diff <= 120:  # 90 -> 120일로 확대
                    recency_score = 12  # 7 -> 12로 증가
                elif days_diff <= 240:  # 180 -> 240일로 확대
                    recency_score = 9   # 5 -> 9로 증가
                elif days_diff <= 365:
                    recency_score = 6   # 3 -> 6으로 증가
                else:
                    recency_score = 3   # 0 -> 3으로 증가 (완전히 오래된 패턴도 약간의 점수)
            except:
                recency_score = 5  # 0 -> 5로 증가
        
        # 총점 계산
        total_score = success_rate_score + sample_size_score + market_similarity_score + recency_score
        
        # 점수 로깅
        if hasattr(self, 'debug_mode') and self.debug_mode:
            print(f"개선된 패턴 품질 점수: {total_score:.1f}/100")
            print(f"- 성공률 점수: {success_rate_score:.1f}/40")
            print(f"- 샘플 크기 점수: {sample_size_score:.1f}/20")
            print(f"- 시장 유사도 점수: {market_similarity_score:.1f}/25")
            print(f"- 최근성 점수: {recency_score:.1f}/15")
        
        return total_score
    
    def filter_patterns_by_quality(self, similar_patterns, min_quality_score=70):
        """
        품질 점수를 기준으로 패턴 필터링
        
        Args:
            similar_patterns: 유사 패턴 목록
            min_quality_score: 최소 품질 점수 (기본값: 70)
            
        Returns:
            list: 품질 점수가 기준 이상인 패턴 목록
        """
        if not similar_patterns:
            return []
        
        # 품질 점수 계산 및 필터링
        quality_patterns = []
        
        for pattern in similar_patterns:
            # 품질 점수 계산
            quality_score = self.calculate_pattern_quality_score(pattern)
            
            # 점수를 패턴에 추가
            pattern['quality_score'] = quality_score
            
            # 최소 품질 점수 이상인지 확인
            if quality_score >= min_quality_score:
                quality_patterns.append(pattern)
        
        # 품질 점수 기준 내림차순 정렬
        quality_patterns.sort(key=lambda x: x.get('quality_score', 0), reverse=True)
        
        print(f"품질 점수 필터링: {len(quality_patterns)}/{len(similar_patterns)} 패턴 선택됨 (기준: {min_quality_score}점)")
        
        return quality_patterns
    
    def update_pattern_score(self, pattern_id, trade_result):
        """
        거래 결과에 따른 패턴 점수 업데이트
        
        Args:
            pattern_id: 패턴 ID
            trade_result: 거래 결과 객체
            
        Returns:
            bool: 업데이트 성공 여부
        """
        if not hasattr(self, 'document_store'):
            print("패턴 저장소가 초기화되지 않았습니다.")
            return False
        
        # 패턴 찾기
        target_pattern = None
        pattern_index = -1
        
        for i, pattern in enumerate(self.document_store):
            if pattern.get('pattern_id') == pattern_id:
                target_pattern = pattern
                pattern_index = i
                break
        
        if target_pattern is None:
            print(f"패턴 {pattern_id}를 찾을 수 없습니다.")
            return False
        
        # 이미 완료된 거래인지 확인
        if target_pattern.get('trade_result', {}).get('completed', False):
            print(f"패턴 {pattern_id}의 거래가 이미 완료되었습니다.")
            return False
        
        # 거래 결과 업데이트 (기존 함수와 동일)
        entry_price = target_pattern['trade_result'].get('entry_price')
        if entry_price is None:
            entry_price = target_pattern['price']
        
        exit_price = trade_result.get('exit_price', 0)
        if entry_price > 0 and exit_price > 0:
            profit_pct = ((exit_price / entry_price) - 1) * 100
            success = profit_pct > 0
            
            # 거래 결과 업데이트
            target_pattern['trade_result'].update({
                'completed': True,
                'exit_price': exit_price,
                'profit_pct': profit_pct,
                'success': success,
                'exit_reason': trade_result.get('exit_reason', 'UNKNOWN'),
                'exit_date': trade_result.get('exit_date', datetime.datetime.now().strftime("%Y-%m-%d")),
                'holding_days': self.calculate_holding_days(target_pattern['date'], trade_result.get('exit_date', datetime.datetime.now().strftime("%Y-%m-%d")))
            })
            
            # 패턴 메트릭 업데이트
            target_pattern['pattern_metrics'].update({
                'success_count': target_pattern['pattern_metrics']['success_count'] + (1 if success else 0),
                'failure_count': target_pattern['pattern_metrics']['failure_count'] + (0 if success else 1),
                'total_profit': target_pattern['pattern_metrics']['total_profit'] + profit_pct,
                'last_update': datetime.datetime.now().strftime("%Y-%m-%d")
            })
            
            # 평균 수익 및 성공률 재계산
            total_trades = target_pattern['pattern_metrics']['success_count'] + target_pattern['pattern_metrics']['failure_count']
            if total_trades > 0:
                target_pattern['pattern_metrics']['avg_profit'] = target_pattern['pattern_metrics']['total_profit'] / total_trades
                target_pattern['pattern_metrics']['success_rate'] = target_pattern['pattern_metrics']['success_count'] / total_trades * 100
            
            # 품질 점수 계산 (신규 추가)
            quality_score = self.calculate_pattern_quality_score(target_pattern)
            target_pattern['pattern_metrics']['quality_score'] = quality_score
            
            # 문서 저장소 업데이트
            self.document_store[pattern_index] = target_pattern
            print(f"패턴 {pattern_id} 거래 결과 및 품질 점수 업데이트: 수익={profit_pct:.2f}%, 성공={success}, 품질={quality_score:.1f}")
            
            return True
        else:
            print(f"패턴 {pattern_id}의 가격 정보가 올바르지 않습니다.")
            return False


    def update_pattern_with_trade_result(self, pattern_id, exit_price, exit_date, exit_reason):
        """거래 결과로 패턴 정보 업데이트
        
        Args:
            pattern_id: 패턴 고유 ID
            exit_price: 매도 가격
            exit_date: 매도 날짜
            exit_reason: 매도 이유 ('PROFIT', 'STOPLOSS', 'TRAILING', 'MANUAL')
        
        Returns:
            bool: 업데이트 성공 여부
        """
        if not hasattr(self, 'document_store'):
            print("Warning: document_store not initialized")
            return False
        
        # 해당 패턴 찾기
        target_pattern = None
        pattern_index = -1
        
        for i, pattern in enumerate(self.document_store):
            if pattern.get('pattern_id') == pattern_id:
                target_pattern = pattern
                pattern_index = i
                break
        
        if target_pattern is None:
            print(f"Pattern {pattern_id} not found in document store")
            return False
        
        # 이미 완료된 거래인지 확인
        if target_pattern.get('trade_result', {}).get('completed', False):
            print(f"Trade for pattern {pattern_id} already completed")
            return False
        
        # 진입 가격 확인
        entry_price = target_pattern['trade_result'].get('entry_price')
        if entry_price is None:
            print(f"No entry price for pattern {pattern_id}")
            entry_price = target_pattern['price']  # 패턴 저장 시 가격 사용
        
        # 결과 계산
        if entry_price > 0 and exit_price > 0:
            profit_pct = ((exit_price / entry_price) - 1) * 100
            success = profit_pct > 0
            
            # 거래 결과 업데이트
            target_pattern['trade_result'].update({
                'completed': True,
                'exit_price': exit_price,
                'profit_pct': profit_pct,
                'success': success,
                'exit_reason': exit_reason,
                'exit_date': exit_date.strftime("%Y-%m-%d") if isinstance(exit_date, datetime.datetime) else exit_date,
                'holding_days': self.calculate_holding_days(target_pattern['date'], exit_date)
            })
            
            # 패턴 메트릭 업데이트
            target_pattern['pattern_metrics'].update({
                'success_count': target_pattern['pattern_metrics']['success_count'] + (1 if success else 0),
                'failure_count': target_pattern['pattern_metrics']['failure_count'] + (0 if success else 1),
                'total_profit': target_pattern['pattern_metrics']['total_profit'] + profit_pct,
                'last_update': datetime.datetime.now().strftime("%Y-%m-%d")
            })
            
            # 평균 수익 및 성공률 재계산
            total_trades = target_pattern['pattern_metrics']['success_count'] + target_pattern['pattern_metrics']['failure_count']
            if total_trades > 0:
                target_pattern['pattern_metrics']['avg_profit'] = target_pattern['pattern_metrics']['total_profit'] / total_trades
                target_pattern['pattern_metrics']['success_rate'] = target_pattern['pattern_metrics']['success_count'] / total_trades * 100
            
            # 문서 저장소 업데이트
            self.document_store[pattern_index] = target_pattern
            print(f"Pattern {pattern_id} updated with trade result: profit={profit_pct:.2f}%, success={success}")
            
            # 신규: 바이너리 압축 형식으로 RAG 데이터 저장
            try:
                import pickle
                import gzip
                with gzip.open('rag_pattern_store.pkl.gz', 'wb') as f:
                    pickle.dump(self.document_store, f)
                print("RAG pattern store saved to compressed file")
            except Exception as e:
                print(f"Failed to save RAG pattern store: {str(e)}")
            
            return True
        else:
            print(f"Invalid prices for pattern {pattern_id}")
            return False



    def store_market_pattern(self, current_indicators, price, decision, context_date=None):
        """시장 패턴을 저장하는 함수 - 성공 패턴 학습을 위해 개선됨
        
        Args:
            current_indicators: 현재 기술적 지표
            price: 현재 가격
            decision: AI 결정 ('BUY', 'SELL', 'HOLD')
            context_date: 컨텍스트 날짜 (기본값: 현재)
        """
        # 현재 시장 추세 감지
        market_trend = self.detect_market_trend(current_indicators)
        
        # 지지선 정보 추가
        if price:
            support_analysis = self._check_near_support_level_enhanced("KRW-BTC", price)
        else:
            support_analysis = {}
        
        # 현재 날짜/시간 설정
        if context_date is None:
            current_datetime = datetime.datetime.now()
        else:
            current_datetime = context_date if isinstance(context_date, datetime.datetime) else pd.to_datetime(context_date)
        
        # 신규: 거래 ID 생성 (패턴과 결과 연결용)
        pattern_id = f"{current_datetime.strftime('%Y%m%d%H%M%S')}_{hash(str(current_indicators))}"
        
        # 패턴 저장 객체 생성
        new_context = {
            'pattern_id': pattern_id,  # 신규: 패턴 고유 ID
            'date': current_datetime.strftime("%Y-%m-%d"),
            'timestamp': current_datetime,
            'indicators': current_indicators,
            'price': price,  # 신규: 가격 정보 저장
            'market_trend': market_trend,
            'support_analysis': support_analysis,
            'ai_decision': decision,  # 신규: AI 결정 저장
            'content': f"Market shows {market_trend} with RSI at {current_indicators.get('RSI(14)', 'N/A')}. "
                    f"MACD is {current_indicators.get('MACD', 'N/A')}. "
                    f"Bollinger Bands: {current_indicators.get('Bollinger Bands', 'N/A')}. "
                    f"Moving Averages: {current_indicators.get('Moving Averages', 'N/A')}. "
                    f"Support level nearby: {support_analysis.get('is_near_support', False)}, "
                    f"Support strength: {support_analysis.get('strength', 0):.2f}.",
            'trade_result': {  # 신규: 거래 결과 저장 영역
                'completed': False,  # 거래 완료 여부
                'entry_price': price if decision == 'BUY' else None,
                'exit_price': None,
                'profit_pct': None,
                'success': None,
                'exit_reason': None,
                'holding_days': None
            },
            'pattern_metrics': {  # 신규: 패턴 메트릭
                'success_count': 0,
                'failure_count': 0,
                'total_profit': 0,
                'avg_profit': 0,
                'success_rate': 0,
                'last_update': current_datetime.strftime("%Y-%m-%d"),
                'usage_count': 0  # 이 패턴이 참조된 횟수
            }
        }
        
        # 중복 방지를 위한 검사 (pattern_id 기반)
        if not hasattr(self, 'document_store'):
            self.document_store = []
            
        existing_index = -1
        for i, doc in enumerate(self.document_store):
            if doc.get('pattern_id') == pattern_id:
                existing_index = i
                break
        
        if existing_index >= 0:
            # 기존 항목 업데이트
            self.document_store[existing_index] = new_context
            print(f"Pattern {pattern_id} updated in document store")
        else:
            # 새 항목 추가
            self.document_store.append(new_context)
            print(f"New pattern {pattern_id} added to document store")
        
        return pattern_id  # 신규: 저장된 패턴의 ID 반환
            
    def reset(self):
        """백테스트 시작 전 상태 초기화"""
        self.historical_data = []
        self.backtest_results = []
        self.processed_timestamps = set()
        self.document_store = []
        self.consecutive_losses = 0
        self.stop_loss_streak = 0
        self.cooldown_until = -1
        self.recovery_factor = 1.0
        self.trailing_stop_price = 0.0
        print("백테스터 상태가 초기화되었습니다.")

    def calculate_holding_days(self, entry_date, exit_date):
        """
        두 날짜 사이의 일수를 계산하는 함수
        
        Args:
            entry_date (str): 진입 날짜 (YYYY-MM-DD 또는 YYYY-MM-DD HH:MM:SS 형식)
            exit_date (str): 종료 날짜 (YYYY-MM-DD 또는 YYYY-MM-DD HH:MM:SS 형식)
            
        Returns:
            int: 보유 기간(일)
        """
        try:
            # 날짜 포맷 정규화 (시간 부분이 있는 경우 처리)
            if ' ' in entry_date:
                entry_date = entry_date.split(' ')[0]
            if ' ' in exit_date:
                exit_date = exit_date.split(' ')[0]
            
            entry_dt = pd.to_datetime(entry_date)
            exit_dt = pd.to_datetime(exit_date)
            
            # 날짜 차이 계산
            delta = exit_dt - entry_dt
            return max(0, delta.days)
        except Exception as e:
            print(f"날짜 계산 오류: {str(e)}")
            return 0
    def load_daily_data(self, target_date, timeframe='1h'):
        """
        명확하게 특정 날짜의 데이터만 로드하는 함수
        
        Args:
            target_date: 대상 날짜 (YYYY-MM-DD)
            timeframe: '1m', '15m', '1h' 등
        """
        try:
            # 날짜 형식 변환
            if isinstance(target_date, str):
                date_obj = pd.to_datetime(target_date)
            else:
                date_obj = target_date
                
            # 다음날 계산 (하루치 데이터 요청)
            next_day = date_obj + datetime.timedelta(days=1)
            
            print(f"로딩 중: {date_obj.strftime('%Y-%m-%d')}의 {timeframe} 데이터")
            
            # 시간 프레임별 데이터 포인트 계산
            timeframe_map = {
                '1m': 1440,     # 하루 = 24시간 * 60분
                '15m': 96,      # 하루 = 24시간 * 4 (15분단위)
                '1h': 24,       # 하루 = 24시간
                '4h': 6,        # 하루 = 24시간 / 4
                '1d': 1         # 하루 = 1일
            }
            
            count = timeframe_map.get(timeframe, 24)
            
            # 정확한 범위 지정을 위해 from과 to 모두 명시
            from_date = date_obj.strftime('%Y-%m-%d')
            to_date = next_day.strftime('%Y-%m-%d')
            
            print(f"데이터 요청 범위: {from_date} ~ {to_date}")
            
            # pyupbit로 데이터 가져오기 (정확한 날짜 범위 지정)
            df = pyupbit.get_ohlcv(
                "KRW-BTC", 
                interval=timeframe, 
                count=count, 
                to=to_date
            )
            
            # 데이터 필터링 - 요청한 날짜에 해당하는 데이터만 유지
            if df is not None and not df.empty:
                # 날짜 필드 추가
                df['date'] = df.index.strftime('%Y-%m-%d %H:%M:%S')
                
                # 요청 날짜에 해당하는 데이터만 필터링
                filtered_df = df[df.index.date == date_obj.date()]
                
                if not filtered_df.empty:
                    print(f"성공: {len(filtered_df)}개 {timeframe} 데이터 로드됨 (필터링 전: {len(df)})")
                    return filtered_df
                else:
                    print(f"경고: {date_obj.strftime('%Y-%m-%d')} 데이터 없음 (필터링 후)")
                    return pd.DataFrame()
            else:
                print(f"경고: {date_obj.strftime('%Y-%m-%d')} 데이터 없음")
                return pd.DataFrame()
                    
        except Exception as e:
            print(f"오류: 데이터 로딩 실패 {str(e)}")
            return pd.DataFrame()

    def load_weekly_data(self, start_date, timeframe='1h'):
        """
        주별 데이터 로딩 (메모리 효율성 향상)
        
        Args:
            start_date: 시작 날짜
            timeframe: '1m', '15m', '1h' 등
        """
        try:
            # 시간 프레임별 데이터 포인트 계산
            timeframe_map = {
                '1m': 10080,    # 1주일 = 7일 * 24시간 * 60분
                '15m': 672,     # 1주일 = 7일 * 24시간 * 4 (15분단위)
                '1h': 168,      # 1주일 = 7일 * 24시간
                '4h': 42,       # 1주일 = 7일 * 6 (4시간단위)
                '1d': 7         # 1주일 = 7일
            }
            
            count = timeframe_map.get(timeframe, 168)
            
            # 주 끝날 계산
            week_end = pd.to_datetime(start_date) + datetime.timedelta(days=7)
            
            # 데이터 가져오기
            df = pyupbit.get_ohlcv("KRW-BTC", interval=timeframe, count=count, to=week_end.strftime('%Y-%m-%d'))
            
            if df is not None and not df.empty:
                df['date'] = df.index.strftime('%Y-%m-%d %H:%M:%S')
                return df
            else:
                print(f"No data retrieved for week starting {start_date}")
                return pd.DataFrame()
                
        except Exception as e:
            print(f"Error loading weekly data: {str(e)}")
            return pd.DataFrame()

    def check_support_trigger(self, current_price, timestamp):
        """
        지지선 도달 여부 체크 (AI 호출 트리거)
        
        Returns:
            bool: 지지선 근처 도달 시 True
        """
        try:
            # 지지선 계산
            support_levels = self._calculate_enhanced_support_levels("KRW-BTC")
            
            if not support_levels:
                return False
            
            # 지지선과의 거리 체크
            closest_distance = float('inf')
            for support in support_levels:
                if support > 0:
                    distance_pct = abs((current_price - support) / current_price) * 100
                    closest_distance = min(closest_distance, distance_pct)
            
            # 지지선 3% 이내 도달 시 트리거
            is_triggered = closest_distance <= 3.0
            
            if is_triggered:
                print(f"[TRIGGER] Support level reached at {timestamp}")
                print(f"Price: ₩{current_price:,.0f}, Distance: {closest_distance:.2f}%")
            
            return is_triggered
            
        except Exception as e:
            print(f"Error checking support trigger: {str(e)}")
            return False


    def collect_all_news_for_period(self, start_date, end_date):
        """백테스팅 시작 전 전체 기간 뉴스 사전 수집"""
        print(f"Collecting all news for period: {start_date} to {end_date}")
        
        self.news_database = {}
        self.news_correlations = {}
        
        current_date = pd.to_datetime(start_date)
        end_dt = pd.to_datetime(end_date)
        
        while current_date <= end_dt:
            date_str = current_date.strftime('%Y-%m-%d')
            
            # 해당 날짜 뉴스 수집
            news_data = self.fetch_news("BTC", current_date, current_date + datetime.timedelta(days=1))
            
            if news_data:
                self.news_database[date_str] = news_data
                print(f"Collected {len(news_data)} news for {date_str}")
            
            current_date += datetime.timedelta(days=1)
            time.sleep(0.1)  # API 제한 고려
        
        print(f"Total news collection complete: {len(self.news_database)} days")
        return self.news_database


    def analyze_with_llm_with_context(self, coin, price, tech_indicators, news_data, analysis_context, test_mode=False):
        """컨텍스트 정보를 포함한 3단계 AI 분석 - 백테스트 모드 지원 강화"""
        if not self.llm:
            return {"signal": "ERROR", "analysis": "LLM not initialized", "confidence": 0}

        print("\n" + "="*70)
        print(f"🚀 STARTING 3-STAGE AI ANALYSIS WITH CONTEXT - {coin}")
        print(f"Context: {analysis_context['current_date']} {analysis_context.get('current_time', '')}")
        print("="*70)

        # 기존 분석들 (그대로 유지)
        market_trend = self.detect_market_trend(tech_indicators)
        news_sentiment = self.analyze_news_sentiment(news_data)
        support_analysis = self._check_near_support_level_enhanced(coin, price)

        # 현재 시점 정보 - 컨텍스트에서 가져오기
        current_datetime = analysis_context.get('current_datetime')
        if current_datetime is None:
            # 컨텍스트에 datetime이 없으면 날짜/시간 정보 조합
            if 'current_date' in analysis_context:
                date_str = analysis_context['current_date']
                time_str = analysis_context.get('current_time', '00:00:00')
                try:
                    current_datetime = pd.to_datetime(f"{date_str} {time_str}")
                except:
                    current_datetime = datetime.datetime.now()
            else:
                current_datetime = datetime.datetime.now()
        
        print(f"[CONTEXT] Using datetime: {current_datetime.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"[CONTEXT] Backtest mode: {analysis_context.get('backtest_mode', False)}")

        # === 1단계: 뉴스 요약 ===
        news_context = self.get_news_context_for_ai(current_datetime, lookback_days=3)
        news_summary = self.summarize_news_with_ai(news_context)

        # === 2단계: 종합 분석 + 결정 ===
        # 컨텍스트 정보 포함하여 호출
        comprehensive_analysis = self.comprehensive_analysis_with_ai_with_context(
            coin, price, tech_indicators, news_summary, support_analysis, analysis_context
        )

        # === 3단계: JSON 추출 ===
        decision_result = self.extract_trading_decision(comprehensive_analysis)

        # === 결과 처리 ===
        decision = decision_result.get('decision', 'HOLD')
        profit_target = decision_result.get('profit_target', 5.0)
        stop_loss = decision_result.get('stop_loss', -2.0)
        trailing_stop = decision_result.get('trailing_stop', 1.0)
        confidence = decision_result.get('confidence', 0.5)
        reasoning = decision_result.get('reasoning', 'AI 3-stage analysis with context completed')

        # 손절가 음수 검증
        if stop_loss > 0:
            print(f"WARNING: Stop loss was positive ({stop_loss}%), converting to negative")
            stop_loss = -abs(stop_loss)

        # 동적 파라미터 조정 (기존 코드)
        confluence_signals = self._calculate_confluence_score(tech_indicators, news_sentiment, support_analysis, market_trend)
        market_regime = self._detect_market_regime(tech_indicators, self.get_recent_market_context())

        # 백테스트 모드에서는 파라미터 조정을 다르게 할 수 있음
        if analysis_context.get('backtest_mode', False):
            # 백테스트 특화 파라미터 조정 (예: 더 보수적인 설정)
            profit_target, stop_loss, trailing_stop = self._apply_dynamic_parameters_for_backtest(
                profit_target, stop_loss, trailing_stop, 
                confluence_signals, market_regime, analysis_context
            )
        else:
            # 일반 거래 파라미터 조정
            profit_target, stop_loss, trailing_stop = self._apply_dynamic_parameters(
                profit_target, stop_loss, trailing_stop, 
                confluence_signals, market_regime, {}
            )

        # === 최종 결과 출력 ===
        print("🎯 FINAL TRADING DECISION WITH CONTEXT:")
        print("="*70)
        print(f"SIGNAL: {decision}")
        print(f"CONFIDENCE: {confidence:.2f}")
        print(f"PROFIT TARGET: {profit_target}%")
        print(f"STOP LOSS: {stop_loss}%")
        print(f"TRAILING STOP: {trailing_stop}%")
        print(f"MARKET TREND: {market_trend}")
        print(f"NEWS SUMMARY: {news_summary[:100]}...")
        print(f"CONTEXT DATE: {current_datetime.strftime('%Y-%m-%d %H:%M:%S')}")
        print("="*70)
        print()

        # 현재 패턴을 document_store에 추가 (RAG 학습)
        if tech_indicators:
            # 현재 시장 추세 감지
            market_trend = self.detect_market_trend(tech_indicators)
            
            # 지지선 정보 추가
            current_price_val = price
            
            if current_price_val:
                support_analysis_for_rag = self._check_near_support_level_enhanced(coin, current_price_val)
            else:
                support_analysis_for_rag = {}
            
            new_context = {
                'date': current_datetime.strftime("%Y-%m-%d"),
                'timestamp': current_datetime,
                'indicators': tech_indicators,
                'market_trend': market_trend,
                'support_analysis': support_analysis_for_rag,
                'content': f"Market shows {market_trend} with RSI at {tech_indicators.get('RSI(14)', 'N/A')}. "
                        f"MACD is {tech_indicators.get('MACD', 'N/A')}. "
                        f"Bollinger Bands: {tech_indicators.get('Bollinger Bands', 'N/A')}. "
                        f"Moving Averages: {tech_indicators.get('Moving Averages', 'N/A')}. "
                        f"Support level nearby: {support_analysis_for_rag.get('is_near_support', False)}, "
                        f"Support strength: {support_analysis_for_rag.get('strength', 0):.2f}."
            }
            
            # 중복 방지를 위한 검사
            existing_index = -1
            
            # document_store가 없으면 초기화
            if not hasattr(self, 'document_store'):
                self.document_store = []
                
            for i, doc in enumerate(self.document_store):
                if doc.get('date') == new_context['date']:
                    existing_index = i
                    break
            
            if existing_index >= 0:
                # 기존 항목 업데이트
                self.document_store[existing_index] = new_context
            else:
                # 새 항목 추가
                self.document_store.append(new_context)

        # 기존 형식으로 반환 (컨텍스트 정보 추가)
        return {
            "signal": decision,
            "profit_target": profit_target,
            "stop_loss": stop_loss,
            "trailing_stop": trailing_stop,
            "analysis": comprehensive_analysis,  # 2단계 전체 텍스트
            "confidence": confidence,
            "market_trend": market_trend,
            "news_sentiment": news_sentiment,
            "reasoning": reasoning,
            "support_analysis": support_analysis,
            "news_summary": news_summary,  # 1단계 결과
            "confluence_score": confluence_signals.get('total_score', 0),
            "market_regime": market_regime,
            "context_date": current_datetime.strftime('%Y-%m-%d %H:%M:%S'),
            "backtest_mode": analysis_context.get('backtest_mode', False)
        }



    def analyze_news_price_correlations(self, minute_data):
        """뉴스와 가격 변화의 상관관계 사전 분석 - 타임존 처리 개선"""
        correlations = {}
        
        for date_str, news_list in self.news_database.items():
            for news in news_list:
                try:
                    # 뉴스 시간을 naive datetime으로 변환
                    news_time = pd.to_datetime(news['publishedAt'])
                    if hasattr(news_time, 'tz') and news_time.tz is not None:
                        news_time = news_time.tz_localize(None)
                    
                    # 뉴스 발생 후 가격 변화 계산
                    price_impacts = self._calculate_price_impacts_after_news(news_time, minute_data)
                    
                    # 뉴스 감성 분석
                    sentiment = self.analyze_news_sentiment([news])
                    
                    correlation_data = {
                        'news_id': news.get('url', str(hash(news['title']))),
                        'timestamp': news_time,
                        'title': news['title'],
                        'sentiment_score': sentiment['sentiment_score'],
                        'themes': sentiment.get('key_topics', []),
                        'price_impact_1h': price_impacts.get('1h', 0),
                        'price_impact_6h': price_impacts.get('6h', 0),
                        'price_impact_24h': price_impacts.get('24h', 0),
                        'volume_impact': price_impacts.get('volume', 0)
                    }
                    
                    correlations[news_time.isoformat()] = correlation_data
                    
                except Exception as e:
                    print(f"Error analyzing news correlation: {str(e)}")
                    continue
        
        self.news_correlations = correlations
        print(f"Analyzed correlations for {len(correlations)} news items")
        return correlations

    def _calculate_price_impacts_after_news(self, news_time, price_data):
        """
        뉴스 발생 후 가격 영향 계산
        
        Args:
            news_time: 뉴스 발행 시간
            price_data: 가격 데이터 목록
            
        Returns:
            dict: 각 기간별 가격 영향 비율
        """
        try:
            # 타임존 처리 - 올바른 방법으로 수정
            if hasattr(news_time, 'tz') and news_time.tz is not None:
                # timezone-aware를 timezone-naive로 변환
                news_time = news_time.tz_localize(None)
            
            # 문자열인 경우 datetime으로 변환
            if isinstance(news_time, str):
                news_time = pd.to_datetime(news_time)
            
            # price_data의 datetime 필드들도 통일
            processed_data = []
            for data in price_data:
                data_datetime = data.get('datetime')
                if data_datetime is not None:
                    # 문자열이라면 먼저 datetime으로 변환
                    if isinstance(data_datetime, str):
                        data_datetime = pd.to_datetime(data_datetime)
                    
                    # timezone aware라면 naive로 변환
                    if hasattr(data_datetime, 'tz') and data_datetime.tz is not None:
                        data_datetime = data_datetime.tz_localize(None)
                    
                    processed_data.append({
                        'datetime': data_datetime,
                        'close': data.get('close', 0),
                        'volume': data.get('volume', 0)
                    })
            
            # 뉴스 시점 가격 찾기
            news_price = None
            news_index = None
            
            for i, data in enumerate(processed_data):
                if data['datetime'] >= news_time:
                    news_price = data['close']
                    news_index = i
                    break
            
            if news_price is None or news_price == 0:
                return {}
            
            # 뉴스 시점 이후 각 시간대별 가격 영향 계산
            impacts = {}
            time_frames = {'1h': 1, '6h': 6, '24h': 24}
            
            for timeframe, hours in time_frames.items():
                target_time = news_time + datetime.timedelta(hours=hours)
                
                # 해당 시간의 가격 찾기
                for data in processed_data:
                    if data['datetime'] >= target_time:
                        later_price = data['close']
                        if later_price > 0 and news_price > 0:
                            impacts[timeframe] = ((later_price / news_price) - 1) * 100
                        break
            
            # 거래량 변화 계산
            if news_index is not None and news_index > 0 and len(processed_data) > news_index + 6:
                # 뉴스 전 평균 거래량
                pre_avg_volume = sum(data['volume'] for data in processed_data[max(0, news_index-6):news_index]) / min(6, news_index)
                
                # 뉴스 후 평균 거래량
                post_avg_volume = sum(data['volume'] for data in processed_data[news_index:news_index+6]) / min(6, len(processed_data)-news_index)
                
                # 거래량 변화율
                if pre_avg_volume > 0:
                    impacts['volume'] = ((post_avg_volume / pre_avg_volume) - 1) * 100
            
            return impacts
            
        except Exception as e:
            print(f"가격 영향 계산 오류: {str(e)}")
            return {}


    def get_news_context_for_ai(self, current_datetime, lookback_days=3):
        """
        AI에게 제공할 뉴스 컨텍스트 구성 - 실시간 분석 활용
        
        Args:
            current_datetime: 현재 시점
            lookback_days: 몇일 전 뉴스까지 포함할지
            
        Returns:
            dict: 뉴스 컨텍스트 정보
        """
        relevant_news = []
        seen_urls = set()  # URL 중복 체크용
        seen_titles = set()  # 제목 중복 체크용
        
        # current_datetime을 naive로 변환
        if hasattr(current_datetime, 'tz') and current_datetime.tz is not None:
            current_datetime = current_datetime.tz_localize(None)
        
        # current_datetime이 string인 경우 datetime으로 변환
        if isinstance(current_datetime, str):
            current_datetime = pd.to_datetime(current_datetime)
        
        print(f"[NEWS CONTEXT] Looking for news around {current_datetime}")
        
        # 시간 범위 설정
        start_date = current_datetime - datetime.timedelta(days=lookback_days)
        
        # 필터링된 뉴스 가져오기
        try:
            # 현재 시점의 뉴스 검색
            news_data = self.fetch_news("BTC", start_date, current_datetime)
            
            # 중복 제거하면서 뉴스 추가
            for news in news_data:
                news_url = news.get('url', '')
                news_title = news.get('title', '')
                
                # URL 또는 제목 기반 중복 체크
                if news_url and news_url not in seen_urls:
                    relevant_news.append(news)
                    seen_urls.add(news_url)
                    seen_titles.add(news_title)
                elif not news_url and news_title and news_title not in seen_titles:
                    relevant_news.append(news)
                    seen_titles.add(news_title)
        except Exception as e:
            print(f"뉴스 데이터 가져오기 오류: {str(e)}")
        
        # 상관관계 분석된 뉴스만 사용해 컨텍스트 구성
        news_with_correlation = []
        
        if hasattr(self, 'news_correlations') and self.news_correlations:
            # news_correlations에서 최근 항목만 필터링
            for news_id, news_info in self.news_correlations.items():
                try:
                    news_time = pd.to_datetime(news_info.get('timestamp', ''))
                    
                    # 지정된 시간 범위 내의 뉴스만 필터링
                    if start_date <= news_time <= current_datetime:
                        news_with_correlation.append({
                            'title': news_info.get('title', ''),
                            'published': news_info.get('timestamp', ''),
                            'sentiment': news_info.get('sentiment_score', 0),
                            'predicted_impact': {
                                'direction': 'positive' if news_info.get('price_impact_6h', 0) > 0 else 'negative',
                                'magnitude': abs(news_info.get('price_impact_6h', 0)),
                                'confidence': min(0.9, 0.4 + abs(news_info.get('sentiment_score', 0))),
                            },
                            'themes': news_info.get('themes', [])
                        })
                except Exception as e:
                    print(f"상관관계 뉴스 처리 오류: {str(e)}")
        
        # 상관관계 정보가 없는 경우 기본 분석 실행
        if not news_with_correlation:
            print("상관관계 데이터 없음, 기본 뉴스 분석 실행")
            for news in relevant_news[:5]:  # 최대 5개만 처리
                try:
                    news_sentiment = self.analyze_news_sentiment([news])
                    predicted_impact = self._predict_news_impact(news, news_sentiment)
                    
                    news_with_correlation.append({
                        'title': news.get('title', '')[:100],
                        'published': news.get('publishedAt', ''),
                        'sentiment': news_sentiment['sentiment_score'],
                        'predicted_impact': predicted_impact,
                        'themes': news_sentiment.get('key_topics', [])
                    })
                except Exception as e:
                    print(f"뉴스 항목 처리 오류: {str(e)}")
                    continue
        
        # 전체 감성 점수 계산
        overall_sentiment = 0
        if news_with_correlation:
            sentiment_scores = [news['sentiment'] for news in news_with_correlation]
            overall_sentiment = sum(sentiment_scores) / len(sentiment_scores) if sentiment_scores else 0
        
        return {
            'news_count': len(relevant_news),
            'overall_sentiment': overall_sentiment,
            'top_news': news_with_correlation[:5],  # 상위 5개만 사용
            'sentiment_summary': self._categorize_sentiment(overall_sentiment)
        }
    




    def _predict_news_impact(self, news, sentiment_analysis):
        """과거 상관관계 데이터를 바탕으로 뉴스 영향 예측 - 개선된 버전"""
        # news_correlations가 없는 경우 기본값 반환
        if not hasattr(self, 'news_correlations') or not self.news_correlations:
            print("Warning: news_correlations not available, using default prediction")
            current_sentiment = sentiment_analysis['sentiment_score']
            
            # 뉴스 제목 키워드 분석으로 추가 예측 정보 제공
            title = news.get('title', '').lower()
            
            # 키워드 기반 영향도 조정
            high_impact_keywords = ['breakout', 'surge', 'crash', 'rally', 'institutional', 'adoption']
            keyword_impact = any(keyword in title for keyword in high_impact_keywords)
            
            # 기본 예측 강도 계산
            base_magnitude = abs(current_sentiment * 5)
            
            # 키워드가 있으면 영향도 증가
            if keyword_impact:
                base_magnitude *= 1.5
            
            # 간단한 감성 기반 예측
            if current_sentiment > 0.3:
                return {
                    'direction': 'positive', 
                    'magnitude': min(base_magnitude, 10),  # 최대 10으로 제한
                    'confidence': 0.5 + (0.2 if keyword_impact else 0)
                }
            elif current_sentiment < -0.3:
                return {
                    'direction': 'negative', 
                    'magnitude': min(base_magnitude, 10),
                    'confidence': 0.5 + (0.2 if keyword_impact else 0)
                }
            else:
                return {
                    'direction': 'neutral', 
                    'magnitude': 0, 
                    'confidence': 0.3
                }
        
        # 기존 로직 (뉴스 상관관계가 있는 경우)
        similar_impacts = []
        current_sentiment = sentiment_analysis['sentiment_score']
        
        # 뉴스 제목이나 내용에서 추가 컨텍스트 추출
        news_title = news.get('title', '').lower()
        news_desc = news.get('description', '').lower()
        news_content = f"{news_title} {news_desc}"
        
        for correlation in self.news_correlations.values():
            sentiment_diff = abs(correlation['sentiment_score'] - current_sentiment)
            
            # 감성뿐만 아니라 뉴스 유형도 비교
            if sentiment_diff < 0.3:  # 유사한 감성
                # 뉴스 제목 유사도도 확인 (선택적)
                correlation_title = correlation.get('title', '').lower()
                
                # 공통 키워드가 있는 경우 가중치 증가
                common_keywords = ['bitcoin', 'btc', 'crypto', 'price', 'market']
                has_common_context = any(keyword in news_content and keyword in correlation_title 
                                    for keyword in common_keywords)
                
                impact = correlation.get('price_impact_6h', 0)
                if has_common_context:
                    similar_impacts.append(impact * 1.1)  # 10% 가중치 증가
                else:
                    similar_impacts.append(impact)
        
        if similar_impacts:
            avg_impact = sum(similar_impacts) / len(similar_impacts)
            
            # 뉴스 소스의 신뢰도도 고려
            source = news.get('source', '').lower()
            trusted_sources = ['coindesk', 'cointelegraph', 'reuters', 'bloomberg']
            source_multiplier = 1.2 if any(trusted in source for trusted in trusted_sources) else 1.0
            
            return {
                'direction': 'positive' if avg_impact > 0 else 'negative' if avg_impact < 0 else 'neutral',
                'magnitude': abs(avg_impact) * source_multiplier,
                'confidence': min(len(similar_impacts) / 10, 1.0) * 100,
                'source_reliability': source_multiplier
            }
        
        # 상관관계 데이터가 없지만 뉴스 자체 분석
        return {
            'direction': 'positive' if current_sentiment > 0 else 'negative' if current_sentiment < 0 else 'neutral',
            'magnitude': abs(current_sentiment * 3),  # 보수적 예측
            'confidence': 0.4,  # 중간 신뢰도
            'note': 'Based on sentiment analysis only'
        }

    def _categorize_sentiment(self, sentiment_score):
        """감성 점수를 카테고리화"""
        if sentiment_score > 0.3:
            return "strongly positive"
        elif sentiment_score > 0.1:
            return "moderately positive"
        elif sentiment_score < -0.3:
            return "strongly negative"
        elif sentiment_score < -0.1:
            return "moderately negative"
        else:
            return "neutral"

    def get_pattern_based_advice(self, similar_patterns):
        """유사 패턴 분석을 통한 거래 조언 생성
        
        Args:
            similar_patterns: 유사 패턴 목록
        
        Returns:
            dict: 패턴 기반 거래 조언
        """
        if not similar_patterns:
            return {
                'recommendation': 'INSUFFICIENT_DATA',
                'confidence': 0.0,
                'reasoning': 'No similar patterns found',
                'profit_expectation': 0.0,
                'params': {
                    'profit_target': 5.0,
                    'stop_loss': -2.0,
                    'trailing_stop': 1.0
                }
            }
        
        # 1. 완료된 거래만 필터링
        completed_patterns = [p for p in similar_patterns if p.get('trade_result', {}).get('completed', False)]
        
        if not completed_patterns:
            print("Warning: No completed trades in similar patterns")
            return {
                'recommendation': 'INSUFFICIENT_DATA',
                'confidence': 0.0,
                'reasoning': 'Similar patterns found but no completed trades',
                'profit_expectation': 0.0,
                'params': {
                    'profit_target': 5.0,
                    'stop_loss': -2.0,
                    'trailing_stop': 1.0
                }
            }
        
        # 2. 패턴 통계 계산
        successful_patterns = [p for p in completed_patterns if p.get('trade_result', {}).get('success', False)]
        failed_patterns = [p for p in completed_patterns if not p.get('trade_result', {}).get('success', False)]
        
        # 승률 계산
        win_rate = len(successful_patterns) / len(completed_patterns) if completed_patterns else 0
        
        # 평균 수익/손실 계산
        avg_profit = sum(p.get('trade_result', {}).get('profit_pct', 0) for p in successful_patterns) / len(successful_patterns) if successful_patterns else 0
        avg_loss = sum(p.get('trade_result', {}).get('profit_pct', 0) for p in failed_patterns) / len(failed_patterns) if failed_patterns else 0
        
        # 기대 수익 계산
        expected_profit = (win_rate * avg_profit) + ((1 - win_rate) * avg_loss)
        
        # 3. 결정 규칙
        # 승률이 50% 이상이고 기대 수익이 양수면 BUY
        if win_rate >= 0.5 and expected_profit > 0:
            recommendation = 'BUY'
            confidence = min(0.95, win_rate + (expected_profit / 20))  # 최대 0.95
            reasoning = f"Based on {len(completed_patterns)} similar patterns with {win_rate:.0%} win rate and {expected_profit:.2f}% expected profit"
        # 승률이 낮지만 기대 수익이 높은 경우 (높은 리스크/리워드)
        elif win_rate < 0.5 and expected_profit > 1.5:
            recommendation = 'BUY'
            confidence = 0.5 + (expected_profit / 30)  # 중간 정도 확신
            reasoning = f"High risk/reward opportunity based on {len(completed_patterns)} similar patterns with {expected_profit:.2f}% expected profit despite {win_rate:.0%} win rate"
        # 승률이 낮고 기대 수익도 낮거나 음수인 경우
        else:
            recommendation = 'HOLD'
            confidence = 0.5 + (abs(expected_profit) / 20) if expected_profit < 0 else 0.5
            reasoning = f"Avoiding risk based on {len(completed_patterns)} similar patterns with {win_rate:.0%} win rate and {expected_profit:.2f}% expected profit"
        
        # 4. 최적 파라미터 계산
        # 수익 패턴에서 최적 파라미터 추출
        if successful_patterns:
            # 가장 수익이 좋았던 상위 3개 패턴에서 파라미터 추출
            top_patterns = sorted(successful_patterns, key=lambda p: p.get('trade_result', {}).get('profit_pct', 0), reverse=True)[:3]
            
            # 가중 평균 계산
            total_weight = sum(p.get('trade_result', {}).get('profit_pct', 0) for p in top_patterns)
            profit_targets = []
            stop_losses = []
            trailing_stops = []
            
            for p in top_patterns:
                profit_pct = p.get('trade_result', {}).get('profit_pct', 0)
                weight = profit_pct / total_weight if total_weight > 0 else 1/len(top_patterns)
                
                # 원래 목표 파라미터 추정
                exit_reason = p.get('trade_result', {}).get('exit_reason', '')
                
                if exit_reason == 'PROFIT':
                    # 익절 목표는 실제 수익보다 약간 높게 설정
                    profit_targets.append((profit_pct * 1.1) * weight)
                elif exit_reason == 'TRAILING':
                    # 트레일링 스탑은 실제 수익의 비율로 추정
                    trailing_stops.append((profit_pct * 0.3) * weight)
                
                # 손절매는 평균 손실에서 추정
                if failed_patterns:
                    avg_failed = abs(sum(p.get('trade_result', {}).get('profit_pct', 0) for p in failed_patterns) / len(failed_patterns))
                    stop_losses.append(-avg_failed * 1.2 * weight)  # 약간 여유있게 설정
                else:
                    stop_losses.append(-2.0 * weight)  # 기본값
            
            # 최종 파라미터 계산
            optimized_params = {
                'profit_target': sum(profit_targets) if profit_targets else 5.0,
                'stop_loss': sum(stop_losses) if stop_losses else -2.0,
                'trailing_stop': sum(trailing_stops) if trailing_stops else 1.0
            }
        else:
            # 기본 파라미터
            optimized_params = {
                'profit_target': 5.0,
                'stop_loss': -2.0,
                'trailing_stop': 1.0
            }
        
        # 5. 최종 조언 구성
        advice = {
            'recommendation': recommendation,
            'confidence': confidence,
            'reasoning': reasoning,
            'win_rate': win_rate,
            'avg_profit': avg_profit,
            'avg_loss': avg_loss,
            'profit_expectation': expected_profit,
            'similar_patterns_count': len(completed_patterns),
            'params': optimized_params
        }
        
        return advice

    def save_rag_patterns(self, file_path="rag_pattern_store.pkl.gz"):
        """RAG 패턴 데이터를 압축하여 저장
        
        Args:
            file_path: 저장할 파일 경로
        
        Returns:
            bool: 저장 성공 여부
        """
        if not hasattr(self, 'document_store') or not self.document_store:
            print("Warning: No patterns to save")
            return False
        
        try:
            import pickle
            import gzip
            with gzip.open(file_path, 'wb') as f:
                pickle.dump(self.document_store, f)
            print(f"Successfully saved {len(self.document_store)} patterns to {file_path}")
            return True
        except Exception as e:
            print(f"Error saving RAG patterns: {str(e)}")
            return False

    def load_rag_patterns(self, file_path="rag_pattern_store.pkl.gz"):
        """저장된 RAG 패턴 데이터 로드
        
        Args:
            file_path: 로드할 파일 경로
        
        Returns:
            bool: 로드 성공 여부
        """
        try:
            import pickle
            import gzip
            import os
            
            if not os.path.exists(file_path):
                print(f"RAG pattern file {file_path} not found")
                return False
            
            with gzip.open(file_path, 'rb') as f:
                self.document_store = pickle.load(f)
            
            print(f"Successfully loaded {len(self.document_store)} patterns from {file_path}")
            
            # 패턴 통계 출력
            completed_patterns = [p for p in self.document_store if p.get('trade_result', {}).get('completed', False)]
            successful_patterns = [p for p in completed_patterns if p.get('trade_result', {}).get('success', False)]
            
            if completed_patterns:
                win_rate = len(successful_patterns) / len(completed_patterns) * 100
                print(f"Pattern stats: {len(completed_patterns)} completed trades, {win_rate:.1f}% win rate")
                
                # 가장 성공적인 패턴 정보
                if successful_patterns:
                    best_pattern = max(successful_patterns, key=lambda p: p.get('trade_result', {}).get('profit_pct', 0))
                    best_profit = best_pattern.get('trade_result', {}).get('profit_pct', 0)
                    print(f"Best pattern: {best_profit:.2f}% profit on {best_pattern.get('date', 'unknown date')}")
            
            return True
        except Exception as e:
            print(f"Error loading RAG patterns: {str(e)}")
            return False


    def _calculate_news_similarity(self, current_news, stored_news):
        """뉴스 유사도 계산"""
        if not current_news or not stored_news:
            return 0
        
        # 현재 뉴스 키워드 추출
        current_keywords = set()
        for news in current_news[:3]:
            title = news.get('title', '').lower()
            keywords = ['regulation', 'etf', 'institutional', 'adoption', 'hack', 'security', 
                    'fed', 'rate', 'inflation', 'mining', 'halving', 'upgrade']
            for keyword in keywords:
                if keyword in title:
                    current_keywords.add(keyword)
        
        # 저장된 뉴스 키워드 추출
        stored_keywords = set()
        for news in stored_news:
            title = news.get('title', '').lower()
            for keyword in keywords:
                if keyword in title:
                    stored_keywords.add(keyword)
        
        # 자카드 유사도 계산
        if not current_keywords and not stored_keywords:
            return 0
        
        intersection = len(current_keywords.intersection(stored_keywords))
        union = len(current_keywords.union(stored_keywords))
        
        return intersection / union if union > 0 else 0


    def find_similar_patterns(self, current_indicators, lookback_days=30, success_weight=False, time_decay=False, current_news=None): 
        """유사한 과거 패턴 검색 - 성공 패턴 가중치 기능 추가"""
        similar_contexts = []
        
        # document_store가 없거나 비어있는 경우 초기화
        if not hasattr(self, 'document_store') or not self.document_store:
            self.document_store = []
            return []
        
        # 현재 시점 확인 (시간 가중치 계산용)
        current_date = datetime.datetime.now()
        
        # 검색 로직 (기존 함수 내용 유지)
        for doc in self.document_store[-lookback_days*3:]:
            similarity_score = 0
            matching_points = 0
            
            # RSI 유사도 체크
            if 'RSI(14)' in doc.get('indicators', {}) and 'RSI(14)' in current_indicators:
                try:
                    doc_rsi = float(str(doc['indicators']['RSI(14)']).replace(',', ''))
                    current_rsi = float(str(current_indicators['RSI(14)']).replace(',', ''))
                    rsi_diff = abs(doc_rsi - current_rsi)
                    
                    if rsi_diff < 5:
                        similarity_score += 3  # 매우 유사
                        matching_points += 1
                    elif rsi_diff < 10:
                        similarity_score += 2  # 유사
                        matching_points += 1
                    elif rsi_diff < 15:
                        similarity_score += 1  # 약간 유사
                        matching_points += 1
                except:
                    pass
            
             # ↓ 뉴스 유사도 비교 추가
            if current_news and doc.get('news_data'):
                news_similarity_score = self._calculate_news_similarity(current_news, doc.get('news_data', []))
                if news_similarity_score > 0.3:  # 30% 이상 유사시
                    similarity_score += news_similarity_score * 3  # 뉴스 유사도 가중치
                    matching_points += 1
                    print(f"뉴스 유사도 발견: {news_similarity_score:.2f}")
            
            
            
            
            # MACD 유사도 체크
            if 'MACD' in doc.get('indicators', {}) and 'MACD' in current_indicators:
                doc_macd = doc['indicators']['MACD']
                current_macd = current_indicators['MACD']
                
                if doc_macd == current_macd:
                    similarity_score += 2
                    matching_points += 1
                elif ("Bullish" in doc_macd and "Bullish" in current_macd) or \
                    ("Bearish" in doc_macd and "Bearish" in current_macd):
                    similarity_score += 1
                    matching_points += 1
            
            # 볼린저 밴드 유사도 체크
            if 'Bollinger Bands' in doc.get('indicators', {}) and 'Bollinger Bands' in current_indicators:
                if doc['indicators']['Bollinger Bands'] == current_indicators['Bollinger Bands']:
                    similarity_score += 2
                    matching_points += 1
            
            # 이동평균선 유사도 체크
            if 'Moving Averages' in doc.get('indicators', {}) and 'Moving Averages' in current_indicators:
                if doc['indicators']['Moving Averages'] == current_indicators['Moving Averages']:
                    similarity_score += 2
                    matching_points += 1
                elif ("Price >" in doc['indicators']['Moving Averages'] and "Price >" in current_indicators['Moving Averages']) or \
                    ("Price <" in doc['indicators']['Moving Averages'] and "Price <" in current_indicators['Moving Averages']):
                    similarity_score += 1
                    matching_points += 1
            
            # 시장 추세 유사도 체크
            doc_trend = doc.get('market_trend', '')
            current_trend = self.detect_market_trend(current_indicators)
            
            if doc_trend and current_trend:
                if doc_trend == current_trend:
                    similarity_score += 3
                    matching_points += 1
                elif ("uptrend" in doc_trend and "uptrend" in current_trend) or \
                    ("downtrend" in doc_trend and "downtrend" in current_trend):
                    similarity_score += 2
                    matching_points += 1
            
            # 지지선 유사도 체크
            if 'support_analysis' in doc and current_indicators:
                doc_support = doc.get('support_analysis', {})
                current_price = None
                if hasattr(self, 'historical_data') and len(self.historical_data) > 0:
                    current_price = self.historical_data[-1].get('price', self.historical_data[-1].get('close'))
                
                if current_price:
                    current_support = self._check_near_support_level_enhanced("KRW-BTC", current_price)
                    
                    # 지지선 근처 여부 매칭
                    if doc_support.get('is_near_support') == current_support.get('is_near_support'):
                        similarity_score += 1.5
                        matching_points += 1
                    
                    # 지지선 강도 유사도
                    if doc_support.get('strength') and current_support.get('strength'):
                        strength_diff = abs(doc_support['strength'] - current_support['strength'])
                        if strength_diff < 0.1:
                            similarity_score += 2
                            matching_points += 1
                        elif strength_diff < 0.2:
                            similarity_score += 1
                            matching_points += 1
            
            # 추가: 거래 결과에 따른 가중치 조정
            if success_weight and 'trade_result' in doc:
                trade_result = doc['trade_result']
                if trade_result.get('completed', False):
                    # 성공한 거래인 경우 가중치 증가
                    if trade_result.get('success', False):
                        profit_pct = trade_result.get('profit_pct', 0)
                        # 높은 수익률일수록 더 큰 가중치
                        similarity_score *= 1.0 + min(1.0, profit_pct / 10.0)
                    # 실패한 거래인 경우 가중치 감소
                    else:
                        similarity_score *= 0.8
            
            # 추가: 시간 경과에 따른 가중치 조정
            if time_decay and 'timestamp' in doc:
                try:
                    doc_date = pd.to_datetime(doc['timestamp'])
                    days_old = (current_date - doc_date).days
                    if days_old > 0:
                        # 최대 50% 감소 (180일 이상 지난 경우)
                        time_decay_factor = max(0.5, 1.0 - (days_old / 360.0))
                        similarity_score *= time_decay_factor
                except:
                    pass
            
            # 유사도가 충분히 높은 패턴만 선택 (기존 로직)
            if matching_points >= 2 and similarity_score >= 4:
                # 거래 결과 정보 포함 (있는 경우)
                trade_info = {}
                if 'trade_result' in doc:
                    trade_info = {
                        'completed': doc['trade_result'].get('completed', False),
                        'success': doc['trade_result'].get('success', False),
                        'profit_pct': doc['trade_result'].get('profit_pct', 0),
                        'exit_reason': doc['trade_result'].get('exit_reason', 'Unknown')
                    }
                
                similar_contexts.append({
                    'date': doc.get('date', ''),
                    'similarity_score': similarity_score,
                    'content': doc.get('content', ''),
                    'indicators': doc.get('indicators', {}),
                    'support_analysis': doc.get('support_analysis', {}),
                    'market_trend': doc.get('market_trend', ''),
                    'trade_result': trade_info,  # 추가: 거래 결과 정보
                    'pattern_id': doc.get('pattern_id', '')  # 추가: 패턴 ID
                })
        
        # 유사도 점수로 정렬
        similar_contexts.sort(key=lambda x: x['similarity_score'], reverse=True)
        
        # 결과 로깅
        print(f"Found {len(similar_contexts)} similar patterns")
        for i, pattern in enumerate(similar_contexts[:3]):  # 상위 3개만 로깅
            profit_info = ""
            if 'trade_result' in pattern and pattern['trade_result'].get('completed', False):
                profit = pattern['trade_result'].get('profit_pct', 0)
                success = "Success" if pattern['trade_result'].get('success', False) else "Failure"
                profit_info = f", {success} with {profit:.2f}% profit"
            
            print(f"Pattern {i+1}: Date={pattern['date']}, Score={pattern['similarity_score']:.2f}{profit_info}")
        
        return similar_contexts[:10]  # 상위 10개 반환 (기존 5개에서 확장)

    def store_market_pattern(self, tech_indicators, price, decision, timestamp):
        """매수 시점의 패턴 저장 (최소 기능만 구현)"""
        if not hasattr(self, 'document_store'):
            self.document_store = []
        
        # 패턴 ID 생성
        pattern_id = f"{timestamp.strftime('%Y%m%d%H%M%S')}_{hash(str(tech_indicators))}"
        
        # 현재 시장 상태 저장
        pattern = {
            'pattern_id': pattern_id,
            'date': timestamp.strftime('%Y-%m-%d'),
            'timestamp': timestamp,
            'indicators': tech_indicators,
            'price': price,
            'ai_decision': decision,
            'market_trend': self.detect_market_trend(tech_indicators),
            'support_analysis': self._check_near_support_level_enhanced("KRW-BTC", price),
            'trade_result': {
                'completed': False,
                'entry_price': price,
                'exit_price': None,
                'profit_pct': None,
                'success': None
            }
        }
        
        self.document_store.append(pattern)
        print(f"Stored new pattern with ID: {pattern_id}")
        return pattern_id
    
    def update_pattern_with_result(self, pattern_id, exit_price, exit_date, exit_reason):
        """매도 시점에 패턴 결과 업데이트 (최소 기능만 구현)"""
        if not hasattr(self, 'document_store'):
            return False
        
        # 패턴 찾기
        for pattern in self.document_store:
            if pattern.get('pattern_id') == pattern_id:
                # 수익률 계산
                entry_price = pattern['trade_result']['entry_price']
                profit_pct = ((exit_price / entry_price) - 1) * 100
                
                # 결과 업데이트
                pattern['trade_result'].update({
                    'completed': True,
                    'exit_price': exit_price,
                    'exit_date': exit_date.strftime('%Y-%m-%d'),
                    'profit_pct': profit_pct,
                    'success': profit_pct > 0,
                    'exit_reason': exit_reason
                })
                
                print(f"Updated pattern {pattern_id} with result: {profit_pct:.2f}% profit, {exit_reason}")
                return True
        
        return False


    def _calculate_enhanced_support_levels(self, ticker):
        """개선된 지지선 계산 - 초기 데이터 부족 문제 해결"""
        try:
            # 데이터 없는 경우 빈 리스트 반환
            if not hasattr(self, 'historical_data') or not self.historical_data:
                print("Warning: No historical data available for support calculation")
                return []
            
            # 최소 데이터 요구사항 완화
            if len(self.historical_data) < 5:  # 30일 → 5일로 완화
                print(f"Warning: Only {len(self.historical_data)} days of data, using simple support calculation")
                # 간단한 지지선 계산
                prices = [item.get('price', item.get('close', 0)) for item in self.historical_data]
                if prices:
                    min_price = min(prices)
                    max_price = max(prices)
                    # 단순 지지선 반환
                    return [min_price, min_price * 1.02, max_price * 0.98]
                return []
            
            # 통합 지지선을 저장할 딕셔너리
            support_weights = {}
            
            try:
                # 1. 기본 지지선 계산 (최근 가격 기반)
                recent_data = self.historical_data[-min(30, len(self.historical_data)):]
                temp_data = []
                for item in recent_data:
                    temp_data.append({
                        'close': item.get('close', item.get('price', 0)),
                        'open': item.get('open', item.get('close', item.get('price', 0))),
                        'high': item.get('high', item.get('close', item.get('price', 0))),
                        'low': item.get('low', item.get('close', item.get('price', 0))),
                        'volume': item.get('volume', 0)
                    })
                
                if temp_data:
                    temp_df = pd.DataFrame(temp_data)
                    standard_supports = self._calculate_standard_supports(temp_df)
                    for level in standard_supports:
                        if level > 0:  # 유효한 가격만
                            support_weights[level] = support_weights.get(level, 0) + 1.0
            except Exception as e:
                print(f"Error in standard support calculation: {str(e)}")
            
            try:
                # 2. 단순 지지선 (최저가 기반)
                prices = [item.get('price', item.get('close', 0)) for item in self.historical_data]
                if prices:
                    min_price = min(prices)
                    recent_low = min(prices[-5:]) if len(prices) >= 5 else min_price
                    
                    # 최근 저가 근처의 지지선들
                    support_weights[recent_low] = support_weights.get(recent_low, 0) + 2.0
                    support_weights[recent_low * 0.98] = support_weights.get(recent_low * 0.98, 0) + 1.5
                    support_weights[recent_low * 0.95] = support_weights.get(recent_low * 0.95, 0) + 1.0
            except Exception as e:
                print(f"Error in simple support calculation: {str(e)}")
            
            try:
                # 3. 심리적 지지선 (라운드 넘버)
                if self.historical_data:
                    current_price = self.historical_data[-1].get('price', self.historical_data[-1].get('close', 0))
                    if current_price > 0:
                        # 1만원, 5만원, 10만원 단위
                        for divisor in [10000, 50000, 100000]:
                            rounded = (int(current_price / divisor) * divisor)
                            if rounded < current_price:
                                support_weights[rounded] = support_weights.get(rounded, 0) + 1.2
            except Exception as e:
                print(f"Error in psychological support calculation: {str(e)}")
            
            # 지지선이 없는 경우
            if not support_weights:
                print("Warning: No support levels calculated, using default")
                if self.historical_data:
                    try:
                        current_price = self.historical_data[-1].get('price', self.historical_data[-1].get('close', 0))
                        if current_price > 0:
                            # 기본 지지선 생성
                            return [current_price * 0.95, current_price * 0.92, current_price * 0.90]
                    except:
                        pass
                return []
            
            # 현재 가격 확인
            current_price = None
            try:
                if self.historical_data:
                    current_price = self.historical_data[-1].get('price', self.historical_data[-1].get('close'))
            except:
                pass
            
            # 지지선 목록 생성 (가중치 기준 정렬)
            weighted_supports = [(price, weight) for price, weight in support_weights.items()]
            weighted_supports.sort(key=lambda x: x[1], reverse=True)
            
            # 상위 지지선 선택 (최대 5개)
            top_supports = [price for price, _ in weighted_supports[:5]]
            
            # 현재 가격 이하만 유지
            if current_price and current_price > 0:
                valid_supports = [s for s in top_supports if s <= current_price]
            else:
                valid_supports = top_supports
            
            # 최소한 하나의 지지선은 반환
            if not valid_supports and self.historical_data:
                try:
                    last_price = self.historical_data[-1].get('price', self.historical_data[-1].get('close', 0))
                    if last_price > 0:
                        valid_supports = [last_price * 0.95]
                except:
                    pass
            
            #if valid_supports:
                #print(f"Calculated {len(valid_supports)} support levels")
            #else:
             #   print("Warning: No valid support levels found")
            
            return valid_supports
            
        except Exception as e:
            print(f"Error in enhanced support calculation: {e}")
            # 오류 시 기본 지지선 반환
            try:
                if hasattr(self, 'historical_data') and self.historical_data:
                    last_price = self.historical_data[-1].get('price', self.historical_data[-1].get('close', 0))
                    if last_price > 0:
                        return [last_price * 0.95, last_price * 0.90]
            except:
                pass
            return []




    def calculate_enhanced_position_size(self, price, confidence, market_regime, pattern_advice, 
                                    fear_greed_index=50, balance=None, ai_decision="HOLD"):
        """🚨 긴급 수정: 안전한 포지션 사이징 - 파산 방지 + 수수료 계산 수정"""
        
        if balance is None:
            balance = getattr(self, 'current_balance', getattr(self, 'initial_balance', 10000000))
        
        # 🚨 긴급 안전장치 1: 잔고 부족 체크
        if balance < 10000:  # 1만원 미만이면 거래 금지
            print(f"⚠️ 잔고 부족으로 거래 중단: ₩{balance:,.0f}")
            return 0, 0, 0, {
                'strategy_type': "잔고 부족",
                'psychology_reason': "거래 중단",
                'pattern_reason': "안전장치 작동"
            }
        
        if ai_decision == "BUY":
            print(f"🚀 AI BUY 신호 - 안전 투자 모드")
            
            # 🚨 긴급 수정: 매우 보수적인 투자 비율
            base_investment_ratio = 0.02  # 기본 2%로 축소
            
            # 🚨 안전장치 2: 최대 투자 비율 제한
            max_investment_ratio = 0.03  # 최대 3%로 제한 (기존 5% → 3%)
            
            # 신뢰도에 따른 소폭 조정만
            if confidence >= 0.8:
                confidence_multiplier = 1.2  # 기존 1.5 → 1.2
            elif confidence >= 0.6:
                confidence_multiplier = 1.1  # 기존 1.2 → 1.1
            else:
                confidence_multiplier = 0.9  # 기존 0.8 → 0.9
            
            # Fear & Greed Index 영향 최소화
            if fear_greed_index <= 25:
                psychology_multiplier = 1.1  # 기존 1.3 → 1.1
            elif fear_greed_index >= 75:
                psychology_multiplier = 0.9  # 기존 0.8 → 0.9
            else:
                psychology_multiplier = 1.0
            
            # 최종 투자 비율 계산
            final_investment_ratio = base_investment_ratio * confidence_multiplier * psychology_multiplier
            
            # 🚨 강력한 상한 제한
            final_investment_ratio = min(final_investment_ratio, max_investment_ratio)
            
            # 🚨 안전장치 3: 절대 금액 체크
            investment_amount = balance * final_investment_ratio
            max_absolute_amount = min(balance * 0.05, 50000)  # 최대 5% 또는 5만원 중 작은 값
            
            if investment_amount > max_absolute_amount:
                investment_amount = max_absolute_amount
                final_investment_ratio = investment_amount / balance
            
            # 최소 투자 금액 체크 (너무 작으면 거래 안함)
            if investment_amount < 1000:
                print(f"⚠️ 투자 금액 너무 작음: ₩{investment_amount:,.0f}")
                return 0, 0, 0, {
                    'strategy_type': "금액 부족",
                    'psychology_reason': "최소 금액 미달",
                    'pattern_reason': "거래 생략"
                }
            
            # 🚨 수정된 수수료 계산
            fee_rate = 0.0005
            fee = investment_amount * fee_rate
            net_investment = investment_amount - fee  # ✅ 올바른 계산
            coin_amount = net_investment / price
            
            # 🚨 총 비용 계산 (투자금액 + 수수료)
            total_cost = investment_amount + fee
            
            # 🚨 최종 안전 확인
            if total_cost >= balance:
                print(f"🚨 총 비용이 잔고 초과: 비용=₩{total_cost:,.0f}, 잔고=₩{balance:,.0f}")
                return 0, 0, 0, {
                    'strategy_type': "비용 초과",
                    'psychology_reason': "안전장치",
                    'pattern_reason': "거래 차단"
                }
            
            print(f"💰 수정된 포지션 사이징 결과:")
            print(f"  ├─ 현재 잔고: ₩{balance:,.0f}")
            print(f"  ├─ 투자 비율: {final_investment_ratio*100:.2f}%")
            print(f"  ├─ 투자 금액: ₩{investment_amount:,.0f}")
            print(f"  ├─ 매수 수수료: ₩{fee:,.0f}")
            print(f"  ├─ 실제 구매금액: ₩{net_investment:,.0f}")
            print(f"  ├─ 코인 수량: {coin_amount:.8f} BTC")
            print(f"  ├─ 총 비용: ₩{total_cost:,.0f}")
            print(f"  └─ 거래 후 잔고: ₩{balance - total_cost:,.0f}")
            
            # 🚨 중요: 수익 계산을 위한 정확한 값들 반환
            return coin_amount, total_cost, final_investment_ratio, {
                'profit_target_adjustment': 0.0,
                'stop_loss_adjustment': 0.0,
                'strategy_type': f"안전 투자 {final_investment_ratio*100:.1f}%",
                'psychology_reason': f"FGI {fear_greed_index}",
                'pattern_reason': f"신뢰도 {confidence:.2f}",
                'net_investment': net_investment,  # 실제 구매에 사용된 금액
                'total_cost': total_cost,          # 총 비용 (투자금액 + 수수료)
                'fee': fee                         # 수수료
            }
        
        else:
            # AI가 BUY 신호를 보내지 않은 경우
            return 0, 0, 0.0, {
                'strategy_type': "AI 비매수",
                'psychology_reason': "대기",
                'pattern_reason': "신호 없음"
            }

    def calculate_trading_statistics(self):
        """과거 거래 통계 계산"""
        if not hasattr(self, 'document_store') or not self.document_store:
            return 0.5, 3.0, -2.0  # 기본값
        
        completed_trades = [p for p in self.document_store 
                        if p.get('trade_result', {}).get('completed', False)]
        
        if len(completed_trades) < 3:
            return 0.5, 3.0, -2.0  # 최소 3거래 미만시 기본값
        
        successful_trades = [t for t in completed_trades 
                            if t.get('trade_result', {}).get('success', False)]
        failed_trades = [t for t in completed_trades 
                        if not t.get('trade_result', {}).get('success', False)]
        
        win_rate = len(successful_trades) / len(completed_trades)
        
        avg_profit = (sum(t.get('trade_result', {}).get('profit_pct', 0) 
                        for t in successful_trades) / len(successful_trades)) if successful_trades else 3.0
        
        avg_loss = (sum(t.get('trade_result', {}).get('profit_pct', 0) 
                    for t in failed_trades) / len(failed_trades)) if failed_trades else -2.0
        
        return win_rate, avg_profit, avg_loss
    
    def confirmation_candle_system(self, ai_decision, confidence, current_candle_data, 
                                next_candle_data=None, historical_context=None):
        """다음 캔들로 AI 신호 검증"""
        
        if ai_decision != "BUY" or next_candle_data is None:
            return ai_decision, confidence, "컨펌 불필요"
        
        # 현재 캔들 정보
        current_price = current_candle_data.get('close', 0)
        current_volume = current_candle_data.get('volume', 0)
        current_open = current_candle_data.get('open', current_price)
        
        # 다음 캔들 정보
        next_price = next_candle_data.get('close', 0)
        next_volume = next_candle_data.get('volume', 0)
        next_open = next_candle_data.get('open', next_price)
        next_high = next_candle_data.get('high', next_price)
        next_low = next_candle_data.get('low', next_price)
        
        # 컨펌 조건들 체크
        confirmations = []
        confirmation_score = 0
        
        # 1. 캔들 방향 확인 (양봉/음봉)
        if next_price > next_open:  # 양봉
            confirmations.append("양봉 형성")
            confirmation_score += 2
        elif next_price == next_open:  # 도지
            confirmations.append("도지 형성")
            confirmation_score += 0.5
        else:  # 음봉
            confirmations.append("음봉 형성 (부정적)")
            confirmation_score -= 1
        
        # 2. 가격 상승 확인
        price_change_pct = ((next_price / current_price) - 1) * 100
        if price_change_pct > 1.0:  # 1% 이상 상승
            confirmations.append(f"강한 상승 {price_change_pct:.1f}%")
            confirmation_score += 3
        elif price_change_pct > 0.3:  # 0.3% 이상 상승
            confirmations.append(f"상승 {price_change_pct:.1f}%")
            confirmation_score += 1
        elif price_change_pct < -0.5:  # 0.5% 이상 하락
            confirmations.append(f"하락 {price_change_pct:.1f}% (부정적)")
            confirmation_score -= 2
        
        # 3. 거래량 증가 확인
        if current_volume > 0:
            volume_change = next_volume / current_volume
            if volume_change > 1.5:  # 50% 이상 증가
                confirmations.append(f"거래량 급증 {volume_change:.1f}x")
                confirmation_score += 2
            elif volume_change > 1.2:  # 20% 이상 증가
                confirmations.append(f"거래량 증가 {volume_change:.1f}x")
                confirmation_score += 1
            elif volume_change < 0.8:  # 20% 이상 감소
                confirmations.append(f"거래량 감소 {volume_change:.1f}x (부정적)")
                confirmation_score -= 1
        
        # 4. 캔들 실체 크기 확인 (상승 모멘텀)
        candle_body_pct = abs(next_price - next_open) / next_open * 100
        if candle_body_pct > 2.0:  # 2% 이상 실체
            confirmations.append(f"큰 캔들 실체 {candle_body_pct:.1f}%")
            confirmation_score += 1
        
        # 5. 상하단 꼬리 분석 (매수 압력)
        if next_high > 0 and next_low > 0:
            upper_shadow = (next_high - max(next_open, next_price)) / next_open * 100
            lower_shadow = (min(next_open, next_price) - next_low) / next_open * 100
            
            if lower_shadow > upper_shadow * 1.5:  # 아래꼬리가 긴 경우
                confirmations.append("아래꼬리 긴 캔들 (매수 압력)")
                confirmation_score += 1
        
        # 6. 기술적 지표 컨펌 (있는 경우)
        if historical_context:
            recent_rsi_trend = historical_context.get('rsi_trend', 'neutral')
            if recent_rsi_trend == 'recovering' and price_change_pct > 0:
                confirmations.append("RSI 회복 + 가격 상승")
                confirmation_score += 2
        
        # 컨펌 여부 결정
        min_score_for_confirm = 3.0  # 최소 3점 이상
        
        if confirmation_score >= min_score_for_confirm:
            adjusted_confidence = min(0.95, confidence + 0.1)  # 신뢰도 10% 증가
            status = "CONFIRMED_BUY"
            reason = f"컨펌 성공 ({confirmation_score:.1f}점): {', '.join(confirmations[:3])}"
            
        elif confirmation_score >= 1.0:
            adjusted_confidence = confidence
            status = "WEAK_CONFIRMED_BUY"
            reason = f"약한 컨펌 ({confirmation_score:.1f}점): {', '.join(confirmations[:2])}"
            
        else:
            adjusted_confidence = max(0.2, confidence - 0.15)  # 신뢰도 15% 감소
            status = "UNCONFIRMED_HOLD"
            reason = f"컨펌 실패 ({confirmation_score:.1f}점): {', '.join(confirmations[:2])}"
        
        print(f"🔍 컨펌 캔들 분석: {status}")
        print(f"  └─ {reason}")
        
        return status, adjusted_confidence, reason


    def _analyze_price_clusters(self, ticker):
        """
        가격 밀집 영역(Price Clusters) 분석을 통한 지지선 식별
        백테스터용으로 수정: historical_data 활용
        
        Args:
            ticker (str): 티커 (예: KRW-BTC)
            
        Returns:
            list: 가격 클러스터 기반 지지선 목록
        """
        try:
            # 백테스터에서 historical_data 활용
            if not hasattr(self, 'historical_data') or len(self.historical_data) < 30:
                return []
                
            # 최근 데이터만 사용 (60일 상당)
            recent_data = self.historical_data[-60:] if len(self.historical_data) > 60 else self.historical_data
            
            # 저가 데이터 추출
            lows = []
            for data in recent_data:
                if 'low' in data:
                    lows.append(data['low'])
                elif 'price' in data:  # 백테스터에서는 단일 가격만 있을 수 있음
                    lows.append(data['price'])
                elif 'close' in data:
                    lows.append(data['close'])
            
            if len(lows) < 30:
                return []
            
            # 가격 범위 설정
            price_min = min(lows) * 0.95
            price_max = max(lows) * 1.05
            
            # 가격 구간 설정 (100개 구간으로 나누기)
            num_bins = 100
            
            # numpy를 사용하여 히스토그램 생성
            import numpy as np
            hist, bin_edges = np.histogram(lows, bins=num_bins, range=(price_min, price_max))
            
            # 가격 빈도 평균 및 표준편차
            mean_freq = np.mean(hist)
            std_freq = np.std(hist)
            
            # 평균보다 1.5 표준편차 이상 높은 빈도를 가진 가격대를 클러스터로 식별
            clusters = []
            for i in range(len(hist)):
                if hist[i] > mean_freq + 1.5 * std_freq:
                    # 해당 구간의 중간 가격을 클러스터로 추가
                    cluster_price = (bin_edges[i] + bin_edges[i+1]) / 2
                    clusters.append(cluster_price)
            
            # 현재 가격 확인
            current_price = None
            if len(recent_data) > 0:
                current_data = recent_data[-1]
                if 'price' in current_data:
                    current_price = current_data['price']
                elif 'close' in current_data:
                    current_price = current_data['close']
            
            # 현재 가격보다 크게 높지 않은 클러스터만 선택 (지지선은 현재 가격보다 낮아야 함)
            valid_clusters = []
            if current_price:
                for cluster in clusters:
                    # 현재 가격의 105% 이내인 경우만 유효한 지지선으로 간주
                    if cluster <= current_price * 1.05:
                        valid_clusters.append(cluster)
            else:
                valid_clusters = clusters
            
            if hasattr(self, 'debug_mode') and self.debug_mode:
                print(f"{ticker} 가격 클러스터 분석 결과: {len(valid_clusters)}개 식별")
            
            return valid_clusters
            
        except Exception as e:
            print(f"가격 클러스터 분석 중 오류: {e}")
            return []

    def _check_near_support_level_enhanced(self, ticker, current_price):
        """개선된 지지선 근처 여부 확인 - 조건 완화"""
        try:
            # 가격이 유효하지 않으면 기본값 반환
            if not current_price or current_price <= 0:
                return {
                    'is_near_support': False,
                    'closest_support': None,
                    'distance_percent': None,
                    'strength': 0.0
                }
            
            # 지지선 계산
            support_levels = self._calculate_enhanced_support_levels(ticker)
            
            if not support_levels:
                # 지지선이 없을 때 기본 지지선 생성
                basic_supports = [current_price * 0.98, current_price * 0.95, current_price * 0.90]
                return {
                    'is_near_support': current_price <= basic_supports[0],  # 2% 하락 시 지지선
                    'closest_support': basic_supports[0],
                    'distance_percent': ((current_price / basic_supports[0]) - 1) * 100,
                    'strength': 0.3  # 기본 강도
                }
            
            # 가장 가까운 지지선 찾기
            closest_support = None
            min_distance = float('inf')
            
            for support in support_levels:
                if support > 0:  # 유효한 지지선만
                    distance = abs(current_price - support) / current_price * 100
                    if distance < min_distance and support <= current_price:  # 현재 가격 이하만
                        min_distance = distance
                        closest_support = support
            
            # 가장 가까운 지지선이 없으면 첫 번째 사용
            if closest_support is None and support_levels:
                closest_support = min(support_levels)
                min_distance = abs(current_price - closest_support) / current_price * 100
            
            # 거리별 강도 계산 (조건 완화)
            distance_percent = min_distance
            
            if distance_percent <= 1.0:  # 1% 이내: 매우 강함
                strength = 1.0
            elif distance_percent <= 2.0:  # 2% 이내: 강함
                strength = 0.8
            elif distance_percent <= 3.0:  # 3% 이내: 중간
                strength = 0.6
            elif distance_percent <= 5.0:  # 5% 이내: 약함
                strength = 0.4
            elif distance_percent <= 8.0:  # 8% 이내: 매우 약함 (기존 5% → 8%로 완화)
                strength = 0.2
            else:
                strength = 0.0
            
            # 근처 지지선 여부 (조건 완화: 3% → 5%)
            is_near = distance_percent <= 5.0
            
            # 다중 지지선 여부 확인
            nearby_supports_count = 0
            if closest_support:
                for support in support_levels:
                    if support != closest_support and support > 0:
                        support_distance = abs(support - closest_support) / closest_support * 100
                        if support_distance <= 3.0:
                            nearby_supports_count += 1
            
            # 다중 지지선 보너스
            if nearby_supports_count >= 1:
                strength = min(1.0, strength + 0.1)  # 강도 10% 증가
            
            # 디버그 로그
            #if is_near:
            #    print(f"Support analysis - Near: {is_near}, Price: ₩{current_price:,.0f}, Support: ₩{closest_support:,.0f}, Distance: {distance_percent:.2f}%, Strength: {strength:.2f}")
            
            return {
                'is_near_support': is_near,
                'closest_support': closest_support,
                'distance_percent': distance_percent,
                'strength': strength,
                'nearby_supports_count': nearby_supports_count
            }
                        
        except Exception as e:
            print(f"Error in support check: {e}")
            return {
                'is_near_support': False,
                'closest_support': None, 
                'distance_percent': None,
                'strength': 0.0
            }
        


    def _calculate_standard_supports(self, df):
        """기본 지지선 계산 (백테스터용)"""
        if df is None or df.empty:
            return []
        
        try:
            # 로컬 미니멈 찾기
            lows = df['close'] if 'close' in df.columns else df['price']
            supports = []
            
            for i in range(2, len(lows) - 2):
                if (lows.iloc[i] < lows.iloc[i-1] and lows.iloc[i] < lows.iloc[i-2] and
                    lows.iloc[i] < lows.iloc[i+1] and lows.iloc[i] < lows.iloc[i+2]):
                    supports.append(lows.iloc[i])
            
            return supports[-5:]  # 최근 5개만 반환
        except:
            return []

    def _calculate_fibonacci_levels(self, ticker):
        """피보나치 되돌림 레벨 계산"""
        try:
            if not hasattr(self, 'historical_data') or len(self.historical_data) < 20:
                return []
            
            # 최근 20일 데이터에서 고점과 저점 찾기
            recent_data = self.historical_data[-20:]
            
            high = max(data.get('price', data.get('close', 0)) for data in recent_data)
            low = min(data.get('price', data.get('close', 0)) for data in recent_data)
            
            if high <= low:
                return []
            
            # 피보나치 레벨 계산
            fib_levels = []
            ratios = [0.236, 0.382, 0.5, 0.618, 0.786]
            
            for ratio in ratios:
                level = high - (high - low) * ratio
                fib_levels.append(level)
            
            return fib_levels
        except:
            return []

    def _calculate_volume_weighted_supports(self, ticker):
        """거래량 가중치 지지선 계산"""
        try:
            if not hasattr(self, 'historical_data') or len(self.historical_data) < 20:
                return []
            
            # 거래량이 높은 가격대 찾기
            recent_data = self.historical_data[-20:]
            volume_supports = []
            
            for data in recent_data:
                if 'volume' in data and data['volume'] > 0:
                    # 거래량이 평균의 1.5배 이상인 가격을 지지선으로 간주
                    avg_volume = sum(d.get('volume', 0) for d in recent_data) / len(recent_data)
                    if data['volume'] > avg_volume * 1.5:
                        price = data.get('price', data.get('close', 0))
                        if price > 0:
                            volume_supports.append(price)
            
            return volume_supports[-3:]  # 최근 3개만 반환
        except:
            return []

    def _calculate_strong_supports(self, ticker):
        """강한 지지선 계산 (여러 번 테스트된 레벨)"""
        try:
            if not hasattr(self, 'historical_data') or len(self.historical_data) < 30:
                return []
            
            # 같은 가격대를 여러 번 건드린 레벨 찾기
            recent_data = self.historical_data[-30:]
            price_counts = {}
            
            for data in recent_data:
                price = data.get('price', data.get('close', 0))
                if price > 0:
                    # 가격을 500 단위로 반올림하여 그룹화
                    rounded_price = round(price / 500) * 500
                    price_counts[rounded_price] = price_counts.get(rounded_price, 0) + 1
            
            # 3회 이상 터치된 가격대를 강한 지지선으로 간주
            strong_supports = []
            for price, count in price_counts.items():
                if count >= 3:
                    strong_supports.append(price)
            
            return strong_supports
        except:
            return []

    def _calculate_technical_indicator_supports(self, ticker):
        """기술적 지표 기반 지지선 계산"""
        try:
            if not hasattr(self, 'historical_data') or len(self.historical_data) < 20:
                return []
            
            # DataFrame 생성
            data_for_analysis = []
            for item in self.historical_data[-30:]:
                data_for_analysis.append({
                    'close': item.get('price', item.get('close', 0)),
                    'volume': item.get('volume', 0)
                })
            
            df = pd.DataFrame(data_for_analysis)
            supports = []
            
            # 볼린저 밴드 하단 계산
            if len(df) >= 20:
                ma20 = df['close'].rolling(window=20).mean()
                std20 = df['close'].rolling(window=20).std()
                lower_band = ma20 - (std20 * 2)
                bb_support = lower_band.iloc[-1]
                supports.append(bb_support)
            
            return supports
        except:
            return []

    def _calculate_ma_supports(self, ticker):
        """이동평균선 기반 지지선 계산"""
        try:
            if not hasattr(self, 'historical_data') or len(self.historical_data) < 50:
                return []
            
            # DataFrame 생성
            data_for_analysis = []
            for item in self.historical_data[-50:]:
                data_for_analysis.append({
                    'close': item.get('price', item.get('close', 0))
                })
            
            df = pd.DataFrame(data_for_analysis)
            ma_supports = []
            
            # 주요 이동평균선들
            ma_periods = [(20, 1.2), (50, 1.5)]
            
            for period, weight in ma_periods:
                if len(df) >= period:
                    ma = df['close'].rolling(window=period).mean().iloc[-1]
                    ma_supports.append((ma, weight))
            
            return ma_supports
        except:
            return []








    def detect_market_trend(self, tech_indicators):
        """개선된 시장 트렌드 감지 함수 - 더 명확한 방향성 제시"""
        try:
            # 기술적 지표에서 트렌드 관련 정보 추출
            rsi_value = 50  # 기본값
            ma_trend = "neutral"  # 기본값
            volume_trend = "stable"  # 기본값
            price_trend = "neutral"  # 기본값
            
            # RSI 값 추출
            for key, value in tech_indicators.items():
                if 'rsi' in key.lower():
                    try:
                        if isinstance(value, (int, float)):
                            rsi_value = float(value)
                        elif isinstance(value, str):
                            rsi_value = float(value.replace(',', ''))
                    except:
                        pass
            
            # 이동평균선 정보 추출
            ma_values = {}
            for key, value in tech_indicators.items():
                if 'ma' in key.lower() or 'moving' in key.lower() or 'average' in key.lower():
                    period = 0
                    try:
                        # 키에서 숫자 추출 (예: MA50, SMA200, EMA20 등)
                        for part in key.split():
                            if any(char.isdigit() for char in part):
                                period_str = ''.join(filter(str.isdigit, part))
                                period = int(period_str)
                                break
                        
                        # 값 변환
                        if isinstance(value, (int, float)):
                            ma_values[period] = float(value)
                        elif isinstance(value, str) and value.replace('.', '', 1).replace(',', '').isdigit():
                            ma_values[period] = float(value.replace(',', ''))
                    except:
                        pass
            
            # 이동평균선 기반 트렌드 계산
            if len(ma_values) >= 2:
                # 단기(50일 이하) vs 장기(50일 초과) 이동평균선 비교
                short_mas = {k: v for k, v in ma_values.items() if k <= 50}
                long_mas = {k: v for k, v in ma_values.items() if k > 50}
                
                if short_mas and long_mas:
                    short_ma = sum(short_mas.values()) / len(short_mas)
                    long_ma = sum(long_mas.values()) / len(long_mas)
                    
                    if short_ma > long_ma * 1.02:  # 2% 이상 높을 때
                        ma_trend = "strong uptrend"
                    elif short_ma > long_ma:
                        ma_trend = "uptrend"
                    elif short_ma < long_ma * 0.98:  # 2% 이상 낮을 때
                        ma_trend = "strong downtrend"
                    elif short_ma < long_ma:
                        ma_trend = "downtrend"
                    else:
                        ma_trend = "consolidation"
            
            # 거래량 트렌드 추출
            for key, value in tech_indicators.items():
                if 'volume' in key.lower() or 'vol' in key.lower():
                    if isinstance(value, str):
                        if 'increasing' in value.lower() or 'up' in value.lower():
                            volume_trend = "increasing"
                        elif 'decreasing' in value.lower() or 'down' in value.lower():
                            volume_trend = "decreasing"
                        elif 'high' in value.lower():
                            volume_trend = "high"
                        elif 'low' in value.lower():
                            volume_trend = "low"
                    break
            
            # 가격 트렌드 정보 추출 (있는 경우)
            for key, value in tech_indicators.items():
                if 'trend' in key.lower() or 'direction' in key.lower():
                    if isinstance(value, str):
                        if 'up' in value.lower() or 'bull' in value.lower() or 'positive' in value.lower():
                            price_trend = "uptrend"
                        elif 'down' in value.lower() or 'bear' in value.lower() or 'negative' in value.lower():
                            price_trend = "downtrend"
                        elif 'sideways' in value.lower() or 'consolidation' in value.lower() or 'neutral' in value.lower():
                            price_trend = "sideways"
                    break
            
            # 추가 정보가 있는 경우 최근 백테스트 결과에서 트렌드 추출
            recent_price_changes = []
            if hasattr(self, 'backtest_results') and len(self.backtest_results) > 3:
                for i in range(1, min(6, len(self.backtest_results))):
                    if 'price' in self.backtest_results[i] and 'price' in self.backtest_results[i-1]:
                        try:
                            daily_change = ((self.backtest_results[i]['price'] / self.backtest_results[i-1]['price']) - 1) * 100
                            recent_price_changes.append(daily_change)
                        except:
                            pass
            
            # 최근 가격 변화로 트렌드 판단
            if recent_price_changes:
                avg_change = sum(recent_price_changes) / len(recent_price_changes)
                up_days = sum(1 for change in recent_price_changes if change > 0)
                down_days = sum(1 for change in recent_price_changes if change < 0)
                
                if avg_change > 1.5:
                    price_trend = "strong uptrend"
                elif avg_change > 0.3 and up_days > down_days:
                    price_trend = "uptrend"
                elif avg_change < -1.5:
                    price_trend = "strong downtrend"
                elif avg_change < -0.3 and down_days > up_days:
                    price_trend = "downtrend"
                elif abs(avg_change) <= 0.3:
                    price_trend = "sideways"
            
            # 최종 트렌드 판단
            if price_trend != "neutral":
                # 가격 트렌드 정보가 있으면 이를 우선시
                primary_trend = price_trend
            elif ma_trend != "neutral":
                # 이동평균선 트렌드 정보 사용
                primary_trend = ma_trend
            else:
                # RSI 기반 판단
                if rsi_value > 70:
                    primary_trend = "potentially overbought"
                elif rsi_value > 60:
                    primary_trend = "bullish"
                elif rsi_value < 30:
                    primary_trend = "potentially oversold"
                elif rsi_value < 40:
                    primary_trend = "bearish"
                else:
                    primary_trend = "neutral"
            
            # 볼륨 정보 결합
            if volume_trend == "increasing" and "uptrend" in primary_trend:
                trend = f"{primary_trend} with increasing volume (strong bullish signal)"
            elif volume_trend == "decreasing" and "downtrend" in primary_trend:
                trend = f"{primary_trend} with decreasing volume (potential reversal)"
            elif volume_trend == "increasing" and "downtrend" in primary_trend:
                trend = f"{primary_trend} with increasing volume (strong bearish signal)"
            elif volume_trend == "decreasing" and "uptrend" in primary_trend:
                trend = f"{primary_trend} with decreasing volume (weakening momentum)"
            elif volume_trend == "high":
                trend = f"{primary_trend} with high volume (strong conviction)"
            elif volume_trend == "low":
                trend = f"{primary_trend} with low volume (weak conviction)"
            else:
                trend = primary_trend
            
            # RSI 상태 추가
            if rsi_value > 70 and "overbought" not in trend:
                trend += f" with overbought RSI ({rsi_value:.1f})"
            elif rsi_value < 30 and "oversold" not in trend:
                trend += f" with oversold RSI ({rsi_value:.1f})"
            
            return trend
        
        except Exception as e:
            print(f"Error detecting market trend: {str(e)}")
            return "Unknown market trend (insufficient data)"


    def __del__(self):
        """
        객체 소멸 시 셀레니움 드라이버 종료
        """
        if self.selenium_driver is not None:
            try:
                self.selenium_driver.quit()
                print("Selenium driver closed")
            except:
                pass

    def _filter_news_for_timestamp(self, news_list, timestamp):
        """
        특정 타임스탬프 시점의 뉴스만 필터링
        
        Args:
            news_list: 뉴스 리스트
            timestamp: 기준 타임스탬프
            
        Returns:
            list: 필터링된 뉴스 리스트
        """
        relevant_news = []
        timestamp_str = timestamp.strftime('%Y-%m-%d %H:%M:%S')
        
        # 타임스탬프를 datetime 객체로 변환
        if isinstance(timestamp, str):
            timestamp = pd.to_datetime(timestamp)
        
        # 타임존 처리 - naive 객체로 통일
        if hasattr(timestamp, 'tz') and timestamp.tz is not None:
            timestamp = timestamp.tz_localize(None)
        
        # 뉴스 필터링 - 특정 캔들 시점에 관련된 뉴스만 선택
        # 1. 캔들 시점 이전 6시간 내에 발행된 뉴스
        # 2. 아직 처리되지 않은 이전 날짜의 중요 뉴스
        for news in news_list:
            try:
                # 뉴스 발행 시간을 datetime으로 변환
                news_time = pd.to_datetime(news.get('publishedAt', ''))
                
                # 타임존 처리
                if hasattr(news_time, 'tz') and news_time.tz is not None:
                    news_time = news_time.tz_localize(None)
                
                # 현재 캔들 시점 이전 6시간 이내의 뉴스만 필터링
                if news_time <= timestamp and news_time >= (timestamp - datetime.timedelta(hours=6)):
                    relevant_news.append(news)
                    
                # 또는 감성 점수가 높은 중요 뉴스는 24시간까지 허용
                elif (
                    news_time <= timestamp and 
                    news_time >= (timestamp - datetime.timedelta(hours=24)) and
                    abs(news.get('sentiment_score', 0)) > 0.6  # 감성 점수가 있는 경우만
                ):
                    relevant_news.append(news)
            except Exception as e:
                print(f"뉴스 필터링 중 오류: {str(e)}")
        
        print(f"타임스탬프 {timestamp_str}에 대해 {len(relevant_news)}개 관련 뉴스 필터링됨")
        return relevant_news



    def _update_news_correlation(self, news_list, price_data, current_timestamp):
        """뉴스-가격 상관관계 실시간 업데이트 - 디버깅 개선"""
        if not hasattr(self, 'news_correlations'):
            self.news_correlations = {}
            print("news_correlations 딕셔너리 초기화")
        
        updated_correlations = 0
        
        print(f"상관관계 분석 시작: {len(news_list)}개 뉴스, {len(price_data)}개 가격 데이터")
        
        for i, news in enumerate(news_list):
            try:
                # 뉴스 식별자 생성
                news_id = news.get('url', str(hash(news.get('title', ''))))
                
                # 이미 분석된 뉴스는 건너뜀
                if news_id in self.news_correlations:
                    print(f"이미 분석된 뉴스 건너뜀: {news['title'][:30]}...")
                    continue
                
                # 뉴스 발생 시간
                news_time = pd.to_datetime(news.get('publishedAt', ''))
                
                # 타임존 처리
                if hasattr(news_time, 'tz') and news_time.tz is not None:
                    news_time = news_time.tz_localize(None)
                
                # 뉴스 감성 분석
                print(f"뉴스 {i+1}/{len(news_list)} 감성 분석 중...")
                sentiment = self.analyze_news_sentiment([news])
                print(f"감성 점수: {sentiment.get('sentiment_score', 0)}")
                
                # 가격 영향 계산 (1시간, 6시간, 24시간 이후)
                price_impacts = self._calculate_price_impacts_after_news(news_time, price_data)
                impact_str = ", ".join([f"{k}: {v:.2f}%" for k, v in price_impacts.items()])
                print(f"가격 영향: {impact_str if impact_str else '데이터 없음'}")
                
                # 뉴스 주제 식별 
                key_topics = sentiment.get('key_topics', [])
                
                # 상관관계 정보 저장
                self.news_correlations[news_id] = {
                    'news_id': news_id,
                    'timestamp': news_time.isoformat(),
                    'title': news.get('title', ''),
                    'sentiment_score': sentiment.get('sentiment_score', 0),
                    'themes': key_topics,
                    'price_impact_1h': price_impacts.get('1h', 0),
                    'price_impact_6h': price_impacts.get('6h', 0), 
                    'price_impact_24h': price_impacts.get('24h', 0),
                    'volume_impact': price_impacts.get('volume', 0),
                    'last_updated': current_timestamp.isoformat()
                }
                
                updated_correlations += 1
                print(f"뉴스 상관관계 데이터 추가: {news['title'][:30]}...")
                
                # 중간 저장 (10개마다)
                if updated_correlations % 10 == 0:
                    self.save_news_correlations()
                    print(f"중간 저장 완료: {len(self.news_correlations)}개 상관관계 데이터")
                
            except Exception as e:
                print(f"뉴스 상관관계 업데이트 중 오류: {str(e)}")
        
        if updated_correlations > 0:
            print(f"{updated_correlations}개 뉴스 상관관계 정보 업데이트 완료")
            # 최종 저장
            self.save_news_correlations()
        
        return self.news_correlations



    def _filter_news_for_timestamp(self, news_list, timestamp):
        """특정 타임스탬프 시점의 뉴스 필터링 - 완화된 조건"""
        relevant_news = []
        timestamp_str = timestamp.strftime('%Y-%m-%d %H:%M:%S')
        
        # 타임스탬프를 datetime 객체로 변환 및 타임존 처리
        if isinstance(timestamp, str):
            timestamp = pd.to_datetime(timestamp)
        if hasattr(timestamp, 'tz') and timestamp.tz is not None:
            timestamp = timestamp.tz_localize(None)
        
        # 필터링 시간 범위 확장: 이전 12시간 + 이후 1시간
        window_start = timestamp - datetime.timedelta(hours=12)
        window_end = timestamp + datetime.timedelta(hours=1)
        
        print(f"뉴스 필터링 시간 범위: {window_start} ~ {window_end}")
        
        # 뉴스 필터링 - 시간 범위 내의 모든 뉴스 포함
        for news in news_list:
            try:
                # 뉴스 발행 시간을 datetime으로 변환
                news_time = pd.to_datetime(news.get('publishedAt', ''))
                
                # 타임존 처리
                if hasattr(news_time, 'tz') and news_time.tz is not None:
                    news_time = news_time.tz_localize(None)
                
                # 시간 범위 내에 있는지 확인
                if window_start <= news_time <= window_end:
                    # 뉴스 타이틀이 있는지 확인
                    if 'title' in news and news['title']:
                        relevant_news.append(news)
                        print(f"관련 뉴스 추가: {news['title'][:50]}... ({news_time})")
                
            except Exception as e:
                print(f"뉴스 필터링 중 오류: {str(e)}")
        
        # 관련 뉴스가 부족하면 최신 5개 뉴스 추가
        if len(relevant_news) < 5:
            print(f"관련 뉴스가 부족합니다. 최신 뉴스 추가...")
            
            # 모든 뉴스를 날짜순으로 정렬
            sorted_news = sorted(
                [n for n in news_list if 'publishedAt' in n], 
                key=lambda x: pd.to_datetime(x['publishedAt']), 
                reverse=True
            )
            
            # 이미 추가된 뉴스 제외하고 최신 5개 추가
            added_titles = set(n['title'] for n in relevant_news)
            for news in sorted_news:
                if news['title'] not in added_titles and len(relevant_news) < 5:
                    relevant_news.append(news)
                    print(f"최신 뉴스 추가: {news['title'][:50]}...")
                    added_titles.add(news['title'])
        
        print(f"타임스탬프 {timestamp_str}에 대해 {len(relevant_news)}개 관련 뉴스 필터링됨")
        return relevant_news


    def fetch_news_from_dataset(self, coin, date_from, date_to):
        """
        다중 데이터셋에서 암호화폐 뉴스를 가져옵니다
        """
        # 캐시 파일 경로
        cache_path = self.get_news_cache_path(coin, date_from, date_to)
        print(f"Cache path: {cache_path}")
        
        # 캐시 확인
        if os.path.exists(cache_path):
            print(f"Cache file exists. Size: {os.path.getsize(cache_path)} bytes")
            with open(cache_path, 'r', encoding='utf-8') as f:
                content = f.read()
                print(f"Cache content preview: {content[:100]}")
                # 전체 내용을 다시 읽어서 파싱
                f.seek(0)
                cached_data = json.load(f)
                print(f"Cached data count: {len(cached_data)}")
                
                # 캐시된 데이터가 충분한 경우에만 반환
                min_required_news = 20
                if len(cached_data) >= min_required_news:
                    return cached_data
                else:
                    print(f"Cache has insufficient data ({len(cached_data)} < {min_required_news}), regenerating...")
        
        print(f"Available handlers: {len(self.news_handlers)}")
        
        # 모든 데이터셋에서 뉴스 수집
        all_news = []
        for handler in self.news_handlers:
            news_list = handler.get_news_for_date_range(date_from, date_to)
            all_news.extend(news_list)
        
        print(f"All news collected: {len(all_news)}")
        
        # 중복 제거 및 정렬
        seen_urls = set()
        unique_news = []
        for news in all_news:
            # URL이 없으면 제목과 내용으로 중복 체크
            news_id = news.get('url', news.get('title', '') + news.get('description', ''))
            if news_id not in seen_urls:
                seen_urls.add(news_id)
                unique_news.append(news)
        
        print(f"Unique news: {len(unique_news)}")
        
        # 날짜순으로 정렬
        unique_news.sort(key=lambda x: x.get("publishedAt", ""))
        
        # 최소 필요 뉴스 수 설정
        min_required_news = 20
        print(f"Minimum required news: {min_required_news}")
        
        # 뉴스가 없거나 충분하지 않은 경우 임시 뉴스 생성
        if len(unique_news) < min_required_news:
            print(f"WARNING: Insufficient news found: only {len(unique_news)} articles. Creating placeholder news.")
            
            # 임시 뉴스 생성
            placeholder_news = []
            for i in range(min_required_news - len(unique_news)):
                placeholder_news.append({
                    "title": f"Placeholder Bitcoin News #{i+1}",
                    "url": f"https://example.com/news/{i+1}",
                    "description": f"Placeholder description for Bitcoin news #{i+1}",
                    "source": "Placeholder",
                    "publishedAt": date_from.strftime("%Y-%m-%dT%H:%M:%SZ")
                })
            
            unique_news.extend(placeholder_news)
            print(f"Added {len(placeholder_news)} placeholder news articles")
        
        print(f"Final news count: {len(unique_news)}")
        
        # 캐시에 저장
        with open(cache_path, 'w', encoding='utf-8') as f:
            json.dump(unique_news, f, ensure_ascii=False, indent=2)
            print(f"Saved {len(unique_news)} news articles to cache")
            
        return unique_news
    
    def fetch_news_from_api(self, coin, date_from, date_to):
        """
        CryptoCompare API를 사용하여 암호화폐 뉴스 가져오기 (개선된 버전)
        """
        import requests
        import os
        from datetime import datetime, timedelta
        
        print("CryptoCompare API에서 뉴스 데이터 가져오기 시도 중...")
        
        # API 키 가져오기 (환경 변수에서)
        api_key = os.getenv("CRYPTOCOMPARE_API_KEY")
        if not api_key:
            print("CryptoCompare API 키가 설정되지 않았습니다. .env 파일을 확인하세요.")
            return []
        
        news_list = []
        try:
            # 코인 심볼 처리
            if isinstance(coin, str):
                if coin.startswith("KRW-"):
                    search_symbol = coin.split("-")[1]  # KRW-BTC -> BTC
                else:
                    search_symbol = coin
            else:
                search_symbol = str(coin)
                
            # CryptoCompare 뉴스 API 엔드포인트
            url = "https://min-api.cryptocompare.com/data/v2/news/"
            
            # 요청 파라미터 (카테고리를 사용하지 않고 일반 뉴스 가져오기)
            params = {
                'api_key': api_key,
                'lang': 'EN',                # 영어 뉴스만
                'sortOrder': 'latest',       # 최신순 정렬
                'feeds': 'cryptocompare,cointelegraph,coindesk'  # 주요 뉴스 소스로 제한
            }
            
            # API 요청 및 응답 디버깅
            response = requests.get(url, params=params)
            print(f"API 요청 URL: {response.url}")
            print(f"응답 상태 코드: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                # 응답 데이터 구조 디버깅
                if 'Response' in data:
                    print(f"API 응답 상태: {data['Response']}")
                if 'Message' in data:
                    print(f"API 메시지: {data['Message']}")
                if 'Data' in data:
                    print(f"받은 뉴스 수: {len(data['Data'])}")
                    articles = data['Data']
                    
                    # 각 기사 정보 추출
                    for article in articles:
                        # 기사 제목과 내용에서 코인 관련 키워드 찾기
                        title = article.get('title', '').lower()
                        body = article.get('body', '').lower()
                        categories = article.get('categories', '').lower()
                        
                        # 해당 코인 관련 뉴스인지 확인 (제목, 내용, 카테고리에서 키워드 찾기)
                        coin_keywords = [search_symbol.lower(), 'bitcoin', 'btc', 'crypto', 'cryptocurrency']
                        is_relevant = False
                        for keyword in coin_keywords:
                            if keyword in title or keyword in body or keyword in categories:
                                is_relevant = True
                                break
                                
                        if not is_relevant:
                            continue  # 관련 없는 뉴스는 건너뛰기
                        
                        # 날짜 처리
                        article_date = datetime.fromtimestamp(article.get('published_on', 0))
                        
                        # 현재 백테스트는 과거 데이터를 사용하므로, 이 부분은 무시하고 모든 뉴스 가져오기
                        # 실제 운영에서는 날짜 범위 필터링 활성화
                        # if not (date_from <= article_date <= date_to):
                        #    continue
                        
                        # 기사 정보 포맷팅
                        news_item = {
                            'title': article.get('title', ''),
                            'description': article.get('body', '')[:200] + '...' if article.get('body') else '',
                            'publishedAt': article_date.strftime('%Y-%m-%dT%H:%M:%SZ'),
                            'source': article.get('source_info', {}).get('name', 'CryptoCompare'),
                            'url': article.get('url', ''),
                            'categories': article.get('categories', ''),
                            'tags': article.get('tags', ''),
                            'from_api': True
                        }
                        news_list.append(news_item)
                    
                    print(f"CryptoCompare API에서 {len(news_list)}개 뉴스 기사를 가져왔습니다.")
                else:
                    print("CryptoCompare API 응답에 'Data' 필드가 없습니다.")
                    print(f"응답 내용: {data}")
            else:
                print(f"CryptoCompare API 요청 실패: 상태 코드 {response.status_code}")
                print(f"응답: {response.text}")
        
        except Exception as e:
            print(f"CryptoCompare API 요청 중 오류 발생: {str(e)}")
            import traceback
            print(traceback.format_exc())
        
        return news_list
    
    
    def _get_historical_news_cases(self, similar_patterns):
        """과거 유사 뉴스 사례 추출"""
        if not similar_patterns:
            return "No historical news cases found."
        
        cases = []
        for pattern in similar_patterns[:3]:  # 상위 3개만
            if pattern.get('news_data') and pattern.get('trade_result', {}).get('completed'):
                news_summary = pattern.get('news_summary', '')
                profit = pattern.get('trade_result', {}).get('profit_pct', 0)
                date = pattern.get('date', '')
                
                if news_summary:
                    cases.append(f"• {date}: '{news_summary}' → {profit:+.1f}% result")
        
        return "\n".join(cases) if cases else "No completed news cases found."



    def _analyze_article_sentiment(self, article):
        """
        기사 내용에 대한 간단한 감성 분석 수행
        """
        # 기사 자체에 감성 점수가 있는 경우 활용
        if 'sentiment' in article:
            return {
                'sentiment_score': article.get('sentiment', 0),
                'sentiment_type': 'positive' if article.get('sentiment', 0) > 0 else 
                                ('negative' if article.get('sentiment', 0) < 0 else 'neutral'),
                'impact_level': 'high' if abs(article.get('sentiment', 0)) > 0.5 else 
                            ('medium' if abs(article.get('sentiment', 0)) > 0.2 else 'low')
            }
        
        # 자체 감성 분석 로직 (키워드 기반 간단한 구현)
        title = article.get('title', '').lower()
        body = article.get('body', '').lower()
        
        positive_keywords = ['bull', 'bullish', 'surge', 'soar', 'rally', 'gain', 'grow', 'rise', 'positive', 'adoption']
        negative_keywords = ['bear', 'bearish', 'crash', 'fall', 'drop', 'decline', 'dump', 'negative', 'ban', 'regulation']
        
        sentiment_score = 0
        for keyword in positive_keywords:
            if keyword in title:
                sentiment_score += 0.2
            elif keyword in body:
                sentiment_score += 0.1
                
        for keyword in negative_keywords:
            if keyword in title:
                sentiment_score -= 0.2
            elif keyword in body:
                sentiment_score -= 0.1
        
        # 감성 점수 범위 제한 (-1 ~ 1)
        sentiment_score = max(-1, min(1, sentiment_score))
        
        return {
            'sentiment_score': sentiment_score,
            'sentiment_type': 'positive' if sentiment_score > 0 else 
                            ('negative' if sentiment_score < 0 else 'neutral'),
            'impact_level': 'high' if abs(sentiment_score) > 0.5 else 
                        ('medium' if abs(sentiment_score) > 0.2 else 'low')
        }
    
    def fetch_historical_data(self, ticker, interval="day", count=100, to=None):
        """
        Fetch historical OHLCV data from Upbit and store in self.historical_data
        """
        try:
            if to:
                df = pyupbit.get_ohlcv(ticker, interval=interval, count=count, to=to)
            else:
                df = pyupbit.get_ohlcv(ticker, interval=interval, count=count)
            
            if df is not None and not df.empty:
                # ===== 중요 추가: DataFrame을 self.historical_data에 저장 =====
                self.historical_data = []  # 기존 데이터 초기화
                
                for timestamp, row in df.iterrows():
                    data_point = {
                        'date': timestamp.strftime('%Y-%m-%d'),
                        'datetime': timestamp,
                        'price': row['close'],
                        'close': row['close'],
                        'open': row['open'],
                        'high': row['high'],
                        'low': row['low'],
                        'volume': row['volume']
                    }
                    self.historical_data.append(data_point)
                
                print(f"Historical data stored: {len(self.historical_data)} records")
                
                # 날짜 컬럼 추가
                if isinstance(df.index[0], pd.Timestamp):
                    df['date'] = df.index.strftime('%Y-%m-%d')
                
                return df
            else:
                print(f"Error fetching data for {ticker}: Empty dataframe returned")
                return None
        except Exception as e:
            print(f"Error fetching data for {ticker}: {str(e)}")
            return None

    def calculate_technical_indicators(self, df):
        """
        Calculate technical indicators for the given dataframe
        
        # 주어진 데이터프레임에 대한 기술적 지표 계산
        """
        if df is None or df.empty:
            return None, {}
        
        # 입력 데이터 확인 및 전처리
        try:
            # 'close' 컬럼이 없는 경우 생성
            if 'close' not in df.columns:
                if 'price' in df.columns:
                    df['close'] = df['price']
                elif 'Close' in df.columns:
                    df['close'] = df['Close']
                else:
                    # 데이터가 단일 시리즈인 경우
                    if isinstance(df, pd.Series):
                        df = pd.DataFrame(df)
                        df.columns = ['close']
                    else:
                        print("Cannot find price data for technical indicators")
                        return df, {}
        except Exception as e:
            print(f"Error preprocessing data for technical indicators: {str(e)}")
            return df, {}
        
        # 기술적 지표 계산
        tech_indicators = {}
        
        try:
            # RSI 계산
            delta = df['close'].diff()
            gain = delta.clip(lower=0).rolling(window=14).mean()
            loss = abs(delta.clip(upper=0)).rolling(window=14).mean()
            rs = gain / loss
            rsi = 100 - (100 / (1 + rs))
            if not pd.isna(rsi.iloc[-1]):
                tech_indicators["RSI(14)"] = round(rsi.iloc[-1], 2)
        except Exception as e:
            print(f"Error calculating RSI: {str(e)}")
        
        try:
            # MACD 계산
            exp1 = df['close'].ewm(span=12, adjust=False).mean()
            exp2 = df['close'].ewm(span=26, adjust=False).mean()
            macd = exp1 - exp2
            signal = macd.ewm(span=9, adjust=False).mean()
            
            if not (pd.isna(macd.iloc[-1]) or pd.isna(signal.iloc[-1])):
                if macd.iloc[-1] > signal.iloc[-1] and macd.iloc[-2] <= signal.iloc[-2]:
                    tech_indicators["MACD"] = "Bullish crossover (12, 26, 9)"
                elif macd.iloc[-1] < signal.iloc[-1] and macd.iloc[-2] >= signal.iloc[-2]:
                    tech_indicators["MACD"] = "Bearish crossover (12, 26, 9)"
                elif macd.iloc[-1] > signal.iloc[-1]:
                    tech_indicators["MACD"] = "Bullish (above signal line)"
                else:
                    tech_indicators["MACD"] = "Bearish (below signal line)"
        except Exception as e:
            print(f"Error calculating MACD: {str(e)}")
        
        try:
            # 볼린저 밴드 계산
            ma20 = df['close'].rolling(window=20).mean()
            std20 = df['close'].rolling(window=20).std()
            upper_band = ma20 + (std20 * 2)
            lower_band = ma20 - (std20 * 2)
            
            if len(df) >= 20 and not pd.isna(ma20.iloc[-1]):
                current_close = df['close'].iloc[-1]
                if current_close >= upper_band.iloc[-1] * 0.98:
                    tech_indicators["Bollinger Bands"] = "Near upper band"
                elif current_close <= lower_band.iloc[-1] * 1.02:
                    tech_indicators["Bollinger Bands"] = "Near lower band"
                else:
                    tech_indicators["Bollinger Bands"] = "Between bands"
        except Exception as e:
            print(f"Error calculating Bollinger Bands: {str(e)}")
        
        try:
            # 이동평균선 확인
            if len(df) >= 20:
                ma5 = df['close'].rolling(window=5).mean().iloc[-1]
                ma10 = df['close'].rolling(window=10).mean().iloc[-1]
                ma20 = df['close'].rolling(window=20).mean().iloc[-1]
                
                if not (pd.isna(ma5) or pd.isna(ma10) or pd.isna(ma20)):
                    current_close = df['close'].iloc[-1]
                    
                    if current_close > ma5 > ma10 > ma20:
                        tech_indicators["Moving Averages"] = "Price > MA5 > MA10 > MA20"
                    elif ma5 > ma10 > ma20:
                        tech_indicators["Moving Averages"] = "MA5 > MA10 > MA20"
                    elif current_close < ma5 < ma10 < ma20:
                        tech_indicators["Moving Averages"] = "Price < MA5 < MA10 < MA20"
                    else:
                        tech_indicators["Moving Averages"] = "Mixed"
        except Exception as e:
            print(f"Error calculating Moving Averages: {str(e)}")
        
        try:
            # 거래량 분석 (거래량 데이터가 있는 경우)
            if 'volume' in df.columns and len(df) >= 6:
                avg_volume = df['volume'].iloc[-6:-1].mean()
                current_volume = df['volume'].iloc[-1]
                
                if not (pd.isna(avg_volume) or pd.isna(current_volume)):
                    if current_volume > avg_volume * 1.2:
                        tech_indicators["Volume"] = "Increasing trend"
                    elif current_volume < avg_volume * 0.8:
                        tech_indicators["Volume"] = "Decreasing trend"
                    else:
                        tech_indicators["Volume"] = "Stable"
        except Exception as e:
            print(f"Error calculating Volume analysis: {str(e)}")
        
        try:
            # 변동성 계산
            if len(df) >= 5:
                returns = df['close'].pct_change().iloc[-5:]
                volatility = returns.std() * np.sqrt(252)  # 연환산 변동성
                if not pd.isna(volatility):
                    tech_indicators["Volatility"] = round(volatility * 100, 2)  # 퍼센트로 표시
        except Exception as e:
            print(f"Error calculating Volatility: {str(e)}")
        
        return df, tech_indicators
    
    def get_recent_market_context(self, days=10):
        """향상된 시장 컨텍스트 제공 함수"""
        try:
            # 최근 가격 데이터 사용 (일별 가격 변화, 볼륨 등)
            recent_results = self.backtest_results[-days:] if hasattr(self, 'backtest_results') and len(self.backtest_results) > 0 else []
            
            # 추가된 부분: 처음 실행 시 초기화 처리
            if not recent_results and hasattr(self, 'historical_data') and len(self.historical_data) > 0:
                # 이전 데이터가 없지만 기존 히스토리컬 데이터가 있는 경우
                recent_results = self.historical_data[-days:] if len(self.historical_data) > days else self.historical_data
            
            if not recent_results:
                # 여전히 데이터가 없으면 기본 컨텍스트 제공
                return """
    Market context: Limited historical data available. 
    Based on general Bitcoin patterns, the market frequently exhibits high volatility with rapid price changes. 
    Recent price action shows consolidation with potential for breakout depending on global macro factors and institutional adoption rates.
    Volume appears moderate with no extreme spikes to indicate major market shifts.
    Support and resistance levels are forming based on recent trading ranges.
    """
            
            # 가격 변화 및 추세 파악
            context = "Recent market activity details:\n"
            
            # 가격 변화 계산
            prices = []
            price_changes = []
            volumes = []
            
            for i, day in enumerate(recent_results):
                if 'price' in day:
                    prices.append(day['price'])
                    
                if i > 0 and 'price' in day and 'price' in recent_results[i-1]:
                    daily_change = ((day['price'] / recent_results[i-1]['price']) - 1) * 100
                    price_changes.append(daily_change)
                
                # 볼륨 정보 확인
                if 'technical_indicators' in day and day['technical_indicators']:
                    for key, value in day['technical_indicators'].items():
                        if 'volume' in key.lower() or 'vol' in key.lower():
                            volumes.append(value)
            
            # 가격 추세 분석
            if prices:
                avg_price = sum(prices) / len(prices)
                min_price = min(prices)
                max_price = max(prices)
                price_range = ((max_price - min_price) / min_price) * 100 if min_price > 0 else 0
                
                context += f"- Average price: ₩{avg_price:,.0f} KRW\n"
                context += f"- Price range: {price_range:.2f}% (₩{min_price:,.0f} - ₩{max_price:,.0f})\n"
            
            # 가격 모멘텀 분석
            if price_changes:
                up_days = sum(1 for change in price_changes if change > 0)
                down_days = sum(1 for change in price_changes if change < 0)
                flat_days = sum(1 for change in price_changes if abs(change) < 0.1)
                
                avg_change = sum(price_changes) / len(price_changes)
                
                # 추세 방향 감지
                if up_days > down_days and avg_change > 0.5:
                    trend = "Uptrend"
                elif down_days > up_days and avg_change < -0.5:
                    trend = "Downtrend"
                else:
                    trend = "Sideways/Consolidation"
                    
                context += f"- Market trend: {trend} ({up_days} up days, {down_days} down days, {flat_days} flat days)\n"
                context += f"- Average daily change: {avg_change:.2f}%\n"
                
                # 볼라틸리티 계산
                if len(price_changes) > 1:
                    volatility = sum((change - avg_change) ** 2 for change in price_changes) / len(price_changes)
                    volatility = volatility ** 0.5  # 표준편차
                    context += f"- Volatility (std dev): {volatility:.2f}%\n"
                    
                    if volatility > 3:
                        context += "- High volatility market conditions\n"
                    elif volatility < 1:
                        context += "- Low volatility market conditions\n"
            
            # 볼륨 분석
            if volumes and len(volumes) > 1:
                try:
                    # 볼륨 값을 숫자로 변환
                    numeric_volumes = []
                    for vol in volumes:
                        if isinstance(vol, (int, float)):
                            numeric_volumes.append(float(vol))
                        elif isinstance(vol, str):
                            # 문자열에서 숫자 추출 시도
                            vol_clean = vol.replace(',', '').replace('%', '')
                            try:
                                numeric_volumes.append(float(vol_clean))
                            except:
                                pass
                    
                    if numeric_volumes:
                        avg_volume = sum(numeric_volumes) / len(numeric_volumes)
                        last_volume = numeric_volumes[-1]
                        vol_change = ((last_volume / avg_volume) - 1) * 100
                        
                        context += f"- Volume trend: "
                        if vol_change > 20:
                            context += "Significantly increasing (potential trend acceleration)\n"
                        elif vol_change > 5:
                            context += "Moderately increasing\n"
                        elif vol_change < -20:
                            context += "Significantly decreasing (potential trend exhaustion)\n"
                        elif vol_change < -5:
                            context += "Moderately decreasing\n"
                        else:
                            context += "Stable\n"
                except Exception as e:
                    print(f"Error analyzing volume data: {str(e)}")
            
            # 기술적 지표 분석
            rsi_values = []
            macd_values = []
            
            for day in recent_results:
                if 'technical_indicators' in day and day['technical_indicators']:
                    for key, value in day['technical_indicators'].items():
                        if 'rsi' in key.lower():
                            try:
                                if isinstance(value, (int, float)):
                                    rsi_values.append(float(value))
                                elif isinstance(value, str):
                                    rsi_values.append(float(value.replace(',', '')))
                            except:
                                pass
                        
                        if 'macd' in key.lower():
                            try:
                                if isinstance(value, (int, float)):
                                    macd_values.append(float(value))
                                elif isinstance(value, str):
                                    macd_values.append(float(value.replace(',', '')))
                            except:
                                pass
            
            # RSI 분석
            if rsi_values:
                last_rsi = rsi_values[-1]
                context += f"- Current RSI: {last_rsi:.1f} - "
                
                if last_rsi > 70:
                    context += "Overbought conditions (potential reversal or continuation)\n"
                elif last_rsi < 30:
                    context += "Oversold conditions (potential reversal or continuation)\n"
                elif last_rsi > 50:
                    context += "Bullish momentum (moderate)\n"
                else:
                    context += "Bearish momentum (moderate)\n"
                
                # RSI 방향 확인
                if len(rsi_values) > 1:
                    rsi_direction = rsi_values[-1] - rsi_values[-2]
                    if rsi_direction > 3:
                        context += "- RSI: Strong upward momentum\n"
                    elif rsi_direction > 0:
                        context += "- RSI: Slight upward momentum\n"
                    elif rsi_direction < -3:
                        context += "- RSI: Strong downward momentum\n"
                    elif rsi_direction < 0:
                        context += "- RSI: Slight downward momentum\n"
            
            # MACD 분석
            if macd_values and len(macd_values) > 1:
                macd_direction = macd_values[-1] - macd_values[-2]
                context += "- MACD: "
                
                if macd_values[-1] > 0 and macd_direction > 0:
                    context += "Strong bullish momentum (above zero and rising)\n"
                elif macd_values[-1] > 0 and macd_direction < 0:
                    context += "Weakening bullish momentum (above zero but falling)\n"
                elif macd_values[-1] < 0 and macd_direction > 0:
                    context += "Improving bearish momentum (below zero but rising)\n"
                elif macd_values[-1] < 0 and macd_direction < 0:
                    context += "Strong bearish momentum (below zero and falling)\n"
            
            # 지원/저항 레벨 분석 (간단한 방식)
            if prices and len(prices) > 5:
                # 간단한 지원/저항 레벨 식별
                sorted_prices = sorted(prices)
                resistance = sorted_prices[-1]  # 최고가
                support = sorted_prices[0]      # 최저가
                
                # 현재 가격과의 거리 계산
                current_price = prices[-1]
                dist_to_resistance = ((resistance / current_price) - 1) * 100
                dist_to_support = ((current_price / support) - 1) * 100
                
                context += f"- Current price is {dist_to_resistance:.2f}% below recent resistance (₩{resistance:,.0f})\n"
                context += f"- Current price is {dist_to_support:.2f}% above recent support (₩{support:,.0f})\n"
                
                # 가격 위치 해석
                if dist_to_resistance < 1:
                    context += "- Price is testing resistance level (breakout potential)\n"
                elif dist_to_support < 1:
                    context += "- Price is testing support level (breakdown risk)\n"
            
            # 트레이딩 패턴 분석
            if price_changes and len(price_changes) >= 3:
                # 최근 변동성 확인
                recent_volatility = sum(abs(change) for change in price_changes[-3:]) / 3
                
                if recent_volatility > 5:
                    context += "- Trading pattern: High volatility swings (whipsaw pattern)\n"
                elif all(abs(change) < 0.8 for change in price_changes[-3:]):
                    context += "- Trading pattern: Low volatility compression (potential breakout setup)\n"
                elif all(change > 0 for change in price_changes[-3:]):
                    context += "- Trading pattern: Consecutive up days (strong bullish momentum)\n"
                elif all(change < 0 for change in price_changes[-3:]):
                    context += "- Trading pattern: Consecutive down days (strong bearish pressure)\n"
                elif price_changes[-1] > 0 and price_changes[-2] < 0 and price_changes[-3] < 0:
                    context += "- Trading pattern: Potential bullish reversal after downtrend\n"
                elif price_changes[-1] < 0 and price_changes[-2] > 0 and price_changes[-3] > 0:
                    context += "- Trading pattern: Potential bearish reversal after uptrend\n"
                
            return context
        
        except Exception as e:
            print(f"Error creating market context: {str(e)}")
            return "Market context analysis encountered an error. Using limited information for decision making."

    def get_news_cache_path(self, coin, date_from, date_to):
        """
        특정 날짜 범위의 뉴스에 대한 캐시 파일 경로 반환
        
        Parameters:
        -----------
        coin : str
            코인 심볼 (예: "KRW-BTC")
        date_from : datetime
            시작 날짜
        date_to : datetime
            종료 날짜
            
        Returns:
        --------
        str
            캐시 파일 경로
        """
        # 코인 심볼 정리
        if coin.startswith("KRW-"):
            symbol = coin.split("-")[1]
        else:
            symbol = coin
            
        date_from_str = date_from.strftime("%Y%m%d")
        date_to_str = date_to.strftime("%Y%m%d")
        
        return os.path.join(self.news_cache_dir, f"{symbol.lower()}_{date_from_str}_{date_to_str}.json")
    
    def fetch_news_with_selenium(self, coin, date_from, date_to):
        """
        셀레니움을 사용하여 암호화폐 뉴스를 가져옵니다
        """
        if self.selenium_driver is None:
            print("Selenium driver not initialized")
            return []
            
        # 캐시 파일 경로
        cache_path = self.get_news_cache_path(coin, date_from, date_to)
        
        # 캐시 확인 (비어있는 캐시도 체크)
        if os.path.exists(cache_path):
            try:
                with open(cache_path, 'r', encoding='utf-8') as f:
                    cached_data = json.load(f)
                    if cached_data and len(cached_data) > 0:  # 비어있는지 확인
                        print(f"Loading news from cache: {cache_path}")
                        return cached_data
                    else:
                        print(f"Empty cache file, regenerating...")
            except:
                print(f"Error reading cache, regenerating...")
        
        # 코인 심볼 정리
        if coin.startswith("KRW-"):
            symbol = coin.split("-")[1]
        else:
            symbol = coin
        
        news_list = []
        
        # 1. 매일경제 검색
        try:
            search_url = f"https://www.mk.co.kr/en/search?word={symbol.lower()}&dateType=direct&startDate={date_from.strftime('%Y-%m-%d')}&endDate={date_to.strftime('%Y-%m-%d')}"
            
            print(f"Fetching news from Maeil Business Newspaper: {search_url}")
            self.selenium_driver.get(search_url)
            time.sleep(3)  # 페이지 로딩 대기
            
            # 뉴스 아티클 요소 찾기
            article_elements = self.selenium_driver.find_elements(By.CSS_SELECTOR, "article")
            
            for article in article_elements[:10]:  # 최대 10개 뉴스만 가져옴
                try:
                    # 제목 추출
                    title_element = article.find_element(By.CSS_SELECTOR, "h2, h3")
                    title = title_element.text.strip()
                    
                    # 링크 추출
                    link_element = article.find_element(By.TAG_NAME, "a")
                    link = link_element.get_attribute("href")
                    
                    news_list.append({
                        "title": title,
                        "url": link,
                        "description": "",
                        "source": "Maeil Business",
                        "publishedAt": date_from.strftime("%Y-%m-%dT%H:%M:%SZ")
                    })
                except NoSuchElementException:
                    continue
            
            time.sleep(1)  # 요청 간격 유지
        except Exception as e:
            print(f"Error fetching news from Maeil Business: {str(e)}")
        
        # 2. BlockMedia 뉴스 크롤링
        try:
            search_url = f"https://www.blockmedia.co.kr/search?q={symbol}"
            print(f"Fetching news from BlockMedia: {search_url}")
            self.selenium_driver.get(search_url)
            time.sleep(3)
            
            # 뉴스 아티클 요소 찾기
            article_elements = self.selenium_driver.find_elements(By.CSS_SELECTOR, ".article-list li, .news-item")[:15]
            
            for article in article_elements:
                try:
                    # 제목 추출
                    title_element = article.find_element(By.CSS_SELECTOR, "h2, h3, .title")
                    title = title_element.text.strip()
                    
                    # 링크 추출
                    link_element = article.find_element(By.TAG_NAME, "a")
                    link = link_element.get_attribute("href")
                    
                    if title and link:
                        news_list.append({
                            "title": title,
                            "url": link,
                            "description": "",
                            "source": "BlockMedia",
                            "publishedAt": date_from.strftime("%Y-%m-%dT%H:%M:%SZ")
                        })
                except NoSuchElementException:
                    continue
                    
            time.sleep(1)  # 요청 간격 유지
            
        except Exception as e:
            print(f"Error fetching news from BlockMedia: {str(e)}")
        
        # 3. CoinTelegraph 뉴스 크롤링
        try:
            search_url = f"https://cointelegraph.com/search?query={symbol.lower()}"
            print(f"Fetching news from CoinTelegraph: {search_url}")
            self.selenium_driver.get(search_url)
            time.sleep(3)
            
            # 검색 결과 찾기
            news_links = self.selenium_driver.find_elements(By.CSS_SELECTOR, ".post-card-inline a, .news-item a")[:15]
            
            for news_link in news_links:
                try:
                    title = news_link.text.strip()
                    url = news_link.get_attribute("href")
                    
                    if title and url:
                        news_list.append({
                            "title": title,
                            "url": url,
                            "description": "",
                            "source": "CoinTelegraph",
                            "publishedAt": date_from.strftime("%Y-%m-%dT%H:%M:%SZ")
                        })
                except NoSuchElementException:
                    continue
                    
            time.sleep(1)  # 요청 간격 유지
            
        except Exception as e:
            print(f"Error fetching news from CoinTelegraph: {str(e)}")
        
        # 중복 제거
        unique_news = []
        seen_titles = set()
        for news in news_list:
            if news["title"] not in seen_titles:
                unique_news.append(news)
                seen_titles.add(news["title"])
        
        # 최소 뉴스 개수 확인
        min_news_count = 5  # 최소한 5개의 뉴스는 필요
        if len(unique_news) < min_news_count:
            print(f"Failed to fetch enough news. Only {len(unique_news)} news articles found.")
            # 재시도 로직이나 기본 뉴스 추가 가능
            # 기본 뉴스 추가
            default_news = [
                {
                    "title": f"{symbol} market analysis",
                    "url": "",
                    "description": "",
                    "source": "Default",
                    "publishedAt": date_from.strftime("%Y-%m-%dT%H:%M:%SZ")
                } for _ in range(min_news_count - len(unique_news))
            ]
            unique_news.extend(default_news)
        
        # 캐시에 저장
        with open(cache_path, 'w', encoding='utf-8') as f:
            json.dump(unique_news, f, ensure_ascii=False, indent=2)
            
        return unique_news
    
    def fetch_news(self, coin, date_from, date_to):
        """
        개선된 뉴스 가져오기 함수 - 오류 처리 및 캐싱 개선
        
        Args:
            coin: 코인 심볼
            date_from: 시작 날짜
            date_to: 종료 날짜
            
        Returns:
            list: 뉴스 목록
        """
        print(f"==== Fetching news for {coin} from {date_from} to {date_to} ====")
        
        # 날짜 객체 확인 및 변환
        if isinstance(date_from, str):
            try:
                date_from = pd.to_datetime(date_from)
            except:
                date_from = datetime.datetime.now() - datetime.timedelta(days=7)
        
        if isinstance(date_to, str):
            try:
                date_to = pd.to_datetime(date_to)
            except:
                date_to = datetime.datetime.now()
        
        # 캐시 확인
        cache_path = self.get_news_cache_path(coin, date_from, date_to)
        if os.path.exists(cache_path):
            try:
                with open(cache_path, 'r', encoding='utf-8') as f:
                    cached_news = json.load(f)
                    if cached_news and len(cached_news) > 0:
                        print(f"Using cached news data: {len(cached_news)} articles")
                        return cached_news
            except Exception as e:
                print(f"Error reading cache: {str(e)}")
        
        news_list = []
        
        # 1. 뉴스 데이터셋 핸들러 사용
        if hasattr(self, 'news_handlers') and self.news_handlers:
            try:
                dataset_news = self.fetch_news_from_dataset(coin, date_from, date_to)
                if dataset_news:
                    news_list.extend(dataset_news)
                    print(f"Fetched {len(dataset_news)} news articles from datasets")
            except Exception as e:
                print(f"Error fetching news from datasets: {str(e)}")
        
        # 2. 셀레니움 뉴스 크롤링
        if hasattr(self, 'use_selenium') and self.use_selenium and hasattr(self, 'selenium_driver') and self.selenium_driver:
            try:
                selenium_news = self.fetch_news_with_selenium(coin, date_from, date_to)
                if selenium_news:
                    news_list.extend(selenium_news)
                    print(f"Fetched {len(selenium_news)} news articles from Selenium")
            except Exception as e:
                print(f"Error fetching news with Selenium: {str(e)}")
        
        # 3. NewsAPI 사용
        if hasattr(self, 'news_api_key') and self.news_api_key:
            try:
                api_news = self.fetch_news_from_api(coin, date_from, date_to)
                if api_news:
                    news_list.extend(api_news)
                    print(f"Fetched {len(api_news)} news articles from NewsAPI")
            except Exception as e:
                print(f"Error fetching news from API: {str(e)}")
        
        # 뉴스가 없는 경우 샘플 데이터 생성
        if not news_list:
            print("No news found, generating sample news data")
            sample_news = self.generate_sample_news(coin, date_from, date_to)
            news_list.extend(sample_news)
        
        # 중복 제거
        unique_news = []
        seen_titles = set()
        
        for news in news_list:
            title = news.get('title', '').strip()
            if title and title not in seen_titles:
                unique_news.append(news)
                seen_titles.add(title)
        
        # 뉴스를 날짜순으로 정렬
        unique_news.sort(key=lambda x: x.get('publishedAt', ''), reverse=True)
        
        # 결과 캐싱
        try:
            with open(cache_path, 'w', encoding='utf-8') as f:
                json.dump(unique_news, f, ensure_ascii=False, indent=2)
            print(f"Cached {len(unique_news)} news articles")
        except Exception as e:
            print(f"Error caching news: {str(e)}")
        
        print(f"Fetched {len(unique_news)} unique news for {coin}")
        return unique_news
    

    def save_news_correlations(self, file_path="news_correlations.pkl.gz"):
        """
        뉴스 상관관계 데이터 압축 저장
        
        Args:
            file_path: 저장 파일 경로
            
        Returns:
            bool: 저장 성공 여부
        """
        if not hasattr(self, 'news_correlations') or not self.news_correlations:
            print("저장할 뉴스 상관관계 데이터가 없습니다")
            return False
        
        try:
            import pickle
            import gzip
            with gzip.open(file_path, 'wb') as f:
                pickle.dump(self.news_correlations, f)
            print(f"{len(self.news_correlations)}개 뉴스 상관관계 정보 저장 완료")
            return True
        except Exception as e:
            print(f"뉴스 상관관계 저장 오류: {str(e)}")
            return False
        

    def visualize_news_correlations(self):
        """
        뉴스 상관관계 시각화
        
        Returns:
            matplotlib.figure.Figure: 시각화 결과 그래프
        """
        if not hasattr(self, 'news_correlations') or not self.news_correlations:
            print("시각화할 뉴스 상관관계 데이터가 없습니다")
            return None
        
        try:
            import matplotlib.pyplot as plt
            import numpy as np
            
            # 데이터 추출
            sentiments = []
            price_impacts = []
            themes = []
            confidence = []
            
            for key, data in self.news_correlations.items():
                sentiment = data.get('sentiment_score', 0)
                impact = data.get('price_impact_6h', 0)
                
                if impact is not None and sentiment is not None:
                    sentiments.append(sentiment)
                    price_impacts.append(impact)
                    
                    # 주제에 따른 색상 구분
                    theme_list = data.get('themes', [])
                    if 'regulation' in theme_list:
                        themes.append('red')
                    elif 'adoption' in theme_list:
                        themes.append('green')
                    elif 'technology' in theme_list:
                        themes.append('blue')
                    else:
                        themes.append('gray')
                    
                    # 신뢰도에 따른 크기 구분
                    if abs(sentiment) > 0.5:
                        confidence.append(80)
                    elif abs(sentiment) > 0.3:
                        confidence.append(60)
                    else:
                        confidence.append(40)
            
            # 그래프 그리기
            plt.figure(figsize=(12, 8))
            
            # 산점도
            scatter = plt.scatter(sentiments, price_impacts, c=themes, s=confidence, alpha=0.6)
            
            # 추세선
            if len(sentiments) > 2:
                z = np.polyfit(sentiments, price_impacts, 1)
                p = np.poly1d(z)
                plt.plot(sorted(sentiments), p(sorted(sentiments)), "r--", alpha=0.7)
            
            # 좌표축
            plt.axhline(y=0, color='r', linestyle='-', alpha=0.3)
            plt.axvline(x=0, color='r', linestyle='-', alpha=0.3)
            
            # 그래프 설정
            plt.title('뉴스 감성과 6시간 후 가격 변화 관계')
            plt.xlabel('감성 점수')
            plt.ylabel('가격 변화율 (%)')
            plt.grid(True, alpha=0.3)
            
            # 상관계수 계산 및 표시
            correlation = np.corrcoef(sentiments, price_impacts)[0, 1]
            plt.text(0.05, 0.95, f'상관계수: {correlation:.4f}', transform=plt.gca().transAxes,
                    bbox=dict(facecolor='white', alpha=0.7))
            
            # 통계 정보 표시
            pos_count = sum(1 for i in price_impacts if i > 0)
            neg_count = sum(1 for i in price_impacts if i < 0)
            plt.text(0.05, 0.90, f'긍정영향/부정영향: {pos_count}/{neg_count}', transform=plt.gca().transAxes,
                    bbox=dict(facecolor='white', alpha=0.7))
            
            plt.tight_layout()
            
            # 저장
            plt.savefig('news_correlation_analysis.png', dpi=300)
            plt.show()
            
            return plt.gcf()
        
        except Exception as e:
            print(f"뉴스 상관관계 시각화 오류: {str(e)}")
            return None


    def load_news_correlations(self, file_path="news_correlations.pkl.gz"):
        """
        뉴스 상관관계 데이터 로드
        
        Args:
            file_path: 로드할 파일 경로
            
        Returns:
            bool: 로드 성공 여부
        """
        try:
            import pickle
            import gzip
            import os
            
            if not os.path.exists(file_path):
                print(f"뉴스 상관관계 파일이 존재하지 않습니다: {file_path}")
                return False
            
            with gzip.open(file_path, 'rb') as f:
                self.news_correlations = pickle.load(f)
            
            print(f"{len(self.news_correlations)}개 뉴스 상관관계 정보 로드 완료")
            return True
        except Exception as e:
            print(f"뉴스 상관관계 로드 오류: {str(e)}")
            self.news_correlations = {}
            return False
    

    def improve_rag_context(self, current_date, news_data, tech_indicators):
        """향상된 RAG 컨텍스트 생성 함수 - 마켓 마이크로 구조 및 시장 심리 분석"""
        try:
            # 뉴스 데이터 sentiment 분석
            news_sentiment = 0
            news_impact = "neutral"
            key_topics = []
            
            if news_data and len(news_data) > 0:
                # 뉴스 제목 및 내용에서 긍정/부정 키워드 검색
                positive_keywords = ["rally", "surge", "soar", "gain", "bullish", "optimistic", "adoption", "regulatory clarity"]
                negative_keywords = ["crash", "fall", "drop", "ban", "regulation", "bearish", "sell-off", "hack", "security"]
                
                positive_count = 0
                negative_count = 0
                
                # 뉴스에서 키워드 추출
                for news in news_data:
                    title = news.get('title', '').lower()
                    desc = news.get('description', '').lower()
                    
                    # 긍정/부정 키워드 카운트
                    for keyword in positive_keywords:
                        if keyword in title or keyword in desc:
                            positive_count += 1
                    
                    for keyword in negative_keywords:
                        if keyword in title or keyword in desc:
                            negative_count += 1
                    
                    # 핵심 토픽 추출
                    topics = ["regulation", "adoption", "institutional", "technology", "mining", "defi", "nft", "security"]
                    for topic in topics:
                        if topic in title or topic in desc:
                            if topic not in key_topics:
                                key_topics.append(topic)
                
                # 뉴스 감성 점수 계산
                if positive_count + negative_count > 0:
                    news_sentiment = (positive_count - negative_count) / (positive_count + negative_count)
                
                # 영향력 판단
                if len(news_data) > 5:
                    news_impact = "high"
                elif len(news_data) > 2:
                    news_impact = "medium"
                else:
                    news_impact = "low"
            
            # 거래량 대비 가격 변동성 분석
            volume_price_ratio = "normal"
            if tech_indicators and 'Volume' in tech_indicators and any(key for key in tech_indicators.keys() if 'volatility' in key.lower()):
                try:
                    volume_key = 'Volume'
                    volatility_key = next(key for key in tech_indicators.keys() if 'volatility' in key.lower())
                    
                    volume = tech_indicators[volume_key]
                    volatility = tech_indicators[volatility_key]
                    
                    # 문자열 처리
                    if isinstance(volume, str):
                        volume = float(volume.replace(',', '').replace('%', ''))
                    if isinstance(volatility, str):
                        volatility = float(volatility.replace(',', '').replace('%', ''))
                    
                    # 비율 계산
                    if isinstance(volume, (int, float)) and isinstance(volatility, (int, float)) and volume > 0:
                        vp_ratio = volatility / volume
                        
                        if vp_ratio > 2:
                            volume_price_ratio = "high volatility with low volume (potential manipulation)"
                        elif vp_ratio < 0.5:
                            volume_price_ratio = "low volatility with high volume (accumulation/distribution)"
                except:
                    pass
            
            # 마켓 마이크로 구조 분석
            market_structure = "neutral"
            
            rsi_value = 50  # 기본값
            for key, value in tech_indicators.items():
                if 'rsi' in key.lower():
                    try:
                        if isinstance(value, (int, float)):
                            rsi_value = float(value)
                        elif isinstance(value, str):
                            rsi_value = float(value.replace(',', ''))
                    except:
                        pass
            
            # 시장 심리 지표
            if rsi_value > 80:
                market_structure = "extreme greed (potential bubble)"
            elif rsi_value > 70:
                market_structure = "overbought (greed phase)"
            elif rsi_value < 20:
                market_structure = "extreme fear (potential bottom)"
            elif rsi_value < 30:
                market_structure = "oversold (fear phase)"
            
            # 현재 마켓 상황 종합 분석
            current_market_state = f"""
    Market Microstructure Analysis:
    - News sentiment: {"Positive" if news_sentiment > 0.3 else "Negative" if news_sentiment < -0.3 else "Neutral"} with {news_impact} impact
    - Key market topics: {', '.join(key_topics) if key_topics else "None identified"}
    - Volume-price dynamics: {volume_price_ratio}
    - Market psychology: {market_structure}
    - Current date: {current_date}

    Trading Implications:
    """
            # 트레이딩 시사점 추가
            if rsi_value > 70 and news_sentiment > 0.3:
                current_market_state += "- Bullish sentiment with overbought conditions - consider taking profits or setting tighter trailing stops"
            elif rsi_value < 30 and news_sentiment < -0.3:
                current_market_state += "- Bearish sentiment with oversold conditions - watch for potential capitulation followed by reversal"
            elif rsi_value > 50 and news_sentiment > 0:
                current_market_state += "- Positive sentiment with bullish momentum - potential for continuation"
            elif rsi_value < 50 and news_sentiment < 0:
                current_market_state += "- Negative sentiment with bearish momentum - consider defensive positioning"
            elif abs(news_sentiment) < 0.2 and 40 < rsi_value < 60:
                current_market_state += "- Neutral conditions with balanced sentiment - range-bound trading likely"
                
            # 특별 주의사항 (있는 경우)
            if "extreme" in market_structure:
                current_market_state += "\n- CAUTION: Extreme market psychology detected - high risk of sharp reversal"
            
            return current_market_state
        
        except Exception as e:
            print(f"Error improving RAG context: {str(e)}")
            return "Limited enhanced market context available due to analysis error."
    
    def find_similar_patterns(self, current_indicators, lookback_days=30, success_weight=False, time_decay=False):
        """현재 상황과 유사한 과거 패턴 검색 - 성공 패턴에 가중치 부여
        
        Args:
            current_indicators: 현재 기술적 지표
            lookback_days: 검색할 과거 데이터 기간 (일)
            success_weight: 성공 패턴에 가중치 부여 여부
            time_decay: 시간 경과에 따른 가중치 감소 적용 여부
        
        Returns:
            list: 유사 패턴 목록 (유사도 점수 내림차순)
        """
        similar_contexts = []
        
        # document_store가 없거나 비어있는 경우 초기화
        if not hasattr(self, 'document_store') or not self.document_store:
            self.document_store = []
            return []
        
        # 현재 시점 확인
        current_date = datetime.datetime.now()
        
        # 검색 로직
        for doc in self.document_store[-lookback_days*3:]:  # 데이터량 증가
            # 기본 유사도 점수 초기화
            similarity_score = 0
            matching_points = 0
            
            # 1. RSI 유사도 체크
            if 'RSI(14)' in doc.get('indicators', {}) and 'RSI(14)' in current_indicators:
                try:
                    doc_rsi = float(str(doc['indicators']['RSI(14)']).replace(',', ''))
                    current_rsi = float(str(current_indicators['RSI(14)']).replace(',', ''))
                    rsi_diff = abs(doc_rsi - current_rsi)
                    
                    if rsi_diff < 5:
                        similarity_score += 3  # 매우 유사
                        matching_points += 1
                    elif rsi_diff < 10:
                        similarity_score += 2  # 유사
                        matching_points += 1
                    elif rsi_diff < 15:
                        similarity_score += 1  # 약간 유사
                        matching_points += 1
                except:
                    pass
            
            # 2. MACD 유사도 체크
            if 'MACD' in doc.get('indicators', {}) and 'MACD' in current_indicators:
                doc_macd = doc['indicators']['MACD']
                current_macd = current_indicators['MACD']
                
                if doc_macd == current_macd:
                    similarity_score += 2
                    matching_points += 1
                elif ("Bullish" in doc_macd and "Bullish" in current_macd) or \
                    ("Bearish" in doc_macd and "Bearish" in current_macd):
                    similarity_score += 1
                    matching_points += 1
            
            # 3. 볼린저 밴드 유사도 체크
            if 'Bollinger Bands' in doc.get('indicators', {}) and 'Bollinger Bands' in current_indicators:
                if doc['indicators']['Bollinger Bands'] == current_indicators['Bollinger Bands']:
                    similarity_score += 2
                    matching_points += 1
            
            # 4. 이동평균선 유사도 체크
            if 'Moving Averages' in doc.get('indicators', {}) and 'Moving Averages' in current_indicators:
                if doc['indicators']['Moving Averages'] == current_indicators['Moving Averages']:
                    similarity_score += 2
                    matching_points += 1
                elif ("Price >" in doc['indicators']['Moving Averages'] and "Price >" in current_indicators['Moving Averages']) or \
                    ("Price <" in doc['indicators']['Moving Averages'] and "Price <" in current_indicators['Moving Averages']):
                    similarity_score += 1
                    matching_points += 1
            
            # 5. 시장 추세 유사도 체크
            doc_trend = doc.get('market_trend', '')
            current_trend = self.detect_market_trend(current_indicators)
            
            if doc_trend and current_trend:
                if doc_trend == current_trend:
                    similarity_score += 3
                    matching_points += 1
                elif ("uptrend" in doc_trend and "uptrend" in current_trend) or \
                    ("downtrend" in doc_trend and "downtrend" in current_trend):
                    similarity_score += 2
                    matching_points += 1
            
            # 6. 지지선 유사도 체크
            if 'support_analysis' in doc:
                doc_support = doc.get('support_analysis', {})
                
                current_price = None
                if hasattr(self, 'historical_data') and len(self.historical_data) > 0:
                    current_price = self.historical_data[-1].get('price', self.historical_data[-1].get('close'))
                
                if current_price:
                    current_support = self._check_near_support_level_enhanced("KRW-BTC", current_price)
                    
                    # 지지선 근처 여부 매칭
                    if doc_support.get('is_near_support') == current_support.get('is_near_support'):
                        similarity_score += 1.5
                        matching_points += 1
                    
                    # 지지선 강도 유사도
                    if doc_support.get('strength') and current_support.get('strength'):
                        strength_diff = abs(doc_support['strength'] - current_support['strength'])
                        if strength_diff < 0.1:
                            similarity_score += 2
                            matching_points += 1
                        elif strength_diff < 0.2:
                            similarity_score += 1
                            matching_points += 1
            
            # 7. 성공 패턴에 가중치 부여 (신규)
            success_msg = "Pattern without result data"
            if success_weight and 'trade_result' in doc:
                # 거래가 완료되었는지 확인
                if doc['trade_result'].get('completed', False):
                    # 성공적인 거래였는지 확인
                    if doc['trade_result'].get('success', False):
                        profit_pct = doc['trade_result'].get('profit_pct', 0)
                        
                        # 수익률에 따른 추가 가중치
                        if profit_pct > 10:  # 매우 성공적인 거래
                            similarity_score *= 1.5
                        elif profit_pct > 5:  # 성공적인 거래
                            similarity_score *= 1.3
                        else:  # 약간 성공적인 거래
                            similarity_score *= 1.1
                        
                        success_msg = f"Successful pattern with {profit_pct:.1f}% profit"
                    else:
                        # 실패한 거래는 가중치 감소
                        similarity_score *= 0.8
                        loss_pct = abs(doc['trade_result'].get('profit_pct', 0))
                        success_msg = f"Failed pattern with {loss_pct:.1f}% loss"
            
            # 8. 시간 경과에 따른 가중치 감소 (신규)
            if time_decay and 'timestamp' in doc:
                try:
                    doc_date = doc['timestamp'] if isinstance(doc['timestamp'], datetime.datetime) else pd.to_datetime(doc['timestamp'])
                    days_old = (current_date - doc_date).days
                    
                    # 최대 180일까지 가중치 감소 (0.5까지)
                    if days_old > 0:
                        time_decay_factor = max(0.5, 1 - (days_old / 360))
                        similarity_score *= time_decay_factor
                except:
                    pass
            
            # 최소 매칭 포인트와 유사도 점수 기준
            if matching_points >= 2 and similarity_score >= 4:
                # 패턴 사용 횟수 증가 (참조 기록)
                if 'pattern_metrics' in doc:
                    doc['pattern_metrics']['usage_count'] = doc['pattern_metrics'].get('usage_count', 0) + 1
                
                pattern_info = {
                    'pattern_id': doc.get('pattern_id', ''),
                    'date': doc.get('date', ''),
                    'timestamp': doc.get('timestamp', ''),
                    'similarity_score': similarity_score,
                    'content': doc.get('content', ''),
                    'indicators': doc.get('indicators', {}),
                    'support_analysis': doc.get('support_analysis', {}),
                    'ai_decision': doc.get('ai_decision', 'UNKNOWN'),
                    'trade_result': doc.get('trade_result', {}) if 'trade_result' in doc else {},
                    'success_message': success_msg,
                    'pattern_metrics': doc.get('pattern_metrics', {}) if 'pattern_metrics' in doc else {}
                }
                
                similar_contexts.append(pattern_info)
            
        # 유사도 점수로 정렬
        similar_contexts.sort(key=lambda x: x['similarity_score'], reverse=True)
        
        # 상위 10개만 반환 (기존 5개에서 증가)
        top_patterns = similar_contexts[:10]
        
        # 디버그 메시지
        print(f"Found {len(top_patterns)} similar patterns from {len(self.document_store)} total patterns")
        for i, pattern in enumerate(top_patterns[:3]):  # 상위 3개만 표시
            status = "Success" if pattern.get('trade_result', {}).get('success', False) else "Failed" 
            profit = pattern.get('trade_result', {}).get('profit_pct', 0)
            if profit is None:
                profit = 0.0
            print(f"Pattern {i+1}: Date={pattern.get('date', 'unknown')}, Score={pattern['similarity_score']:.2f}, Status={status}, Profit={profit:.2f}%")
        
        return top_patterns
    
    def get_pattern_based_advice(self, similar_patterns):
        """유사 패턴 분석을 통한 거래 조언 생성
        
        Args:
            similar_patterns: 유사 패턴 목록
        
        Returns:
            dict: 패턴 기반 거래 조언
        """
        if not similar_patterns:
            return {
                'recommendation': 'INSUFFICIENT_DATA',
                'confidence': 0.0,
                'reasoning': 'No similar patterns found',
                'profit_expectation': 0.0,
                'params': {
                    'profit_target': 5.0,
                    'stop_loss': -2.0,
                    'trailing_stop': 1.0
                }
            }
        
        # 1. 완료된 거래만 필터링
        completed_patterns = [p for p in similar_patterns if p.get('trade_result', {}).get('completed', False)]
        
        if not completed_patterns:
            print("Warning: No completed trades in similar patterns")
            return {
                'recommendation': 'INSUFFICIENT_DATA',
                'confidence': 0.0,
                'reasoning': 'Similar patterns found but no completed trades',
                'profit_expectation': 0.0,
                'params': {
                    'profit_target': 5.0,
                    'stop_loss': -2.0,
                    'trailing_stop': 1.0
                }
            }
        
        # 2. 패턴 통계 계산
        successful_patterns = [p for p in completed_patterns if p.get('trade_result', {}).get('success', False)]
        failed_patterns = [p for p in completed_patterns if not p.get('trade_result', {}).get('success', False)]
        
        # 승률 계산
        win_rate = len(successful_patterns) / len(completed_patterns) if completed_patterns else 0
        
        # 평균 수익/손실 계산
        avg_profit = sum(p.get('trade_result', {}).get('profit_pct', 0) for p in successful_patterns) / len(successful_patterns) if successful_patterns else 0
        avg_loss = sum(p.get('trade_result', {}).get('profit_pct', 0) for p in failed_patterns) / len(failed_patterns) if failed_patterns else 0
        
        # 기대 수익 계산
        expected_profit = (win_rate * avg_profit) + ((1 - win_rate) * avg_loss)
        
        # 3. 결정 규칙
        # 승률이 50% 이상이고 기대 수익이 양수면 BUY
        if win_rate >= 0.5 and expected_profit > 0:
            recommendation = 'BUY'
            confidence = min(0.95, win_rate + (expected_profit / 20))  # 최대 0.95
            reasoning = f"Based on {len(completed_patterns)} similar patterns with {win_rate:.0%} win rate and {expected_profit:.2f}% expected profit"
        # 승률이 낮지만 기대 수익이 높은 경우 (높은 리스크/리워드)
        elif win_rate < 0.5 and expected_profit > 1.5:
            recommendation = 'BUY'
            confidence = 0.5 + (expected_profit / 30)  # 중간 정도 확신
            reasoning = f"High risk/reward opportunity based on {len(completed_patterns)} similar patterns with {expected_profit:.2f}% expected profit despite {win_rate:.0%} win rate"
        # 승률이 낮고 기대 수익도 낮거나 음수인 경우
        else:
            recommendation = 'HOLD'
            confidence = 0.5 + (abs(expected_profit) / 20) if expected_profit < 0 else 0.5
            reasoning = f"Avoiding risk based on {len(completed_patterns)} similar patterns with {win_rate:.0%} win rate and {expected_profit:.2f}% expected profit"
        
        # 4. 최적 파라미터 계산
        # 수익 패턴에서 최적 파라미터 추출
        if successful_patterns:
            # 가장 수익이 좋았던 상위 3개 패턴에서 파라미터 추출
            top_patterns = sorted(successful_patterns, key=lambda p: p.get('trade_result', {}).get('profit_pct', 0), reverse=True)[:3]
            
            # 가중 평균 계산
            total_weight = sum(p.get('trade_result', {}).get('profit_pct', 0) for p in top_patterns)
            profit_targets = []
            stop_losses = []
            trailing_stops = []
            
            for p in top_patterns:
                profit_pct = p.get('trade_result', {}).get('profit_pct', 0)
                weight = profit_pct / total_weight if total_weight > 0 else 1/len(top_patterns)
                
                # 원래 목표 파라미터 추정
                exit_reason = p.get('trade_result', {}).get('exit_reason', '')
                
                if exit_reason == 'PROFIT':
                    # 익절 목표는 실제 수익보다 약간 높게 설정
                    profit_targets.append((profit_pct * 1.1) * weight)
                elif exit_reason == 'TRAILING':
                    # 트레일링 스탑은 실제 수익의 비율로 추정
                    trailing_stops.append((profit_pct * 0.3) * weight)
                
                # 손절매는 평균 손실에서 추정
                if failed_patterns:
                    avg_failed = abs(sum(p.get('trade_result', {}).get('profit_pct', 0) for p in failed_patterns) / len(failed_patterns))
                    stop_losses.append(-avg_failed * 1.2 * weight)  # 약간 여유있게 설정
                else:
                    stop_losses.append(-2.0 * weight)  # 기본값
            
            # 최종 파라미터 계산
            optimized_params = {
                'profit_target': sum(profit_targets) if profit_targets else 5.0,
                'stop_loss': sum(stop_losses) if stop_losses else -2.0,
                'trailing_stop': sum(trailing_stops) if trailing_stops else 1.0
            }
        else:
            # 기본 파라미터
            optimized_params = {
                'profit_target': 5.0,
                'stop_loss': -2.0,
                'trailing_stop': 1.0
            }
        
        # 5. 최종 조언 구성
        advice = {
            'recommendation': recommendation,
            'confidence': confidence,
            'reasoning': reasoning,
            'win_rate': win_rate,
            'avg_profit': avg_profit,
            'avg_loss': avg_loss,
            'profit_expectation': expected_profit,
            'similar_patterns_count': len(completed_patterns),
            'params': optimized_params
        }
        
        return advice
    
    def store_market_pattern(self, current_indicators, price, decision, context_date=None):
        """시장 패턴을 저장하는 함수 - 성공 패턴 학습을 위해 개선됨
        
        Args:
            current_indicators: 현재 기술적 지표
            price: 현재 가격
            decision: AI 결정 ('BUY', 'SELL', 'HOLD')
            context_date: 컨텍스트 날짜 (기본값: 현재)
        """
        # 현재 시장 추세 감지
        market_trend = self.detect_market_trend(current_indicators)
        
        # 지지선 정보 추가
        if price:
            support_analysis = self._check_near_support_level_enhanced("KRW-BTC", price)
        else:
            support_analysis = {}
        
        # 현재 날짜/시간 설정
        if context_date is None:
            current_datetime = datetime.datetime.now()
        else:
            current_datetime = context_date if isinstance(context_date, datetime.datetime) else pd.to_datetime(context_date)
        
        # 패턴 ID 생성
        pattern_id = f"{current_datetime.strftime('%Y%m%d%H%M%S')}_{hash(str(current_indicators))}"
        
        # 패턴 저장 객체 생성
        new_context = {
            'pattern_id': pattern_id,
            'date': current_datetime.strftime("%Y-%m-%d"),
            'timestamp': current_datetime,
            'indicators': current_indicators,
            'price': price,
            'market_trend': market_trend,
            'support_analysis': support_analysis,
            'ai_decision': decision,
            'content': f"Market shows {market_trend} with RSI at {current_indicators.get('RSI(14)', 'N/A')}. "
                    f"MACD is {current_indicators.get('MACD', 'N/A')}. "
                    f"Bollinger Bands: {current_indicators.get('Bollinger Bands', 'N/A')}. "
                    f"Moving Averages: {current_indicators.get('Moving Averages', 'N/A')}. "
                    f"Support level nearby: {support_analysis.get('is_near_support', False)}, "
                    f"Support strength: {support_analysis.get('strength', 0):.2f}.",
            'trade_result': {
                'completed': False,
                'entry_price': price if decision == 'BUY' else None,
                'exit_price': None,
                'profit_pct': None,
                'success': None,
                'exit_reason': None,
                'holding_days': None
            },
            'pattern_metrics': {
                'success_count': 0,
                'failure_count': 0,
                'total_profit': 0,
                'avg_profit': 0,
                'success_rate': 0,
                'last_update': current_datetime.strftime("%Y-%m-%d"),
                'usage_count': 0
            }
        }
        
        # document_store 초기화 확인
        if not hasattr(self, 'document_store'):
            self.document_store = []
            
        # 중복 방지를 위한 검사
        existing_index = -1
        for i, doc in enumerate(self.document_store):
            if doc.get('pattern_id') == pattern_id:
                existing_index = i
                break
        
        if existing_index >= 0:
            # 기존 항목 업데이트
            self.document_store[existing_index] = new_context
            print(f"Pattern {pattern_id} updated in document store")
        else:
            # 새 항목 추가
            self.document_store.append(new_context)
            print(f"New pattern {pattern_id} added to document store")
        
        return pattern_id


    def manage_consecutive_losses(self, profit_pct, i):
        """
        패턴 학습용 연속 손실 관리 - 쿨다운 없음
        """
        if not hasattr(self, 'consecutive_losses'):
            self.consecutive_losses = 0
        if not hasattr(self, 'consecutive_wins'):
            self.consecutive_wins = 0
        if not hasattr(self, 'stop_loss_streak'):
            self.stop_loss_streak = 0
        if not hasattr(self, 'cooldown_until'):
            self.cooldown_until = -1  # 항상 비활성화
        if not hasattr(self, 'recovery_factor'):
            self.recovery_factor = 1.0
        
        if profit_pct > 0:
            # 수익이 발생한 경우
            self.consecutive_wins += 1
            self.consecutive_losses = max(0, self.consecutive_losses - 1)
            self.stop_loss_streak = 0
            
            # 연속 성공 시 회복 계수 점진적 증가
            if self.consecutive_wins >= 3:
                self.recovery_factor = min(1.0, self.recovery_factor + 0.1)
            
            # 패턴 학습 모드: 쿨다운 없음
            self.cooldown_until = -1
        else:
            # 손실이 발생한 경우
            self.consecutive_losses += 1
            self.consecutive_wins = 0
            
            # 손절매로 인한 손실인 경우
            if profit_pct <= -1.0:
                self.stop_loss_streak += 1
            
            # 회복 계수 감소 (하지만 쿨다운은 없음)
            self.recovery_factor = max(0.3, self.recovery_factor - 0.15)
            
            # 패턴 학습 모드: 쿨다운 없이 상태만 로깅
            if self.consecutive_losses >= 3:
                print(f"📊 패턴학습: 연속 {self.consecutive_losses}회 손실 발생 - 계속 학습 중")
            
            if self.stop_loss_streak >= 2:
                print(f"📊 패턴학습: 손절매 {self.stop_loss_streak}회 연속 발생 - 계속 학습 중")
            
            # 쿨다운은 적용하지 않음
            self.cooldown_until = -1
        
        # 현재 상태 로깅 및 반환
        status = {
            "consecutive_losses": self.consecutive_losses,
            "consecutive_wins": self.consecutive_wins,
            "stop_loss_streak": self.stop_loss_streak,
            "cooldown_until": -1,  # 항상 -1 (쿨다운 없음)
            "recovery_factor": self.recovery_factor
        }
        
        if self.consecutive_losses > 0 or self.consecutive_wins > 0:
            print(f"📊 패턴학습 상태: 연속손실={self.consecutive_losses}, 연속성공={self.consecutive_wins}, 회복계수={self.recovery_factor:.2f}")
        
        return status
    
    def set_adaptive_trailing_stop(self, price, market_trend, volatility):
        """시장 조건에 맞는 트레일링 스탑 설정 - 더 동적인 조정"""
        # 기본 트레일링 값 설정
        base_trailing = 1.0
        
        # 시장 추세에 따른 기본 조정
        if "Strong uptrend" in market_trend:
            # 강한 상승장에서는 더 넓은 트레일링 (더 많은 이익 확보)
            base_trailing = 1.2
        elif "Moderate uptrend" in market_trend or "Possible uptrend" in market_trend:
            base_trailing = 1.0
        elif "Mixed/Sideways" in market_trend:
            # 횡보장에서는 중간 수준의 트레일링
            base_trailing = 0.8
        elif "Moderate downtrend" in market_trend or "Possible downtrend" in market_trend:
            # 약한 하락장에서는 타이트한 트레일링
            base_trailing = 0.6
        elif "Strong downtrend" in market_trend:
            # 강한 하락장에서는 매우 타이트한 트레일링
            base_trailing = 0.5
        
        # 변동성에 따른 조정 - 더 세밀하게 분류
        if volatility < 0.02:  # 매우 낮은 변동성
            volatility_factor = 0.8
        elif volatility < 0.04:  # 낮은 변동성
            volatility_factor = 1.0
        elif volatility < 0.06:  # 중간 변동성
            volatility_factor = 1.2
        elif volatility < 0.08:  # 높은 변동성
            volatility_factor = 1.5
        else:  # 매우 높은 변동성
            volatility_factor = 2.0
        
        # RSI 상태에 따른 추가 조정
        try:
            # tech_indicators가 전달된 경우에만 실행
            if hasattr(self, 'tech_indicators') and self.tech_indicators:
                rsi_str = self.tech_indicators.get("RSI(14)", "50")
                rsi = float(str(rsi_str).replace(',', '')) if isinstance(rsi_str, (int, float, str)) else 50
                
                # 과매수/과매도 상태에서의 조정
                if rsi > 75:  # 과매수
                    rsi_factor = 0.7  # 타이트하게 조정
                elif rsi < 25:  # 과매도
                    rsi_factor = 1.3  # 여유롭게 조정
                else:
                    rsi_factor = 1.0  # 중립
                    
                # 최종 계산에 RSI 팩터 적용
                base_trailing *= rsi_factor
        except:
            pass  # RSI 정보가 없으면 이 조정은 건너뜀
        
        # 최종 트레일링 스탑 계산
        final_trailing = base_trailing * volatility_factor
        
        # 한계값 설정 (너무 크거나 작지 않도록)
        final_trailing = max(0.3, min(final_trailing, 3.0))
        
        # 트레일링 스탑 가격 계산
        trailing_stop_price = price * (1 - final_trailing/100)
        
        # 디버깅을 위한 정보 로깅
        if hasattr(self, 'debug_mode') and self.debug_mode:
            print(f"Adaptive Trailing Stop: {final_trailing}% (Base: {base_trailing}, Volatility Factor: {volatility_factor})")
            print(f"Price: {price}, Stop Price: {trailing_stop_price}")
        
        return trailing_stop_price
    
    def update_pattern_with_trade_result(self, pattern_id, exit_price, exit_date, exit_reason):
        """거래 결과로 패턴 정보 업데이트
        
        Args:
            pattern_id: 패턴 고유 ID
            exit_price: 매도 가격
            exit_date: 매도 날짜
            exit_reason: 매도 이유 ('PROFIT', 'STOPLOSS', 'TRAILING', 'MANUAL')
        
        Returns:
            bool: 업데이트 성공 여부
        """
        if not hasattr(self, 'document_store'):
            print("Warning: document_store not initialized")
            return False
        
        # 해당 패턴 찾기
        target_pattern = None
        pattern_index = -1
        
        for i, pattern in enumerate(self.document_store):
            if pattern.get('pattern_id') == pattern_id:
                target_pattern = pattern
                pattern_index = i
                break
        
        if target_pattern is None:
            print(f"Pattern {pattern_id} not found in document store")
            return False
        
        # 이미 완료된 거래인지 확인
        if target_pattern.get('trade_result', {}).get('completed', False):
            print(f"Trade for pattern {pattern_id} already completed")
            return False
        
        # 진입 가격 확인
        entry_price = target_pattern['trade_result'].get('entry_price')
        if entry_price is None:
            print(f"No entry price for pattern {pattern_id}")
            entry_price = target_pattern['price']  # 패턴 저장 시 가격 사용
        
        # 결과 계산
        if entry_price > 0 and exit_price > 0:
            profit_pct = ((exit_price / entry_price) - 1) * 100
            success = profit_pct > 0
            
            # 거래 결과 업데이트
            target_pattern['trade_result'].update({
                'completed': True,
                'exit_price': exit_price,
                'profit_pct': profit_pct,
                'success': success,
                'exit_reason': exit_reason,
                'exit_date': exit_date.strftime("%Y-%m-%d") if isinstance(exit_date, datetime.datetime) else str(exit_date),
                'holding_days': self.calculate_holding_days(target_pattern['date'], str(exit_date))
            })
            
            # 패턴 메트릭 업데이트
            target_pattern['pattern_metrics'].update({
                'success_count': target_pattern['pattern_metrics']['success_count'] + (1 if success else 0),
                'failure_count': target_pattern['pattern_metrics']['failure_count'] + (0 if success else 1),
                'total_profit': target_pattern['pattern_metrics']['total_profit'] + profit_pct,
                'last_update': datetime.datetime.now().strftime("%Y-%m-%d")
            })
            
            # 평균 수익 및 성공률 재계산
            total_trades = target_pattern['pattern_metrics']['success_count'] + target_pattern['pattern_metrics']['failure_count']
            if total_trades > 0:
                target_pattern['pattern_metrics']['avg_profit'] = target_pattern['pattern_metrics']['total_profit'] / total_trades
                target_pattern['pattern_metrics']['success_rate'] = target_pattern['pattern_metrics']['success_count'] / total_trades * 100
            
            # 문서 저장소 업데이트
            self.document_store[pattern_index] = target_pattern
            print(f"Pattern {pattern_id} updated with trade result: profit={profit_pct:.2f}%, success={success}")
            
            # RAG 데이터 저장
            try:
                import pickle
                import gzip
                with gzip.open('rag_pattern_store.pkl.gz', 'wb') as f:
                    pickle.dump(self.document_store, f)
                print("RAG pattern store saved to compressed file")
            except Exception as e:
                print(f"Failed to save RAG pattern store: {str(e)}")
            
            return True
        else:
            print(f"Invalid prices for pattern {pattern_id}")
            return False

    def save_rag_patterns(self, file_path="rag_pattern_store.pkl.gz"):
        """RAG 패턴 데이터를 압축하여 저장
        
        Args:
            file_path: 저장할 파일 경로
        
        Returns:
            bool: 저장 성공 여부
        """
        if not hasattr(self, 'document_store') or not self.document_store:
            print("Warning: No patterns to save")
            return False
        
        try:
            import pickle
            import gzip
            with gzip.open(file_path, 'wb') as f:
                pickle.dump(self.document_store, f)
            print(f"Successfully saved {len(self.document_store)} patterns to {file_path}")
            return True
        except Exception as e:
            print(f"Error saving RAG patterns: {str(e)}")
            return False

    def load_rag_patterns(self, file_path="rag_pattern_store.pkl.gz"):
        """저장된 RAG 패턴 데이터 로드
        
        Args:
            file_path: 로드할 파일 경로
        
        Returns:
            bool: 로드 성공 여부
        """
        try:
            import pickle
            import gzip
            import os
            
            if not os.path.exists(file_path):
                print(f"RAG pattern file {file_path} not found")
                return False
            
            with gzip.open(file_path, 'rb') as f:
                self.document_store = pickle.load(f)
            
            print(f"Successfully loaded {len(self.document_store)} patterns from {file_path}")
            
            # 패턴 통계 출력
            completed_patterns = [p for p in self.document_store if p.get('trade_result', {}).get('completed', False)]
            successful_patterns = [p for p in completed_patterns if p.get('trade_result', {}).get('success', False)]
            
            if completed_patterns:
                win_rate = len(successful_patterns) / len(completed_patterns) * 100
                print(f"Pattern stats: {len(completed_patterns)} completed trades, {win_rate:.1f}% win rate")
                
                # 가장 성공적인 패턴 정보
                if successful_patterns:
                    best_pattern = max(successful_patterns, key=lambda p: p.get('trade_result', {}).get('profit_pct', 0))
                    best_profit = best_pattern.get('trade_result', {}).get('profit_pct', 0)
                    print(f"Best pattern: {best_profit:.2f}% profit on {best_pattern.get('date', 'unknown date')}")
            
            return True
        except Exception as e:
            print(f"Error loading RAG patterns: {str(e)}")
            return False

    def calculate_volatility(self, data, period=5):
        """변동성 계산 - 다양한 데이터 형식 처리 및 오류 처리 개선"""
        # 데이터가 없는 경우 처리
        if data is None:
            return 0.05  # 기본값
        
        try:
            # pandas DataFrame인 경우
            if isinstance(data, pd.DataFrame):
                if data.empty or len(data) < period:
                    return 0.05
                
                # 'close' 키가 있는지 확인
                if 'close' not in data.columns:
                    # 가능한 대체 칼럼 찾기
                    possible_columns = ['Close', 'price', 'Price']
                    for col in possible_columns:
                        if col in data.columns:
                            prices = data[col].tolist()
                            break
                    else:
                        # 대체 칼럼도 없는 경우
                        return 0.05
                else:
                    # Close 가격 사용
                    prices = data['close'].tolist()
            
            # 리스트나 딕셔너리 리스트인 경우 (backtest_results)
            elif isinstance(data, list):
                if not data or len(data) < period:
                    return 0.05
                
                # 가격 추출 시도
                try:
                    # 딕셔너리 리스트인 경우
                    if isinstance(data[0], dict):
                        # 가능한 가격 키 목록
                        price_keys = ['price', 'close', 'Close', 'closing_price']
                        
                        # 존재하는 키 사용
                        for key in price_keys:
                            if key in data[0]:
                                prices = [float(str(item[key]).replace(',', '')) for item in data]
                                break
                        else:
                            # 적합한 키를 찾지 못한 경우
                            return 0.05
                    else:
                        # 숫자 리스트로 가정
                        prices = [float(str(item).replace(',', '')) if isinstance(item, (int, float, str)) else 0 for item in data]
                except (TypeError, ValueError, KeyError):
                    return 0.05
            else:
                return 0.05  # 알 수 없는 데이터 형식
            
            # 모든 숫자를 float로 변환 확인
            clean_prices = []
            for p in prices:
                try:
                    if isinstance(p, str):
                        clean_prices.append(float(p.replace(',', '')))
                    else:
                        clean_prices.append(float(p))
                except (ValueError, TypeError):
                    # 잘못된 값은 제외
                    continue
                    
            # 충분한 데이터가 없는 경우
            if len(clean_prices) < period:
                return 0.05
                
            # 가격 변화율 계산
            returns = []
            for i in range(1, len(clean_prices)):
                if clean_prices[i-1] > 0:  # 0으로 나누기 방지
                    ret = (clean_prices[i] / clean_prices[i-1]) - 1
                    returns.append(ret)
            
            if not returns:
                return 0.05
            
            # 최근 period 기간의 표준편차 계산
            recent_returns = returns[-period:] if len(returns) >= period else returns
            volatility = np.std(recent_returns) * (252**0.5)  # 연환산
            
            return volatility if volatility > 0 else 0.05
            
        except Exception as e:
            if hasattr(self, 'debug_mode') and self.debug_mode:
                print(f"Error calculating volatility: {str(e)}")
            return 0.05  # 오류 시 기본값 반환


    def analyze_news_sentiment(self, news_data):
        """
        뉴스 감성 분석 - 키워드 및 감성 점수 추출
        
        Args:
            news_data: 뉴스 데이터 목록
            
        Returns:
            dict: 감성 분석 결과
        """
        if not news_data or len(news_data) == 0:
            return {"sentiment_score": 0, "key_topics": [], "impact_level": "neutral"}
        
        # 긍정/부정 키워드 사전
        bullish_keywords = ['bullish', 'surge', 'rally', 'breakout', 'adoption', 'institutional', 'upgrade', 
                            'growth', 'positive', 'uptrend', 'support', 'partnership', 'development']
        bearish_keywords = ['bearish', 'crash', 'ban', 'regulation', 'hack', 'exploit', 'downgrade', 
                            'restriction', 'crackdown', 'sell-off', 'bearish', 'resistance', 'negative']
        
        # 감성 점수 계산
        sentiment_score = 0
        key_topics = []
        
        for news in news_data:
            title = news.get('title', '').lower()
            description = news.get('description', '').lower()
            content = title + " " + description
            
            # 긍정/부정 키워드 확인
            bull_count = sum(1 for word in bullish_keywords if word in content)
            bear_count = sum(1 for word in bearish_keywords if word in content)
            
            # 개별 뉴스 점수 계산 (범위: -1.0 ~ 1.0)
            news_score = 0
            if bull_count + bear_count > 0:
                news_score = (bull_count - bear_count) / max(1, bull_count + bear_count)
            sentiment_score += news_score
            
            # 주요 토픽 추출
            if 'regulation' in content or 'compliance' in content or 'legal' in content:
                key_topics.append('regulation')
            if 'adoption' in content or 'institutional' in content or 'invest' in content:
                key_topics.append('adoption')
            if 'technology' in content or 'upgrade' in content or 'development' in content:
                key_topics.append('technology')
            if 'market' in content or 'trading' in content or 'volume' in content:
                key_topics.append('market')
            if 'hack' in content or 'security' in content or 'breach' in content:
                key_topics.append('security')
        
        # 전체 감성 점수 정규화
        if len(news_data) > 0:
            sentiment_score = sentiment_score / len(news_data)
        
        # 영향도 판단
        if abs(sentiment_score) < 0.2:
            impact_level = "low"
        elif abs(sentiment_score) < 0.5:
            impact_level = "medium"
        else:
            impact_level = "high"
            
        return {
            "sentiment_score": sentiment_score,
            "key_topics": list(set(key_topics)),
            "impact_level": impact_level,
            "news_count": len(news_data)
        }
    


    def optimize_parameters(self, data, parameter_ranges):
        """파라미터 최적화 - 수익률 극대화를 위한 그리드 서치"""
        best_profit = -float('inf')
        best_params = {}
        results = []
        
        # 파라미터 조합 생성
        param_combinations = []
        for profit_target in parameter_ranges['profit_target']:
            for stop_loss in parameter_ranges['stop_loss']:
                for trailing_stop in parameter_ranges['trailing_stop']:
                    for rsi_threshold in parameter_ranges['rsi_threshold']:
                        param_combinations.append({
                            'profit_target': profit_target,
                            'stop_loss': stop_loss,
                            'trailing_stop': trailing_stop,
                            'rsi_threshold': rsi_threshold
                        })
        
        print(f"총 {len(param_combinations)}개 파라미터 조합으로 최적화 시작...")
        
        # 각 파라미터 조합으로 백테스트 실행
        for params in tqdm(param_combinations):
            # 파라미터 설정
            self.default_profit_target = params['profit_target']
            self.default_stop_loss = params['stop_loss']
            self.default_trailing_stop = params['trailing_stop']
            self.rsi_threshold = params['rsi_threshold']
            
            # 백테스트 실행
            backtest_results = self.run_backtest(
                data, 
                test_mode=False, 
                llm_mode=True,
                initial_position=False
            )
            
            # 백테스트 결과 평가
            evaluation = self.evaluate_backtest(backtest_results)
            
            # 결과 저장
            result = {
                'parameters': params.copy(),
                'total_return': evaluation['total_return_pct'],
                'max_drawdown': evaluation['max_drawdown_pct'],
                'win_rate': evaluation['win_rate'],
                'trade_count': evaluation['trade_count'],
                'sharpe_ratio': evaluation.get('sharpe_ratio', 0)
            }
            results.append(result)
            
            # 최고 수익률 업데이트
            if result['total_return'] > best_profit:
                best_profit = result['total_return']
                best_params = params.copy()
                print(f"새로운 최적 파라미터 발견: {best_params}, 수익률: {best_profit:.2f}%")
        
        # 결과 저장
        try:
            with open(f"backtest_results/optimization_results.json", 'w', encoding='utf-8') as f:
                json.dump({
                    'best_params': best_params,
                    'best_profit': best_profit,
                    'all_results': results
                }, f, indent=2)
            print(f"최적화 결과 저장 완료: backtest_results/optimization_results.json")
        except Exception as e:
            print(f"최적화 결과 저장 실패: {str(e)}")
        
        return best_params, results



    def identify_profitable_patterns(self, backtest_results):
        """수익성 높은 트레이딩 패턴 식별"""
        profitable_patterns = []
        
        # 수익성 있는 거래 필터링
        profitable_trades = []
        current_position = None
        
        for i, day in enumerate(backtest_results):
            # 매수 포지션 시작
            if day.get('actual_decision') == 'BUY':
                current_position = {
                    'entry_date': day.get('date'),
                    'entry_price': day.get('price'),
                    'tech_indicators': day.get('technical_indicators', {}).copy() if day.get('technical_indicators') else {},
                    'news_sentiment': day.get('news_sentiment', {}),
                    'market_trend': day.get('market_trend', 'Unknown')
                }
            
            # 매도로 포지션 종료
            elif day.get('actual_decision') in ['SELL', 'SELL_PROFIT', 'SELL_TRAILING', 'SELL_STOPLOSS'] and current_position:
                profit_pct = ((day.get('price', 0) / current_position['entry_price']) - 1) * 100
                
                # 수익이 났다면 패턴 분석
                if profit_pct > 3.0:  # 3% 이상 수익
                    trade_info = {
                        'entry_date': current_position['entry_date'],
                        'exit_date': day.get('date'),
                        'profit_pct': profit_pct,
                        'holding_days': self.calculate_holding_days(current_position['entry_date'], day.get('date')),
                        'entry_indicators': current_position['tech_indicators'],
                        'exit_indicators': day.get('technical_indicators', {}),
                        'entry_news': current_position.get('news_sentiment', {}),
                        'market_trend': current_position['market_trend']
                    }
                    profitable_trades.append(trade_info)
                
                current_position = None
        
        # 패턴 분석 - 기술적 지표 패턴
        pattern_clusters = {}
        
        for trade in profitable_trades:
            # RSI 범위 그룹화
            rsi_entry = 0
            try:
                rsi_entry = float(str(trade['entry_indicators'].get('RSI(14)', 50)).replace(',', ''))
            except:
                rsi_entry = 50
                
            rsi_group = "low" if rsi_entry < 30 else "high" if rsi_entry > 70 else "medium"
            
            # 시장 추세 그룹화
            trend = trade['market_trend']
            
            # 뉴스 감성 그룹화
            news_sentiment = "positive" if trade.get('entry_news', {}).get('sentiment_score', 0) > 0.2 else \
                            "negative" if trade.get('entry_news', {}).get('sentiment_score', 0) < -0.2 else "neutral"
            
            # 패턴 키 생성
            pattern_key = f"{rsi_group}_{trend}_{news_sentiment}"
            
            if pattern_key not in pattern_clusters:
                pattern_clusters[pattern_key] = {
                    'trades': [],
                    'avg_profit': 0,
                    'trade_count': 0,
                    'description': f"RSI: {rsi_group}, 시장 추세: {trend}, 뉴스 감성: {news_sentiment}"
                }
            
            pattern_clusters[pattern_key]['trades'].append(trade)
            pattern_clusters[pattern_key]['trade_count'] += 1
        
        # 각 패턴 그룹의 평균 수익률 계산
        for key, cluster in pattern_clusters.items():
            if cluster['trade_count'] > 0:
                total_profit = sum(trade['profit_pct'] for trade in cluster['trades'])
                cluster['avg_profit'] = total_profit / cluster['trade_count']
                
                # 3% 이상의 평균 수익률을 가진 패턴만 선택
                if cluster['avg_profit'] >= 3.0 and cluster['trade_count'] >= 3:
                    profitable_patterns.append({
                        'pattern': key,
                        'description': cluster['description'],
                        'avg_profit': cluster['avg_profit'],
                        'trade_count': cluster['trade_count']
                    })
        
        # 수익률 기준 내림차순 정렬
        profitable_patterns.sort(key=lambda x: x['avg_profit'], reverse=True)
        
        # 패턴 분석 결과 저장
        try:
            with open(f"backtest_results/profitable_patterns.json", 'w', encoding='utf-8') as f:
                json.dump(profitable_patterns, f, indent=2)
            print(f"수익성 패턴 분석 저장 완료: backtest_results/profitable_patterns.json")
        except Exception as e:
            print(f"수익성 패턴 분석 저장 실패: {str(e)}")
        
        return profitable_patterns



    def format_support_info(self, support_analysis):
        """지지선 정보를 깔끔하게 포맷팅"""
        is_near = support_analysis.get('is_near_support', False)
        closest = support_analysis.get('closest_support')
        distance = support_analysis.get('distance_percent')
        strength = support_analysis.get('strength', 0)
        nearby_count = support_analysis.get('nearby_supports_count', 0)
        
        # 안전한 포맷팅
        closest_str = f"₩{closest:,.0f} KRW" if closest is not None else "N/A"
        distance_str = f"{distance:.2f}%" if distance is not None else "N/A"
        
        return f"""
    Support Level Analysis:
    - Is near support: {is_near}
    - Closest support: {closest_str}
    - Distance: {distance_str}
    - Support strength: {strength:.2f}
    - Nearby supports: {nearby_count}

    """


    def __del__(self):
        """
        객체 소멸 시 셀레니움 드라이버 종료 및 파서 캐시 정리
        """
        if self.selenium_driver is not None:
            try:
                self.selenium_driver.quit()
                print("Selenium driver closed")
            except:
                pass
        
        # 파서 캐시 정리 (추가)
        if hasattr(self, 'trading_parser') and self.trading_parser:
            try:
                self.trading_parser.clear_cache()
                print("Trading parser cache cleared")
            except:
                pass


    def _parse_response_basic(self, response_text):
        """파서가 실패하거나 없을 때 사용하는 기본 파싱 로직"""
        decision = "HOLD"
        profit_target = 5.0
        stop_loss = -2.0
        trailing_stop = 1.0
        confidence = 0.5
        confidence_text = "MEDIUM"
        reasoning = ""
        
        # 정규식 기반 기본 파싱
        import re
        
        # 결정 추출
        decision_patterns = [
            r'recommend\s+a?\s*(BUY|SELL|HOLD)', 
            r'I\s+recommend\s+(BUY|SELL|HOLD)',
            r'(?:signal|decision).*?(BUY|SELL|HOLD)'
        ]
        
        for pattern in decision_patterns:
            match = re.search(pattern, response_text, re.IGNORECASE)
            if match:
                decision = match.group(1).upper()
                break
        
        # 백분율 추출
        profit_matches = re.findall(r'(?:profit|target).*?(\d+\.?\d*)\%', response_text, re.IGNORECASE)
        if profit_matches:
            try:
                profit_target = float(profit_matches[0])
            except:
                pass
        
        stop_matches = re.findall(r'(?:stop|loss).*?-?(\d+\.?\d*)\%', response_text, re.IGNORECASE)
        if stop_matches:
            try:
                stop_loss = -abs(float(stop_matches[0]))
            except:
                pass
        
        trail_matches = re.findall(r'(?:trailing|trail).*?(\d+\.?\d*)\%', response_text, re.IGNORECASE)
        if trail_matches:
            try:
                trailing_stop = float(trail_matches[0])
            except:
                pass
        
        # 간단한 추론 생성
        reasoning = f"Market analysis completed. {decision} decision based on technical indicators."
        
        return decision, profit_target, stop_loss, trailing_stop, confidence, confidence_text, reasoning
    

    def calculate_atr(self, period=14):
        """ATR (Average True Range) 계산"""
        try:
            if not hasattr(self, 'historical_data') or len(self.historical_data) < period + 1:
                return 0.05  # 기본값
            
            # 최근 데이터에서 TR(True Range) 계산
            recent_data = self.historical_data[-(period + 1):]
            true_ranges = []
            
            for i in range(1, len(recent_data)):
                high = recent_data[i].get('high', recent_data[i].get('close', 0))
                low = recent_data[i].get('low', recent_data[i].get('close', 0))
                prev_close = recent_data[i-1].get('close', 0)
                
                if high > 0 and low > 0 and prev_close > 0:
                    tr1 = high - low
                    tr2 = abs(high - prev_close)
                    tr3 = abs(low - prev_close)
                    true_range = max(tr1, tr2, tr3)
                    true_ranges.append(true_range)
            
            if not true_ranges:
                return 0.05
            
            # ATR = TR들의 평균
            atr = sum(true_ranges) / len(true_ranges)
            return atr
            
        except Exception as e:
            print(f"ATR 계산 오류: {str(e)}")
            return 0.05
        
    def calculate_bollinger_band_position(self, current_price, period=20):
        """볼린저 밴드 상대적 위치 계산"""
        try:
            if not hasattr(self, 'historical_data') or len(self.historical_data) < period:
                return 0.5, 0, 0  # 중간 위치, 상단, 하단
            
            # 최근 기간의 종가들
            recent_closes = []
            for data in self.historical_data[-period:]:
                close = data.get('close', data.get('price', 0))
                if close > 0:
                    recent_closes.append(close)
            
            if len(recent_closes) < period:
                return 0.5, 0, 0
            
            # 볼린저 밴드 계산
            import numpy as np
            closes = np.array(recent_closes)
            sma = np.mean(closes)
            std = np.std(closes)
            
            upper_band = sma + (std * 2)
            lower_band = sma - (std * 2)
            
            # 현재 가격의 밴드 내 위치 (0=하단, 0.5=중간, 1=상단)
            if upper_band > lower_band:
                bb_position = (current_price - lower_band) / (upper_band - lower_band)
            else:
                bb_position = 0.5
            
            return bb_position, upper_band, lower_band
            
        except Exception as e:
            print(f"볼린저 밴드 계산 오류: {str(e)}")
            return 0.5, 0, 0


    def calculate_volume_surge(self, current_volume, period=10):
        """거래량 급증 여부 계산"""
        try:
            if not hasattr(self, 'historical_data') or len(self.historical_data) < period:
                return 1.0  # 기본값
            
            # 최근 거래량들
            recent_volumes = []
            for data in self.historical_data[-period:]:
                volume = data.get('volume', 0)
                if volume > 0:
                    recent_volumes.append(volume)
            
            if not recent_volumes or current_volume <= 0:
                return 1.0
            
            avg_volume = sum(recent_volumes) / len(recent_volumes)
            volume_ratio = current_volume / avg_volume if avg_volume > 0 else 1.0
            
            return volume_ratio
            
        except Exception as e:
            print(f"거래량 분석 오류: {str(e)}")
            return 1.0
        

    def calculate_price_momentum(self, current_price, period=5):
        """최근 가격 모멘텀 계산"""
        try:
            if not hasattr(self, 'historical_data') or len(self.historical_data) < period:
                return 0.0
            
            # 최근 가격들
            recent_prices = []
            for data in self.historical_data[-period:]:
                price = data.get('close', data.get('price', 0))
                if price > 0:
                    recent_prices.append(price)
            
            if len(recent_prices) < 2:
                return 0.0
            
            # 가격 변화율 계산
            price_changes = []
            for i in range(1, len(recent_prices)):
                change = (recent_prices[i] / recent_prices[i-1] - 1) * 100
                price_changes.append(change)
            
            if not price_changes:
                return 0.0
            
            # 평균 모멘텀
            momentum = sum(price_changes) / len(price_changes)
            return momentum
            
        except Exception as e:
            print(f"모멘텀 계산 오류: {str(e)}")
            return 0.0
        

    def check_volatility_breakout_trigger(self, current_price, timestamp, current_volume=0):
        """
        변동성 돌파 기반 트리거 체크 (기존 check_support_trigger 대체)
        
        Returns:
            bool: 변동성 돌파 트리거 발생 시 True
        """
        try:
            if not hasattr(self, 'historical_data') or len(self.historical_data) < 20:
                return False
            
            print(f"🔍 변동성 돌파 분석 중: {timestamp}")
            
            # 1. ATR 기반 변동성 체크
            current_atr = self.calculate_atr(14)
            baseline_atr = self.calculate_atr(30)  # 더 긴 기간의 기준선
            
            atr_ratio = current_atr / baseline_atr if baseline_atr > 0 else 1.0
            
            # 2. 볼린저 밴드 위치 체크
            bb_position, upper_band, lower_band = self.calculate_bollinger_band_position(current_price)
            
            # 3. 거래량 급증 체크
            volume_ratio = self.calculate_volume_surge(current_volume)
            
            # 4. 가격 모멘텀 체크
            momentum = self.calculate_price_momentum(current_price)
            
            # 5. 변동성 압축 체크 (볼린저 밴드 폭)
            bb_width = (upper_band - lower_band) / current_price * 100 if current_price > 0 else 0
            
            # 트리거 조건들
            triggers = []
            trigger_score = 0
            
            # 조건 1: ATR 급증 (가장 강한 신호)
            if atr_ratio >= 2.0:
                triggers.append(f"ATR 급증 {atr_ratio:.2f}x")
                trigger_score += 3
            elif atr_ratio >= 1.5:
                triggers.append(f"ATR 상승 {atr_ratio:.2f}x")
                trigger_score += 2
            
            # 조건 2: 볼린저 밴드 돌파
            if bb_position >= 1.02:  # 상단 돌파
                triggers.append(f"볼린저 상단 돌파 ({bb_position:.2f})")
                trigger_score += 2
            elif bb_position <= -0.02:  # 하단 돌파
                triggers.append(f"볼린저 하단 돌파 ({bb_position:.2f})")
                trigger_score += 2
            elif bb_position >= 0.95:  # 상단 근접
                triggers.append(f"볼린저 상단 근접 ({bb_position:.2f})")
                trigger_score += 1
            elif bb_position <= 0.05:  # 하단 근접
                triggers.append(f"볼린저 하단 근접 ({bb_position:.2f})")
                trigger_score += 1
            
            # 조건 3: 거래량 급증
            if volume_ratio >= 3.0:
                triggers.append(f"거래량 급증 {volume_ratio:.1f}x")
                trigger_score += 2
            elif volume_ratio >= 2.0:
                triggers.append(f"거래량 증가 {volume_ratio:.1f}x")
                trigger_score += 1
            
            # 조건 4: 가격 모멘텀
            if abs(momentum) >= 3.0:
                direction = "상승" if momentum > 0 else "하락"
                triggers.append(f"강한 {direction} 모멘텀 {momentum:+.1f}%")
                trigger_score += 2
            elif abs(momentum) >= 1.5:
                direction = "상승" if momentum > 0 else "하락"
                triggers.append(f"{direction} 모멘텀 {momentum:+.1f}%")
                trigger_score += 1
            
            # 조건 5: 변동성 압축 후 확장
            if bb_width < 2.0 and atr_ratio > 1.2:  # 압축 후 확장
                triggers.append(f"변동성 압축→확장 (폭:{bb_width:.1f}%)")
                trigger_score += 2
            
            # 최종 트리거 판단 (기존과 비슷한 빈도 유지)
            trigger_threshold = 2  # 2점 이상이면 트리거
            is_triggered = trigger_score >= trigger_threshold
            
            if is_triggered:
                print(f"🎯 [변동성 돌파 트리거] 점수: {trigger_score}점")
                print(f"  📊 세부 조건: {', '.join(triggers)}")
                print(f"  📈 ATR 비율: {atr_ratio:.2f}x")
                print(f"  🎪 볼린저 위치: {bb_position:.2f}")
                print(f"  📢 거래량 비율: {volume_ratio:.1f}x")
                print(f"  🚀 모멘텀: {momentum:+.1f}%")
            else:
                # 5% 확률로 낮은 점수도 로깅 (디버깅용)
                if trigger_score > 0 and hash(str(timestamp)) % 20 == 0:
                    print(f"📊 변동성 분석: {trigger_score}점 (임계값 미달)")
                    print(f"  조건: {', '.join(triggers) if triggers else '없음'}")
            
            return is_triggered
            
        except Exception as e:
            print(f"변동성 돌파 분석 오류: {str(e)}")
            return False

    def get_volatility_context_for_ai(self, current_price, current_volume=0):
        """AI 분석용 변동성 컨텍스트 생성"""
        try:
            atr_ratio = self.calculate_atr(14) / max(self.calculate_atr(30), 0.001)
            bb_position, upper_band, lower_band = self.calculate_bollinger_band_position(current_price)
            volume_ratio = self.calculate_volume_surge(current_volume)
            momentum = self.calculate_price_momentum(current_price)
            
            context = f"""
    Volatility Analysis Results:
    - ATR change: {atr_ratio:.2f}x (relative to baseline)
    - Bollinger band position: {bb_position:.2f} (0=bottom, 1=top)
    - Top band: ₩{upper_band:.0f}, Bottom band: ₩{lower_band:,.0f}
    - Trading volume change: {volume_ratio:.1f}x (compared to average)
    - Price Momentum: {momentum:+.1f}% (last five-day average)

    Variability Interpretation:
    """

            if atr_ratio >= 2.0:
                context += "- Very high volatility: significant market changes in progress\n"
            elif atr_ratio >= 1.5:
                context += "- high volatility: market movement active\n"
            elif atr_ratio <= 0.7:
                context += "- low volatility: market stability or compression\n"

            if bb_position >= 1.0:
                context += "- Bollinger band top break: strong upward pressure\n"
            elif bb_position <= 0.0:
                context += "- Breaking the bottom of the bolinger band: strong downward pressure\n"
            elif bb_position >= 0.8:
                context += "- close to the top of the bolinger band: likely overbought\n"
            elif bb_position <= 0.2:
                context += "- close to the bottom of the bolinger band: likely oversold\n"

            if volume_ratio >= 3.0:
                context += "- Volume Surge: Strong Market Interest\n"
            elif volume_ratio >= 2.0:
                context += "- Trading volume increase: market activation\n"
            elif volume_ratio <= 0.5:
                context += "- volume decline: market interest also low\n"

            return context
            
        except Exception as e:
            return f"변동성 컨텍스트 생성 오류: {str(e)}"


    def summarize_news_with_ai(self, news_context):
        """Step 1: Detailed news analysis and summarization"""
        if not news_context or not news_context.get('top_news'):
            print("📰 NEWS ANALYSIS: No significant news")
            return "No significant news impact on market"
        
        print("📰 NEWS ANALYSIS STAGE 1...")
        print(f"  - Processing {len(news_context['top_news'])} news articles")
        print(f"  - Overall Sentiment: {news_context.get('sentiment_summary', 'neutral')}")
        print(f"  - Total News Count: {news_context.get('news_count', 0)}")
        
        system_msg = """You are a Bitcoin news analyst. Provide comprehensive news impact analysis including:
    1. Overall market sentiment from news
    2. Key developments and their potential impact
    3. Short-term and medium-term implications
    4. Risk factors from news

    Create a detailed 2-3 sentence analysis focusing on market-moving factors."""
        
        # 뉴스 상세 정보 구성
        news_details = []
        for i, news in enumerate(news_context['top_news'][:5]):
            sentiment_score = news.get('sentiment', 0)
            predicted_impact = news.get('predicted_impact', {})
            
            news_details.append(f"{i+1}. {news['title'][:100]}")
            news_details.append(f"   Sentiment: {sentiment_score:.2f}, Impact: {predicted_impact.get('direction', 'neutral')}")
        
        user_msg = f"""Bitcoin News Analysis:

    NEWS ARTICLES:
    {chr(10).join(news_details)}

    AGGREGATE DATA:
    - Overall Sentiment: {news_context.get('sentiment_summary', 'neutral')}
    - Sentiment Score: {news_context.get('overall_sentiment', 0):.2f}
    - News Count: {news_context.get('news_count', 0)}
    - Key Themes: {', '.join(news_context.get('top_news', [{}])[0].get('themes', []))}

    Provide comprehensive market impact analysis:"""
        
        try:
            response = self.llm(f"{system_msg}\n\n{user_msg}", max_tokens=150, temperature=0.3)
            summary = response["choices"][0]["text"].strip()
            
            print("📰 DETAILED NEWS ANALYSIS:")
            print(f"  ├─ Raw sentiment: {news_context.get('sentiment_summary', 'neutral')}")
            print(f"  ├─ Sentiment Score: {news_context.get('overall_sentiment', 0):.2f}")
            print(f"  └─ AI Analysis: {summary}")
            print()
            
            return summary
        except Exception as e:
            print(f"  ⚠️  News analysis error: {str(e)}")
            return f"News sentiment: {news_context.get('sentiment_summary', 'neutral')} with {news_context.get('news_count', 0)} articles"
    

    def _apply_dynamic_parameters_for_backtest(self, profit_target, stop_loss, trailing_stop, confluence_signals, market_regime, analysis_context):
        """백테스트 모드용 동적 파라미터 조정 함수"""
        # 기본 파라미터 조정 (일반 적용 파라미터 조정)
        profit_target, stop_loss, trailing_stop = self._apply_dynamic_parameters(
            profit_target, stop_loss, trailing_stop, confluence_signals, market_regime, {}
        )
        
        # 백테스트 특화 조정 (필요시 추가 조정)
        # 예: 백테스트에서는 좀 더 보수적인 설정 적용
        
        # 매우 오래된 데이터인 경우 (2021년 이전)
        current_date = analysis_context.get('current_date', '')
        if current_date and '2020' in current_date:
            # 2020년 이전 데이터는 변동성이 달랐으므로 조정
            profit_target = max(3.0, profit_target * 0.9)  # 수익 타겟 약간 감소
            stop_loss = min(-1.0, stop_loss * 0.9)  # 손절 범위 감소 (덜 공격적)
        
        # 특정 시장 환경에 따른 추가 조정
        regime = market_regime.get('regime', '')
        if 'HIGH_VOLATILITY' in regime:
            # 고변동성 환경에서는 트레일링 스탑 강화
            trailing_stop = min(2.0, trailing_stop * 1.2)
        
        return profit_target, stop_loss, trailing_stop


    def comprehensive_analysis_with_ai_with_context(self, coin, price, tech_indicators, news_summary, support_analysis, analysis_context):
        """컨텍스트 정보와 패턴 분석을 포함한 종합 분석 함수"""
        
        print("🔍 COMPREHENSIVE ANALYSIS STAGE 2 WITH CONTEXT...")
        print(f"  - Current Price: ₩{price:,}")
        print(f"  - Support Strength: {support_analysis.get('strength', 0):.2f}")
        print(f"  - Context Date: {analysis_context.get('current_date', 'N/A')}")
        
        # 유사 패턴 검색 및 패턴 기반 조언 생성
        similar_patterns = self.find_similar_patterns(tech_indicators, success_weight=True, time_decay=True)
        pattern_advice = self.get_pattern_based_advice(similar_patterns)
        
        # ↓ 과거 뉴스 사례 추가
        historical_news_cases = self._get_historical_news_cases(similar_patterns)



        print(f"Pattern-based advice: {pattern_advice['recommendation']} (confidence: {pattern_advice['confidence']:.2f})")
        print(f"Expected profit: {pattern_advice['profit_expectation']:.2f}%, Win rate: {pattern_advice.get('win_rate', 0):.0%}")
        
        system_msg = """You are the world's best Bitcoin trader. Provide comprehensive analysis using ALL provided data.
        Pay special attention to PATTERN-BASED ADVICE which contains historical performance of similar market conditions.
        End with specific trading recommendation in this format:

        DECISION: BUY/SELL/HOLD
        PROFIT_TARGET: X%
        STOP_LOSS: -X% 
        TRAILING_STOP: X%
        CONFIDENCE: 0.X"""
        
        # 기술적 지표 및 기타 분석 기존 유지...
        rsi = tech_indicators.get('RSI(14)', 'N/A')
        macd = tech_indicators.get('MACD', 'N/A')
        bb = tech_indicators.get('Bollinger Bands', 'N/A')
        ma = tech_indicators.get('Moving Averages', 'N/A')
        volume = tech_indicators.get('Volume', 'N/A')
        volatility = tech_indicators.get('Volatility', 'N/A')
        
        # 기존 함수들 호출
        market_trend = self.detect_market_trend(tech_indicators)
        news_sentiment = self.analyze_news_sentiment([])  # 빈 리스트로 호출
        
        # Confluence 점수 계산
        confluence_signals = self._calculate_confluence_score(tech_indicators, news_sentiment, support_analysis, market_trend)
        
        # 시장 환경 분석
        market_regime = self._detect_market_regime(tech_indicators, self.get_recent_market_context())
        
        # 거래량-가격 관계
        volume_analysis = self._analyze_volume_price_relationship(tech_indicators, price)
        
        # 리스크 메트릭
        risk_metrics = self._calculate_dynamic_risk_metrics(confluence_signals, market_regime, volume_analysis)
        
        # 최적 리스크-리워드
        optimal_rr = self._calculate_optimal_risk_reward(price, support_analysis, market_regime)

        # 변동성 컨텍스트 추가 (기존 user_msg에 추가)
        volatility_context = analysis_context.get('volatility_context', '')
        
        # 지지선 상세 정보
        support_strength = support_analysis.get('strength', 0)
        support_distance = support_analysis.get('distance_percent', 0)
        is_near_support = support_analysis.get('is_near_support', False)
        closest_support = support_analysis.get('closest_support', 0)
        
        # 패턴 분석 요약 구성
        pattern_summary = "No similar patterns found"
        if similar_patterns:
            completed_patterns = [p for p in similar_patterns if p.get('trade_result', {}).get('completed', False)]
            if completed_patterns:
                successful = [p for p in completed_patterns if p.get('trade_result', {}).get('success', False)]
                win_rate = len(successful) / len(completed_patterns) if completed_patterns else 0
                
                pattern_summary = f"Found {len(completed_patterns)} similar historical patterns with {win_rate:.0%} win rate. "
                pattern_summary += f"Expected profit: {pattern_advice['profit_expectation']:.2f}%. "
                pattern_summary += f"Pattern-based recommendation: {pattern_advice['recommendation']} "
                pattern_summary += f"(confidence: {pattern_advice['confidence']:.2f})"
                
                # 상위 패턴 세부 정보 추가
                if successful:
                    best_pattern = max(successful, key=lambda p: p.get('trade_result', {}).get('profit_pct', 0))
                    best_profit = best_pattern.get('trade_result', {}).get('profit_pct', 0)
                    pattern_summary += f". Best similar pattern resulted in {best_profit:.2f}% profit."
            else:
                pattern_summary = f"Found {len(similar_patterns)} similar patterns, but none have completed trades yet."
        
        # 현재 날짜/시간 정보 포함
        current_date = analysis_context.get('current_date', 'Unknown')
        current_time = analysis_context.get('current_time', 'Unknown')
        backtest_mode = analysis_context.get('backtest_mode', False)
        
        user_msg = f"""Bitcoin Comprehensive Analysis - ₩{price:,.0f}
        TIMESTAMP: {current_date} {current_time}
        ANALYSIS_MODE: {"Backtest" if backtest_mode else "Real-time"}

        TECHNICAL INDICATORS:
        - RSI: {rsi}
        - MACD: {macd}
        - Bollinger Bands: {bb}
        - Moving Averages: {ma}
        - Volume: {volume}
        - Volatility: {volatility}%

        VOLATILITY BREAKOUT ANALYSIS:  
        {volatility_context}

        SUPPORT/RESISTANCE ANALYSIS:
        - Near Support: {is_near_support}
        - Support Level: ₩{closest_support:,.0f}
        - Support Strength: {support_strength:.1f}/1.0
        - Distance to Support: {support_distance:.1f}%

        NEWS IMPACT ANALYSIS:
        {news_summary}

        MARKET REGIME & CONFLUENCE:
        - Market Regime: {market_regime['regime']} (Confidence: {market_regime['confidence']:.2f})
        - Market Trend: {market_trend}
        - Confluence Score: {confluence_signals['total_score']:.1f}/10
        - Bullish Signals: {confluence_signals['bullish_signals']}
        - Bearish Signals: {confluence_signals['bearish_signals']}

        VOLUME & RISK ANALYSIS:
        - Volume-Price Relationship: {volume_analysis}
        - Position Size Recommendation: {risk_metrics['position_size']:.0f}%
        - Max Loss Tolerance: {risk_metrics['max_loss']:.1f}%
        - Expected Value: {risk_metrics['expected_value']:.2f}%

        PATTERN-BASED ADVICE:
        {pattern_summary}
        Optimized parameters from successful patterns:
        - Recommended profit target: {pattern_advice['params']['profit_target']:.1f}%
        - Recommended stop loss: {pattern_advice['params']['stop_loss']:.1f}%
        - Recommended trailing stop: {pattern_advice['params']['trailing_stop']:.1f}%
        Reasoning: {pattern_advice['reasoning']}

        HISTORICAL PATTERNS:
        - Optimal Risk-Reward Ratio: {optimal_rr['ratio']}:1

        RECENT MARKET CONTEXT:
        {self.get_recent_market_context(days=5)}

        HISTORICAL NEWS IMPACT ANALYSIS:
        {historical_news_cases}

        Based on this comprehensive analysis, provide your detailed reasoning and specific trading recommendation:"""
        
        try:
            response = self.llm(f"{system_msg}\n\n{user_msg}", max_tokens=400, temperature=0.75)
            analysis_text = response["choices"][0]["text"].strip()
            
            print("🔍 COMPREHENSIVE ANALYSIS RESULT:")
            print("─" * 80)
            print(analysis_text)
            print("─" * 80)
            print()
            
            return analysis_text
        except Exception as e:
            print(f"  ⚠️  Analysis error: {str(e)}")
            return f"Analysis error: {str(e)}"



    def comprehensive_analysis_with_ai(self, coin, price, tech_indicators, news_summary, support_analysis):
        """Step 2: Comprehensive analysis with ALL available data"""
        
        print("🔍 COMPREHENSIVE ANALYSIS STAGE 2...")
        print(f"  - Current Price: ₩{price:,}")
        print(f"  - Support Strength: {support_analysis.get('strength', 0):.2f}")
        print(f"  - News Summary: {news_summary[:50]}...")
        
        system_msg = """You are the world's best Bitcoin trader. Provide comprehensive analysis using ALL provided data.
    End with specific trading recommendation in this format:

    DECISION: BUY/SELL/HOLD
    PROFIT_TARGET: X%
    STOP_LOSS: -X% 
    TRAILING_STOP: X%
    CONFIDENCE: 0.X"""
        
        # === 기술적 지표 상세 분석 ===
        rsi = tech_indicators.get('RSI(14)', 'N/A')
        macd = tech_indicators.get('MACD', 'N/A')
        bb = tech_indicators.get('Bollinger Bands', 'N/A')
        ma = tech_indicators.get('Moving Averages', 'N/A')
        volume = tech_indicators.get('Volume', 'N/A')
        volatility = tech_indicators.get('Volatility', 'N/A')
        
        # === 고급 분석 결과들 ===
        # 기존 함수들 호출
        market_trend = self.detect_market_trend(tech_indicators)
        news_sentiment = self.analyze_news_sentiment([])  # 빈 리스트로 호출
        
        # Confluence 점수 계산
        confluence_signals = self._calculate_confluence_score(tech_indicators, news_sentiment, support_analysis, market_trend)
        
        # 시장 환경 분석
        market_regime = self._detect_market_regime(tech_indicators, self.get_recent_market_context())
        
        # 거래량-가격 관계
        volume_analysis = self._analyze_volume_price_relationship(tech_indicators, price)
        
        # 유사 패턴 검색
        similar_patterns = self.find_similar_patterns(tech_indicators)
        
        # 리스크 메트릭
        risk_metrics = self._calculate_dynamic_risk_metrics(confluence_signals, market_regime, volume_analysis)
        
        # 최적 리스크-리워드
        optimal_rr = self._calculate_optimal_risk_reward(price, support_analysis, market_regime)
        
        # 지지선 상세 정보
        support_strength = support_analysis.get('strength', 0)
        support_distance = support_analysis.get('distance_percent', 0)
        is_near_support = support_analysis.get('is_near_support', False)
        closest_support = support_analysis.get('closest_support', 0)
        
        # 유사 패턴 요약
        pattern_summary = "No similar patterns found"
        if similar_patterns:
            pattern_summary = f"Found {len(similar_patterns)} similar patterns with avg similarity {sum(p.get('similarity_score', 0) for p in similar_patterns)/len(similar_patterns):.2f}"
        
        user_msg = f"""Bitcoin Comprehensive Analysis - ₩{price:,.0f}

    TECHNICAL INDICATORS:
    - RSI: {rsi}
    - MACD: {macd}
    - Bollinger Bands: {bb}
    - Moving Averages: {ma}
    - Volume: {volume}
    - Volatility: {volatility}%

    SUPPORT/RESISTANCE ANALYSIS:
    - Near Support: {is_near_support}
    - Support Level: ₩{closest_support:,.0f}
    - Support Strength: {support_strength:.1f}/1.0
    - Distance to Support: {support_distance:.1f}%

    NEWS IMPACT ANALYSIS:
    {news_summary}

    MARKET REGIME & CONFLUENCE:
    - Market Regime: {market_regime['regime']} (Confidence: {market_regime['confidence']:.2f})
    - Market Trend: {market_trend}
    - Confluence Score: {confluence_signals['total_score']:.1f}/10
    - Bullish Signals: {confluence_signals['bullish_signals']}
    - Bearish Signals: {confluence_signals['bearish_signals']}

    VOLUME & RISK ANALYSIS:
    - Volume-Price Relationship: {volume_analysis}
    - Position Size Recommendation: {risk_metrics['position_size']:.0f}%
    - Max Loss Tolerance: {risk_metrics['max_loss']:.1f}%
    - Expected Value: {risk_metrics['expected_value']:.2f}%

    HISTORICAL PATTERNS:
    - {pattern_summary}
    - Optimal Risk-Reward Ratio: {optimal_rr['ratio']}:1

    RECENT MARKET CONTEXT:
    {self.get_recent_market_context(days=5)}

    Based on this comprehensive analysis, provide your detailed reasoning and specific trading recommendation:"""
        
        try:
            response = self.llm(f"{system_msg}\n\n{user_msg}", max_tokens=400, temperature=0.75)
            analysis_text = response["choices"][0]["text"].strip()
            
            print("🔍 COMPREHENSIVE ANALYSIS RESULT:")
            print("─" * 80)
            print(analysis_text)
            print("─" * 80)
            print()
            
            return analysis_text
        except Exception as e:
            print(f"  ⚠️  Analysis error: {str(e)}")
            return f"Analysis error: {str(e)}"

    def extract_trading_decision(self, analysis_text):
        """Step 3: Extract trading decision from analysis"""
        
        print("⚙️  DECISION EXTRACTION STAGE 3...")
        
        # 정규식으로 바로 파싱 (2단계 결과가 이미 완벽함)
        import re
        
        decision = re.search(r'DECISION:\s*(BUY|SELL|HOLD)', analysis_text, re.IGNORECASE)
        profit = re.search(r'PROFIT_TARGET:\s*(\d+\.?\d*)%?', analysis_text, re.IGNORECASE)
        stop = re.search(r'STOP_LOSS:\s*-?(\d+\.?\d*)%?', analysis_text, re.IGNORECASE)
        trailing = re.search(r'TRAILING_STOP:\s*(\d+\.?\d*)%?', analysis_text, re.IGNORECASE)
        confidence = re.search(r'CONFIDENCE:\s*(\d+\.?\d*)', analysis_text, re.IGNORECASE)
        
        result = {
            "decision": decision.group(1).upper() if decision else "HOLD",
            "profit_target": float(profit.group(1)) if profit else 5.0,
            "stop_loss": -abs(float(stop.group(1))) if stop else -2.0,
            "trailing_stop": float(trailing.group(1)) if trailing else 1.0,
            "confidence": float(confidence.group(1)) if confidence else 0.5,
            "reasoning": "Extracted from comprehensive analysis"
        }
        
        print("✅ REGEX PARSING SUCCESS:")
        print(f"  ├─ Decision: {result['decision']}")
        print(f"  ├─ Profit Target: {result['profit_target']}%")
        print(f"  ├─ Stop Loss: {result['stop_loss']}%")
        print(f"  ├─ Trailing Stop: {result['trailing_stop']}%")
        print(f"  └─ Confidence: {result['confidence']:.2f}")
        print()
        
        return result



    def analyze_with_llm(self, coin, price, tech_indicators, news_data, test_mode=False):
        """3-stage AI analysis with complete output visibility"""
        if not self.llm:
            return {"signal": "ERROR", "analysis": "LLM not initialized", "confidence": 0}

        print("\n" + "="*70)
        print(f"🚀 STARTING 3-STAGE AI ANALYSIS - {coin}")
        print("="*70)

        # 기존 분석들 (그대로 유지)
        market_trend = self.detect_market_trend(tech_indicators)
        news_sentiment = self.analyze_news_sentiment(news_data)
        support_analysis = self._check_near_support_level_enhanced(coin, price)

        # 현재 시점 확인 - 백테스트 중인 경우 올바른 시점 사용
        current_datetime = datetime.datetime.now()
        
        # 백테스트 결과에서 시점 가져오기 (최우선)
        if hasattr(self, 'backtest_results') and self.backtest_results:
            last_result = self.backtest_results[-1]
            if 'timestamp' in last_result:
                current_datetime = pd.to_datetime(last_result['timestamp'])
            elif 'date' in last_result:
                # 날짜 형식에 따라 처리
                if isinstance(last_result['date'], str):
                    current_datetime = pd.to_datetime(last_result['date'])
                else:
                    current_datetime = last_result['date']
            elif 'datetime' in last_result:
                current_datetime = last_result['datetime']
        
        # historical_data에서 시점 가져오기 (대안)
        elif hasattr(self, 'historical_data') and self.historical_data:
            last_data = self.historical_data[-1]
            if 'datetime' in last_data:
                current_datetime = last_data['datetime']
            elif 'date' in last_data:
                current_datetime = pd.to_datetime(last_data['date'])
        
        print(f"[CONTEXT] Using datetime: {current_datetime.strftime('%Y-%m-%d %H:%M:%S')}")

        # === 1단계: 뉴스 요약 ===
        news_context = self.get_news_context_for_ai(current_datetime, lookback_days=3)
        news_summary = self.summarize_news_with_ai(news_context)

        # === 2단계: 종합 분석 + 결정 ===
        comprehensive_analysis = self.comprehensive_analysis_with_ai(
            coin, price, tech_indicators, news_summary, support_analysis
        )

        # === 3단계: JSON 추출 ===
        decision_result = self.extract_trading_decision(comprehensive_analysis)

        # === 결과 처리 ===
        decision = decision_result.get('decision', 'HOLD')
        profit_target = decision_result.get('profit_target', 5.0)
        stop_loss = decision_result.get('stop_loss', -2.0)
        trailing_stop = decision_result.get('trailing_stop', 1.0)
        confidence = decision_result.get('confidence', 0.5)
        reasoning = decision_result.get('reasoning', 'AI 3-stage analysis completed')

        # 손절가 음수 검증
        if stop_loss > 0:
            print(f"WARNING: Stop loss was positive ({stop_loss}%), converting to negative")
            stop_loss = -abs(stop_loss)

        # 동적 파라미터 조정 (기존 코드)
        confluence_signals = self._calculate_confluence_score(tech_indicators, news_sentiment, support_analysis, market_trend)
        market_regime = self._detect_market_regime(tech_indicators, self.get_recent_market_context())

        profit_target, stop_loss, trailing_stop = self._apply_dynamic_parameters(
            profit_target, stop_loss, trailing_stop, 
            confluence_signals, market_regime, {}
        )

        # === 최종 결과 출력 ===
        print("🎯 FINAL TRADING DECISION:")
        print("="*70)
        print(f"SIGNAL: {decision}")
        print(f"CONFIDENCE: {confidence:.2f}")
        print(f"PROFIT TARGET: {profit_target}%")
        print(f"STOP LOSS: {stop_loss}%")
        print(f"TRAILING STOP: {trailing_stop}%")
        print(f"MARKET TREND: {market_trend}")
        print(f"NEWS SUMMARY: {news_summary[:100]}...")
        print("="*70)
        print()

        # 현재 패턴을 document_store에 추가 (RAG 학습)
        if tech_indicators:
            # 현재 시장 추세 감지
            market_trend = self.detect_market_trend(tech_indicators)
            
            # 지지선 정보 추가
            current_price_val = None
            if hasattr(self, 'historical_data') and len(self.historical_data) > 0:
                current_price_val = self.historical_data[-1].get('price', self.historical_data[-1].get('close'))
            else:
                current_price_val = price
            
            if current_price_val:
                support_analysis_for_rag = self._check_near_support_level_enhanced(coin, current_price_val)
            else:
                support_analysis_for_rag = {}
            
            new_context = {
                'date': current_datetime.strftime("%Y-%m-%d"),
                'indicators': tech_indicators,
                'market_trend': market_trend,
                'support_analysis': support_analysis_for_rag,
                'content': f"Market shows {market_trend} with RSI at {tech_indicators.get('RSI(14)', 'N/A')}. "
                        f"MACD is {tech_indicators.get('MACD', 'N/A')}. "
                        f"Bollinger Bands: {tech_indicators.get('Bollinger Bands', 'N/A')}. "
                        f"Moving Averages: {tech_indicators.get('Moving Averages', 'N/A')}. "
                        f"Support level nearby: {support_analysis_for_rag.get('is_near_support', False)}, "
                        f"Support strength: {support_analysis_for_rag.get('strength', 0):.2f}."
            }
            
            # 중복 방지를 위한 검사
            existing_index = -1
            for i, doc in enumerate(self.document_store):
                if doc.get('date') == new_context['date']:
                    existing_index = i
                    break
            
            if existing_index >= 0:
                # 기존 항목 업데이트
                self.document_store[existing_index] = new_context
            else:
                # 새 항목 추가
                self.document_store.append(new_context)

        # 기존 형식으로 반환
        return {
            "signal": decision,
            "profit_target": profit_target,
            "stop_loss": stop_loss,
            "trailing_stop": trailing_stop,
            "analysis": comprehensive_analysis,  # 2단계 전체 텍스트
            "confidence": confidence,
            "market_trend": market_trend,
            "news_sentiment": news_sentiment,
            "reasoning": reasoning,
            "support_analysis": support_analysis,
            "news_summary": news_summary,  # 1단계 결과
            "confluence_score": confluence_signals.get('total_score', 0),
            "market_regime": market_regime
        }

    # 고급 투자전략 지원 함수들

    def _assess_support_risk(self, closest_support, current_price, strength):
        """지지선 기반 리스크 평가"""
        if closest_support <= 0:
            return "No clear support - HIGH RISK"
        
        distance_pct = abs((current_price - closest_support) / current_price) * 100
        
        # 거리와 강도를 종합한 리스크 평가
        if strength >= 0.8 and distance_pct <= 2.0:
            return "VERY LOW RISK - Strong nearby support"
        elif strength >= 0.6 and distance_pct <= 3.0:
            return "LOW RISK - Good support level"
        elif strength >= 0.4 and distance_pct <= 5.0:
            return "MEDIUM RISK - Moderate support"
        elif distance_pct > 10.0:
            return "HIGH RISK - Support too far away"
        else:
            return "HIGH RISK - Weak support level"

    def _format_similar_patterns(self, similar_patterns):
        """유사 패턴을 읽기 쉽게 포맷팅"""
        if not similar_patterns or len(similar_patterns) == 0:
            return "No matching patterns found in historical data"
        
        formatted = "Historical Patterns (Most Similar):\n"
        for i, pattern in enumerate(similar_patterns[:3]):  # 상위 3개만
            date = pattern.get('date', 'Unknown')
            score = pattern.get('similarity_score', 0)
            content = pattern.get('content', '')
            
            # 패턴 내용에서 핵심 정보 추출
            if 'uptrend' in content.lower() or 'bullish' in content.lower():
                signal_hint = "BULLISH"
            elif 'downtrend' in content.lower() or 'bearish' in content.lower():
                signal_hint = "BEARISH"
            else:
                signal_hint = "NEUTRAL"
            
            formatted += f"  {i+1}. Date: {date}, Similarity: {score:.1f}, Signal: {signal_hint}\n"
            formatted += f"     Pattern: {content[:100]}{'...' if len(content) > 100 else ''}\n"
        
        return formatted

    def _synthesize_patterns_and_context(self, similar_patterns, context_string):
        """패턴과 컨텍스트를 종합하여 인사이트 제공"""
        synthesis = "INTEGRATED ANALYSIS:\n"
        
        # 패턴 분석
        if similar_patterns and len(similar_patterns) > 0:
            bullish_patterns = 0
            bearish_patterns = 0
            
            for pattern in similar_patterns[:5]:
                content = pattern.get('content', '').lower()
                if 'bullish' in content or 'uptrend' in content or 'buy' in content:
                    bullish_patterns += 1
                elif 'bearish' in content or 'downtrend' in content or 'sell' in content:
                    bearish_patterns += 1
            
            if bullish_patterns > bearish_patterns:
                synthesis += f"- Historical Pattern Bias: BULLISH ({bullish_patterns} vs {bearish_patterns})\n"
            elif bearish_patterns > bullish_patterns:
                synthesis += f"- Historical Pattern Bias: BEARISH ({bearish_patterns} vs {bullish_patterns})\n"
            else:
                synthesis += f"- Historical Pattern Bias: NEUTRAL ({bullish_patterns} vs {bearish_patterns})\n"
        else:
            synthesis += "- Historical Patterns: No clear precedent found\n"
        
        # 컨텍스트 분석
        if context_string:
            # 컨텍스트에서 핵심 키워드 추출
            context_lower = context_string.lower()
            
            if 'strong bullish' in context_lower or 'bullish signal' in context_lower:
                synthesis += "- Market Context: Strong bullish indicators detected\n"
            elif 'bearish' in context_lower:
                synthesis += "- Market Context: Bearish conditions present\n"
            elif 'neutral' in context_lower:
                synthesis += "- Market Context: Neutral market conditions\n"
            else:
                synthesis += "- Market Context: Mixed signals requiring careful analysis\n"
            
            # 볼륨 및 추세 정보 추출
            if 'increasing volume' in context_lower:
                synthesis += "- Volume Context: Rising volume supports current move\n"
            elif 'decreasing volume' in context_lower:
                synthesis += "- Volume Context: Declining volume shows weak conviction\n"
        else:
            synthesis += "- Enhanced Context: Limited additional context available\n"
        
        # 종합 결론
        synthesis += "\nCONTEXT-PATTERN CONCLUSION:\n"
        synthesis += "Integrating historical patterns with current market context for optimal decision making."
        
        return synthesis




    def _calculate_confluence_score(self, tech_indicators, news_sentiment, support_analysis, market_trend):
        """다중 신호 점수 계산 시스템"""
        score = {
            'technical_score': 0.0,
            'fundamental_score': 0.0,
            'risk_score': 0.0,
            'bullish_signals': 0,
            'bearish_signals': 0,
            'total_score': 0.0
        }
        
        # Technical Score (5점 만점)
        rsi_value = tech_indicators.get('RSI(14)', 50)
        try:
            rsi_num = float(str(rsi_value).replace(',', ''))
            if rsi_num < 30:
                score['technical_score'] += 1.5
                score['bullish_signals'] += 1
            elif rsi_num > 70:
                score['technical_score'] -= 1.5
                score['bearish_signals'] += 1
        except:
            pass
        
        macd = tech_indicators.get('MACD', '')
        if 'Bullish' in str(macd):
            score['technical_score'] += 1.0
            score['bullish_signals'] += 1
        elif 'Bearish' in str(macd):
            score['technical_score'] -= 1.0
            score['bearish_signals'] += 1
        
        bb = tech_indicators.get('Bollinger Bands', '')
        if 'lower' in str(bb).lower():
            score['technical_score'] += 0.8
            score['bullish_signals'] += 1
        elif 'upper' in str(bb).lower():
            score['technical_score'] -= 0.8
            score['bearish_signals'] += 1
        
        # Moving Average Analysis
        ma = tech_indicators.get('Moving Averages', '')
        if 'Price > MA' in str(ma):
            score['technical_score'] += 0.7
            score['bullish_signals'] += 1
        elif 'Price < MA' in str(ma):
            score['technical_score'] -= 0.7
            score['bearish_signals'] += 1
        
        # Fundamental Score (3점 만점)
        sentiment_score = news_sentiment.get('sentiment_score', 0)
        if sentiment_score > 0.3:
            score['fundamental_score'] += 1.5
            score['bullish_signals'] += 1
        elif sentiment_score < -0.3:
            score['fundamental_score'] -= 1.5
            score['bearish_signals'] += 1
        
        # Support Analysis
        if support_analysis.get('is_near_support', False):
            strength = support_analysis.get('strength', 0)
            score['fundamental_score'] += strength * 1.5
            if strength > 0.6:
                score['bullish_signals'] += 1
        
        # Risk Score (2점 만점)
        if 'uptrend' in market_trend.lower():
            score['risk_score'] += 1.0
        elif 'downtrend' in market_trend.lower():
            score['risk_score'] -= 1.0
        
        # Volume confirmation
        volume = tech_indicators.get('Volume', '')
        if 'increasing' in str(volume).lower():
            score['risk_score'] += 1.0
            score['bullish_signals'] += 1
        elif 'decreasing' in str(volume).lower():
            score['risk_score'] -= 0.5
        
        # Calculate total score (normalized to 10)
        raw_total = score['technical_score'] + score['fundamental_score'] + score['risk_score']
        score['total_score'] = max(0, min(10, (raw_total + 5) * 2))  # Normalize to 0-10 scale
        
        return score

    def _detect_market_regime(self, tech_indicators, recent_context):
        """시장 환경 감지"""
        regime = {
            'regime': 'RANGING',
            'confidence': 0.5,
            'characteristics': []
        }
        
        # Volatility analysis
        volatility = tech_indicators.get('Volatility', 0)
        try:
            vol_num = float(str(volatility).replace(',', ''))
            if vol_num > 50:
                regime['regime'] = 'HIGH_VOLATILITY'
                regime['characteristics'].append('Extreme volatility')
                regime['confidence'] += 0.2
            elif vol_num < 20:
                regime['regime'] = 'LOW_VOLATILITY'
                regime['characteristics'].append('Consolidation phase')
                regime['confidence'] += 0.1
        except:
            pass
        
        # Trend strength analysis
        ma_data = tech_indicators.get('Moving Averages', '')
        if 'Price > MA5 > MA10 > MA20' in str(ma_data):
            regime['regime'] = 'STRONG_UPTREND'
            regime['confidence'] = 0.9
            regime['characteristics'].append('Strong bullish alignment')
        elif 'Price < MA5 < MA10 < MA20' in str(ma_data):
            regime['regime'] = 'STRONG_DOWNTREND'
            regime['confidence'] = 0.9
            regime['characteristics'].append('Strong bearish alignment')
        
        # Recent context analysis
        if recent_context and 'uptrend' in recent_context.lower():
            if regime['regime'] == 'RANGING':
                regime['regime'] = 'EMERGING_UPTREND'
            regime['confidence'] += 0.2
        elif recent_context and 'downtrend' in recent_context.lower():
            if regime['regime'] == 'RANGING':
                regime['regime'] = 'EMERGING_DOWNTREND'
            regime['confidence'] += 0.2
        
        regime['confidence'] = min(1.0, max(0.0, regime['confidence']))
        return regime

    def _analyze_volume_price_relationship(self, tech_indicators, price):
        """거래량-가격 관계 분석"""
        volume_info = tech_indicators.get('Volume', 'Unknown')
        
        if 'increasing' in str(volume_info).lower():
            return "Price rising with increasing volume - Strong bullish confirmation"
        elif 'decreasing' in str(volume_info).lower():
            return "Volume declining - Weak price action, potential reversal"
        elif 'high' in str(volume_info).lower():
            return "High volume present - Significant market interest"
        else:
            return "Normal volume conditions"

    def _calculate_dynamic_risk_metrics(self, confluence_signals, market_regime, volume_analysis):
        """동적 위험 관리 메트릭"""
        metrics = {
            'position_size': 100.0,  # Default 100%
            'max_loss': 2.0,         # Default 2%
            'expected_value': 0.0
        }
        
        # Adjust position size based on confluence score
        confluence_score = confluence_signals['total_score']
        if confluence_score >= 8.0:
            metrics['position_size'] = 100.0  # Full position
        elif confluence_score >= 6.0:
            metrics['position_size'] = 75.0   # 3/4 position
        elif confluence_score >= 4.0:
            metrics['position_size'] = 50.0   # Half position
        else:
            metrics['position_size'] = 25.0   # Quarter position
        
        # Adjust max loss based on market regime
        if market_regime['regime'] in ['STRONG_UPTREND', 'STRONG_DOWNTREND']:
            metrics['max_loss'] = 1.5  # Tighter stop in trending markets
        elif market_regime['regime'] == 'HIGH_VOLATILITY':
            metrics['max_loss'] = 3.0  # Wider stop in volatile markets
        
        # Calculate expected value (simplified)
        win_rate = 0.4 + (confluence_score / 25.0)  # Base 40% + confluence bonus
        avg_win = 3.0    # Average 3% win
        avg_loss = metrics['max_loss']
        metrics['expected_value'] = (win_rate * avg_win) - ((1 - win_rate) * avg_loss)
        
        return metrics

    def _analyze_rsi_advanced(self, rsi_value, price):
        """고급 RSI 분석 (다이버전스 포함)"""
        if rsi_value < 20:
            return "EXTREME OVERSOLD - High probability reversal", "VERY_STRONG"
        elif rsi_value < 30:
            return "OVERSOLD - Bullish signal", "STRONG"
        elif rsi_value > 80:
            return "EXTREME OVERBOUGHT - High probability reversal", "VERY_STRONG"
        elif rsi_value > 70:
            return "OVERBOUGHT - Bearish signal", "STRONG"
        elif 30 <= rsi_value <= 70:
            return "NEUTRAL - No clear signal", "WEAK"
        else:
            return "UNDEFINED", "NONE"

    def _analyze_macd_advanced(self, macd):
        """고급 MACD 분석 (모멘텀 포함)"""
        if 'Bullish crossover' in str(macd):
            return "STRONG BUY - Fresh bullish momentum", "ACCELERATING"
        elif 'Bearish crossover' in str(macd):
            return "STRONG SELL - Fresh bearish momentum", "DECELERATING"
        elif 'Bullish' in str(macd):
            return "BUY - Above signal line", "POSITIVE"
        elif 'Bearish' in str(macd):
            return "SELL - Below signal line", "NEGATIVE"
        else:
            return "NEUTRAL", "FLAT"

    def _analyze_bollinger_advanced(self, bb, price):
        """고급 볼린저 밴드 분석 (스퀴즈 감지 포함)"""
        if 'lower' in str(bb).lower():
            return "BUY SIGNAL - Near lower band", "POTENTIAL_REVERSAL"
        elif 'upper' in str(bb).lower():
            return "SELL SIGNAL - Near upper band", "POTENTIAL_REVERSAL"
        elif 'between' in str(bb).lower():
            return "NEUTRAL - Between bands", "NORMAL_RANGE"
        else:
            return "ANALYSIS_NEEDED", "UNKNOWN"

    def _calculate_sentiment_momentum(self, news_data):
        """뉴스 감성 모멘텀 계산"""
        if len(news_data) < 2:
            return "INSUFFICIENT_DATA"
        
        # Simple momentum calculation based on recent vs older news
        recent_news = news_data[:len(news_data)//2]
        older_news = news_data[len(news_data)//2:]
        
        # This is a simplified version - would need actual sentiment scores per article
        if len(recent_news) > len(older_news):
            return "INCREASING"
        elif len(recent_news) < len(older_news):
            return "DECREASING"
        else:
            return "STABLE"

    def _news_to_signal(self, sentiment_score, momentum):
        """뉴스 감성을 거래 신호로 변환"""
        if sentiment_score > 0.3:
            if momentum == "INCREASING":
                return "STRONG BUY"
            else:
                return "BUY"
        elif sentiment_score < -0.3:
            if momentum == "INCREASING":
                return "STRONG SELL"
            else:
                return "SELL"
        else:
            return "NEUTRAL"

    def _analyze_support_zones(self, support_analysis, price):
        """지지선 구간 분석"""
        if not support_analysis.get('is_near_support', False):
            return "No significant support zones detected"
        
        strength = support_analysis.get('strength', 0)
        distance = support_analysis.get('distance_percent', 0)
        
        if strength >= 0.8 and distance <= 1.0:
            return "CRITICAL SUPPORT ZONE - Very high probability of bounce"
        elif strength >= 0.6 and distance <= 2.0:
            return "STRONG SUPPORT ZONE - High probability of bounce"
        elif strength >= 0.4 and distance <= 3.0:
            return "MODERATE SUPPORT ZONE - Watch for bounce"
        else:
            return "WEAK SUPPORT ZONE - May not hold"

    def _analyze_market_structure(self, confluence_signals, market_regime):
        """시장 구조 분석"""
        structure = ""
        
        total_score = confluence_signals['total_score']
        bullish_signals = confluence_signals['bullish_signals']
        bearish_signals = confluence_signals['bearish_signals']
        
        if bullish_signals > bearish_signals + 2:
            structure = "BULLISH MARKET STRUCTURE - Multiple confirming signals"
        elif bearish_signals > bullish_signals + 2:
            structure = "BEARISH MARKET STRUCTURE - Multiple warning signals"
        else:
            structure = "MIXED MARKET STRUCTURE - Conflicting signals"
        
        regime_type = market_regime['regime']
        if regime_type in ['STRONG_UPTREND', 'STRONG_DOWNTREND']:
            structure += f" in {regime_type.replace('_', ' ').title()} regime"
        
        return structure

    def _calculate_optimal_risk_reward(self, price, support_analysis, market_regime):
        """최적 리스크-리워드 비율 계산"""
        # Default 2:1 ratio
        optimal_ratio = {
            'ratio': 2.0,
            'reasoning': "Standard risk-reward ratio"
        }
        
        # Adjust based on support strength
        if support_analysis.get('is_near_support', False):
            strength = support_analysis.get('strength', 0)
            if strength >= 0.8:
                optimal_ratio['ratio'] = 3.0
                optimal_ratio['reasoning'] = "Strong support allows for better risk-reward"
            elif strength >= 0.6:
                optimal_ratio['ratio'] = 2.5
                optimal_ratio['reasoning'] = "Good support provides favorable risk-reward"
        
        # Adjust based on market regime
        if market_regime['regime'] == 'STRONG_UPTREND':
            optimal_ratio['ratio'] = min(4.0, optimal_ratio['ratio'] + 1.0)
            optimal_ratio['reasoning'] += " - Trending market allows extended targets"
        elif market_regime['regime'] == 'HIGH_VOLATILITY':
            optimal_ratio['ratio'] = max(1.5, optimal_ratio['ratio'] - 0.5)
            optimal_ratio['reasoning'] += " - Volatile conditions require tighter management"
        
        return optimal_ratio

    def _apply_dynamic_parameters(self, profit_target, stop_loss, trailing_stop, confluence_signals, market_regime, risk_metrics):
        """동적 파라미터 조정"""
        # Adjust based on confluence score
        score = confluence_signals['total_score']
        
        if score >= 8.0:
            # High confidence - extend targets
            profit_target = min(15.0, profit_target * 1.2)
            stop_loss = max(-3.0, stop_loss * 0.8)  # Tighter stop
            trailing_stop = min(2.5, trailing_stop * 1.1)
        elif score <= 3.0:
            # Low confidence - conservative targets
            profit_target = max(2.0, profit_target * 0.7)
            stop_loss = min(-1.0, stop_loss * 1.2)  # Wider stop
            trailing_stop = max(0.5, trailing_stop * 0.9)
        
        # Adjust based on market regime
        regime = market_regime['regime']
        if regime == 'STRONG_UPTREND':
            profit_target = min(20.0, profit_target * 1.1)
            trailing_stop = min(3.0, trailing_stop * 1.2)
        elif regime == 'HIGH_VOLATILITY':
            stop_loss = max(-5.0, stop_loss * 1.5)
            trailing_stop = min(3.0, trailing_stop * 1.3)
        
        return profit_target, stop_loss, trailing_stop
    

    def run_backtest(self, start_date=None, end_date=None, data=None, timeframe=None, 
                    test_mode=False, llm_mode=True, initial_position=False):
        """
        완전히 수정된 백테스트 시스템 - 매수 문제 해결
        """
        
        # 기존 방식 호환성 유지
        if data is not None:
            print("기존 백테스트 방식 사용 (전체 데이터 일괄 로드)")
            return self._run_backtest_legacy_enhanced(data, test_mode, llm_mode, initial_position)
        
        # 새로운 방식: 하루 단위 + 강화된 전략
        if start_date is None or end_date is None:
            raise ValueError("start_date와 end_date는 필수 파라미터입니다")
        
        try:
            current_date = pd.to_datetime(start_date)
            end_dt = pd.to_datetime(end_date)
            print(f"🚀 완전 강화된 백테스트 시작: {current_date.strftime('%Y-%m-%d')} ~ {end_dt.strftime('%Y-%m-%d')}")
        except Exception as e:
            raise ValueError(f"날짜 형식 오류: {str(e)}")
        
        # 🚨 1. 초간단 매도 함수 정의 (누락된 함수)
        def simple_exit_strategy_fixed(current_price, entry_price, entry_date, current_date, 
                                    market_trend, profit_target, stop_loss, confidence,
                                    position_adjustments=None):
            """✅ AI 조건 우선 적용"""
            
            profit_pct = ((current_price / entry_price) - 1) * 100
            
            # ✅ 1순위: AI 손절 조건
            if profit_pct <= stop_loss:
                return "SELL_STOPLOSS", f"AI 손절매 ({profit_pct:.2f}% ≤ {stop_loss:.2f}%)"
            
            # ✅ 2순위: AI 익절 조건  
            if profit_pct >= profit_target:
                return "SELL_PROFIT", f"AI 익절 ({profit_pct:.2f}% ≥ {profit_target:.2f}%)"
            
            # ✅ 3순위: 시간 청산 (더 길게, 신뢰도 고려)
            try:
                entry_dt = pd.to_datetime(entry_date)
                current_dt = pd.to_datetime(current_date)
                days_held = (current_dt - entry_dt).days
                
                # 신뢰도에 따른 동적 보유 기간
                max_hold_days = max(7, int(confidence * 14))  # 7-14일
                
                if days_held >= max_hold_days:
                    return "SELL_TIMEOUT", f"{max_hold_days}일 경과 청산 ({profit_pct:.2f}%)"
            except:
                pass
            
            return "HOLD", f"보유 중 ({profit_pct:.2f}%, 목표: {profit_target:.1f}%, 손절: {stop_loss:.1f}%)"
        
        # 🚨 2. 간단한 통합 결정 시스템
        def simple_integrated_decision(analysis_result, pattern_advice, news_sentiment, market_trend, confluence_signals):
            """간단한 매수 결정 - 너무 까다롭지 않게"""
            
            ai_decision = analysis_result.get('signal', 'HOLD')
            confidence = analysis_result.get('confidence', 0.5)
            
            print(f"🔍 통합결정 디버깅:")
            print(f"  ├─ AI결정: {ai_decision}")
            print(f"  ├─ 신뢰도: {confidence:.2f}")
            print(f"  ├─ 시장추세: {market_trend}")
            
            # 🚨 매우 관대한 매수 조건
            should_buy = False
            reasons = []
            
            # 기본 조건: AI가 BUY 신호 + 신뢰도 0.3 이상
            if ai_decision == "BUY" and confidence >= 0.3:
                should_buy = True
                reasons.append(f"AI매수신호+신뢰도{confidence:.2f}")
            
            # 추가 보정: 뉴스가 긍정적이면 신뢰도 낮아도 OK
            if ai_decision == "BUY" and confidence >= 0.2:
                if news_sentiment.get('sentiment_score', 0) > 0.1:
                    should_buy = True
                    reasons.append("긍정뉴스보정")
            
            # 최종 안전장치: 매우 높은 신뢰도면 무조건 매수
            if confidence >= 0.8:
                should_buy = True
                reasons.append(f"고신뢰도{confidence:.2f}")
            
            print(f"  ├─ 매수결정: {should_buy}")
            print(f"  └─ 근거: {', '.join(reasons) if reasons else '조건미달'}")
            
            return {
                'should_buy': should_buy,
                'total_score': confidence * 100,
                'reasons': reasons,
                'details': f"간단통합결정: {'매수' if should_buy else '보류'}"
            }
        
        # 🚨 3. 간단한 포지션 사이징
        def simple_position_sizing(price, confidence, balance):
            """간단한 포지션 사이징 - 확실히 작동"""
            
            print(f"🔍 포지션사이징 디버깅:")
            print(f"  ├─ 현재가격: ₩{price:,.0f}")
            print(f"  ├─ 신뢰도: {confidence:.2f}")
            print(f"  ├─ 잔고: ₩{balance:,.0f}")
            
            # 기본 투자 비율: 20% (안전하게)
            base_ratio = 0.2
            
            # 신뢰도에 따른 조정
            confidence_multiplier = max(0.5, min(1.5, confidence * 2))
            final_ratio = base_ratio * confidence_multiplier
            
            # 최대 50%로 제한
            final_ratio = min(0.5, final_ratio)
            
            investment_amount = balance * final_ratio
            fee_rate = 0.0005
            
            # 수수료 고려한 실제 매수 가능 금액
            available_for_coin = investment_amount / (1 + fee_rate)
            coin_amount = available_for_coin / price
            fee = investment_amount - available_for_coin
            total_cost = investment_amount
            
            print(f"  ├─ 투자비율: {final_ratio*100:.1f}%")
            print(f"  ├─ 투자금액: ₩{investment_amount:,.0f}")
            print(f"  ├─ 코인수량: {coin_amount:.8f}")
            print(f"  ├─ 수수료: ₩{fee:,.0f}")
            print(f"  └─ 총비용: ₩{total_cost:,.0f}")
            
            position_adjustments = {
                'fee': fee,
                'profit_target_adjustment': 0,
                'stop_loss_adjustment': 0,
                'investment_ratio': final_ratio
            }
            
            return coin_amount, total_cost, final_ratio, position_adjustments
        
        # RAG 패턴 데이터 로드
        try:
            self.load_rag_patterns()
            print("기존 RAG 패턴 데이터 로드 완료")
        except Exception as e:
            print(f"RAG 패턴 로드 실패: {str(e)}. 새로운 패턴 저장소로 시작")
            if not hasattr(self, 'document_store'):
                self.document_store = []
        
        # Fear & Greed Index 초기화
        self.fear_greed_index = 50
        
        # timeframe 설정
        if timeframe is None:
            timeframe = getattr(self, 'timeframe', '1h')
        
        print(f"🎯 RAG 기반 선별적 호출 백테스트 설정:")
        print(f"- 타임프레임: {timeframe}")
        print(f"- RAG 기반 시점 선별")
        print(f"- 🚨 간단한 매수 조건 적용")
        
        # 초기화
        backtest_results = []
        
        # 강화된 계좌 관리
        self.initial_balance = getattr(self, 'initial_balance', 10000000)
        self.current_balance = self.initial_balance
        self.coin_amount = 0.0
        self.total_fees_paid = 0.0
        
        print(f"💰 초기 설정: 잔고=₩{self.current_balance:,.0f}")
        
        # 포지션 관리 변수
        in_position = initial_position
        entry_price = 0.0
        entry_date = None
        entry_amount_krw = 0.0  
        profit_target = 7.0  # 🚨 수정: 더 높은 목표
        stop_loss = -3.0     # 🚨 수정: 더 큰 손절
        trailing_stop = 1.0
        self.trailing_stop_price = 0.0
        current_pattern_id = None
        position_adjustments = None
        
        # 강화된 통계 변수
        ai_calls_count = 0
        trigger_count = 0
        rag_approved_count = 0
        rag_rejected_count = 0
        strong_buy_signals = 0
        confirmed_signals = 0
        unconfirmed_signals = 0
        actual_buy_count = 0  # 🚨 추가: 실제 매수 횟수
        
        # 리스크 관리 변수
        self.consecutive_losses = 0
        self.consecutive_wins = 0
        self.breakeven_protection_active = False
        self.partial_profit_taken = False
        self.profit_stagnation_days = 0
        
        # 백테스트 결과 초기화
        self.backtest_results = []
        
        # 처리된 타임스탬프 집합
        processed_timestamps = set()
        
        # 일별 백테스팅 루프
        while current_date <= end_dt:
            print(f"\n📅 === 처리 중: {current_date.strftime('%Y-%m-%d')} ===")
            
            # 하루 단위 데이터 로딩
            daily_data = self.load_daily_data(current_date.strftime('%Y-%m-%d'), timeframe)
            
            # 뉴스 데이터 가져오기
            news_lookback_days = 3
            lookback_start = current_date - datetime.timedelta(days=news_lookback_days)
            daily_news = self.fetch_news("BTC", lookback_start, current_date)
            
            # Fear & Greed Index 업데이트
            if not daily_data.empty:
                market_volatility = self.calculate_volatility(daily_data)
                if market_volatility > 0.1:
                    self.fear_greed_index = max(10, self.fear_greed_index - 10)
                elif market_volatility < 0.03:
                    self.fear_greed_index = min(90, self.fear_greed_index + 5)
            
            if daily_data.empty:
                print(f"⚠️ {current_date.strftime('%Y-%m-%d')} 데이터 없음")
                current_date += datetime.timedelta(days=1)
                continue
            
            # 하루 데이터를 historical_data에 추가
            for timestamp, row in daily_data.iterrows():
                current_data = {
                    'date': timestamp.strftime('%Y-%m-%d %H:%M:%S'),
                    'datetime': timestamp,
                    'price': row['close'],
                    'close': row['close'],
                    'open': row['open'],
                    'high': row['high'],
                    'low': row['low'],
                    'volume': row['volume']
                }
                
                if hasattr(self, 'historical_data'):
                    self.historical_data.append(current_data)
                else:
                    self.historical_data = [current_data]
            
            # 각 캔들 처리
            daily_candles = list(daily_data.iterrows())
            
            for idx, (timestamp, row) in enumerate(daily_candles):
                timestamp_str = timestamp.strftime('%Y-%m-%d %H:%M:%S')
                
                if timestamp_str in processed_timestamps:
                    continue
                
                processed_timestamps.add(timestamp_str)
                price = row['close']
                
                # 현재 캔들 정보
                current_candle_data = {
                    'open': row['open'],
                    'high': row['high'],
                    'low': row['low'],
                    'close': row['close'],
                    'volume': row['volume']
                }
                
                # 다음 캔들 정보 (컨펌용)
                next_candle_data = None
                if idx < len(daily_candles) - 1:
                    next_timestamp, next_row = daily_candles[idx + 1]
                    next_candle_data = {
                        'open': next_row['open'],
                        'high': next_row['high'],
                        'low': next_row['low'],
                        'close': next_row['close'],
                        'volume': next_row['volume']
                    }
                
                # 가상 거래 및 기회비용 추적 업데이트
                self.track_hypothetical_trades(price, timestamp_str)
                
                # 테스트 모드 제한
                if test_mode and ai_calls_count > 10:
                    break
                
                # === 포지션 보유 중 매도 로직 ===
                if in_position:
                    current_portfolio_value = self.current_balance + (self.coin_amount * price)
                    profit_pct = ((price / entry_price) - 1) * 100
                    
                    print(f"💎 포지션 보유중: 수익률 {profit_pct:.2f}%")
                    
                    # 🚨 수정된 간단한 매도 전략 사용
                    exit_decision, exit_reason = simple_exit_strategy_fixed(
                        price, entry_price, entry_date, timestamp_str,
                        "Unknown", profit_target, stop_loss, 
                        getattr(self, 'last_confidence', 0.5),
                        position_adjustments
                    )
                    
                    # 완전 매도 처리
                    if exit_decision != "HOLD":
                        fee_rate = 0.0005
                        sell_amount_krw = self.coin_amount * price
                        fee = sell_amount_krw * fee_rate
                        final_amount = sell_amount_krw - fee
                        
                        # 🚨 수익 계산 디버깅
                        print(f"🔍 매도 계산:")
                        print(f"  ├─ 코인수량: {self.coin_amount:.8f}")
                        print(f"  ├─ 매도가격: ₩{price:,.0f}")
                        print(f"  ├─ 매도금액: ₩{sell_amount_krw:,.0f}")
                        print(f"  ├─ 수수료: ₩{fee:,.0f}")
                        print(f"  ├─ 실수령액: ₩{final_amount:,.0f}")
                        print(f"  ├─ 원투자금: ₩{entry_amount_krw:,.0f}")
                        print(f"  └─ 실제수익: ₩{final_amount - entry_amount_krw:,.0f}")
                        
                        self.current_balance += final_amount
                        profit_amount = final_amount - entry_amount_krw  
                        self.coin_amount = 0.0
                        self.total_fees_paid += fee
                        in_position = False
                        
                        # 포지션 관련 플래그 리셋
                        self.breakeven_protection_active = False
                        self.partial_profit_taken = False
                        self.profit_stagnation_days = 0
                        
                        print(f"📤 매도 완료: 수익=₩{profit_amount:,.0f} ({profit_pct:.2f}%)")
                        
                        backtest_results.append({
                            'date': timestamp_str,
                            'datetime': timestamp,
                            'price': price,
                            'ai_decision': 'NONE',
                            'actual_decision': exit_decision,
                            'profit_pct': profit_pct,
                            'profit_amount': profit_amount,
                            'confidence': getattr(self, 'last_confidence', 0.5),
                            'entry_price': entry_price,
                            'entry_date': entry_date,
                            'exit_reason': exit_reason,
                            'balance': self.current_balance,
                            'coin_amount': 0.0,
                            'portfolio_value': self.current_balance,
                            'fees_paid': fee
                        })
                        continue
                    
                    continue
                
                # === 🚨 핵심 수정: RAG 기반 선별적 진입 로직 ===
                if not in_position:
                    # 🎯 1단계: 기술적 지표 계산 (RAG 체크용)
                    if len(getattr(self, 'historical_data', [])) > 14:
                        temp_data = []
                        for item in self.historical_data[-30:]:
                            temp_data.append({
                                'close': item['close'],
                                'open': item.get('open', item['close']),
                                'high': item.get('high', item['close']),
                                'low': item.get('low', item['close']),
                                'volume': item.get('volume', 0)
                            })
                        temp_df = pd.DataFrame(temp_data)
                        temp_df, tech_indicators = self.calculate_technical_indicators(temp_df)
                    else:
                        tech_indicators = {}
                    
                    # 🎯 2단계: 현재 캔들 시점의 뉴스 필터링
                    candle_news = self._filter_news_for_timestamp(daily_news, timestamp)
                    
                    # 🚨 핵심: RAG 기반 트리거 체크
                    rag_trigger, rag_reason = self.rag_based_trigger_check(price, timestamp, tech_indicators, candle_news)
                    print(f"🔍 RAG 트리거 결과: {rag_trigger}, 이유: {rag_reason}")
                    
                    if rag_trigger:
                        # ✅ RAG 승인된 경우에만 AI 분석 진행
                        rag_approved_count += 1
                        trigger_count += 1
                        print(f"🎯 [RAG 선별 트리거 #{trigger_count}] {rag_reason}")
                        
                        # LLM 분석 실행
                        if llm_mode:
                            ai_calls_count += 1
                            print(f"🤖 [AI 호출 #{ai_calls_count}] 강화된 분석 시작...")
                            
                            if len(backtest_results) > 0:
                                self.backtest_results = backtest_results.copy()
                            
                            # 분석 컨텍스트
                            analysis_context = {
                                'current_datetime': timestamp,
                                'current_date': timestamp.strftime('%Y-%m-%d'),
                                'current_time': timestamp.strftime('%H:%M:%S'),
                                'backtest_mode': True,
                                'fear_greed_index': self.fear_greed_index,
                                'volatility_context': self.get_volatility_context_for_ai(price, current_candle_data.get('volume', 0))
                            }
                            
                            # AI 분석 결과
                            analysis_result = self.analyze_with_llm_with_context(
                                "BTC/KRW", price, tech_indicators, candle_news, analysis_context, test_mode
                            )
                            
                            # AI 결과 파싱
                            ai_decision = analysis_result.get('signal', 'HOLD')
                            confidence = analysis_result.get('confidence', 0.5)
                            profit_target_ai = analysis_result.get('profit_target', 7.0)
                            stop_loss_ai = analysis_result.get('stop_loss', -3.0)
                            market_trend = analysis_result.get('market_trend', 'Unknown')
                            news_sentiment = analysis_result.get('news_sentiment', {})
                            
                            self.last_confidence = confidence
                            
                            print(f"🎯 AI 결정: {ai_decision}, 신뢰도: {confidence:.2f}")
                            
                            # 컨펌 캔들 시스템 적용 (간소화)
                            if ai_decision == "BUY" and confidence >= 0.4:
                                confirmed_signals += 1
                                final_ai_decision = "BUY"
                                final_confidence = confidence
                            else:
                                final_ai_decision = ai_decision
                                final_confidence = confidence
                            
                            # 유사 패턴 검색 (간소화)
                            try:
                                similar_patterns = self.find_similar_patterns(tech_indicators, success_weight=True, time_decay=True)
                                pattern_advice = self.get_pattern_based_advice(similar_patterns)
                            except:
                                pattern_advice = {'success_rate': 0.5, 'avg_return': 0.0}
                            
                            # 🚨 핵심: 간단한 통합 결정
                            integrated_decision = simple_integrated_decision(
                                analysis_result, pattern_advice, news_sentiment, market_trend, {}
                            )
                            
                            should_buy = integrated_decision['should_buy']
                            print(f"🎯 통합 결정: {integrated_decision['details']}")
                            print(f"   근거: {', '.join(integrated_decision['reasons'])}")
                            
                            # 🚨 수정된 매수 실행
                            if should_buy:
                                # 🚨 사전 잔고 체크
                                if self.current_balance < 50000:  # 최소 5만원
                                    print(f"❌ 잔고 부족으로 매수 포기: ₩{self.current_balance:,.0f}")
                                    should_buy = False
                                    rejection_reason = f"잔고 부족: ₩{self.current_balance:,.0f}"
                                else:
                                    print(f"💰 매수 시도 - 현재 잔고: ₩{self.current_balance:,.0f}")
                                    
                                    # 🚨 간단한 포지션 사이징
                                    coin_amount, total_cost, final_investment_ratio, position_adjustments = simple_position_sizing(
                                        price, final_confidence, self.current_balance
                                    )
                                    
                                    # 🚨 추가 안전 검증
                                    if total_cost > 0 and coin_amount > 0 and total_cost < self.current_balance:
                                        # 🚨 안전한 매수 실행
                                        old_balance = self.current_balance
                                        
                                        self.coin_amount = coin_amount
                                        self.current_balance -= total_cost  
                                        self.total_fees_paid += position_adjustments.get('fee', 0)
                                        
                                        in_position = True
                                        entry_price = price
                                        entry_date = timestamp_str
                                        entry_amount_krw = total_cost  
                                        actual_buy_count += 1
                                        
                                        # 조정된 익절/손절 적용
                                        profit_target = profit_target_ai
                                        stop_loss = stop_loss_ai
                                        
                                        strong_buy_signals += 1
                                        print(f"✅ 매수 실행 성공! (#{actual_buy_count})")
                                        print(f"  ├─ 총 지출: ₩{total_cost:,.0f}")
                                        print(f"  ├─ 코인수량: {coin_amount:.8f} BTC")
                                        print(f"  ├─ 현재 잔고: ₩{self.current_balance:,.0f}")
                                        print(f"  └─ 신뢰도: {final_confidence:.2f}")
                                        
                                        backtest_results.append({
                                            'date': timestamp_str,
                                            'datetime': timestamp,
                                            'price': price,
                                            'ai_decision': final_ai_decision,
                                            'actual_decision': 'BUY',
                                            'profit_pct': 0.0,
                                            'confidence': final_confidence,
                                            'market_trend': market_trend,
                                            'profit_target': profit_target,
                                            'stop_loss': stop_loss,
                                            'entry_price': entry_price,
                                            'entry_date': entry_date,
                                            'total_cost': total_cost,  
                                            'coin_amount': coin_amount,
                                            'balance': self.current_balance,
                                            'portfolio_value': self.current_balance + (coin_amount * price),
                                            'fees_paid': position_adjustments.get('fee', 0),
                                            'fear_greed_index': self.fear_greed_index,
                                            'integrated_score': integrated_decision['total_score'],
                                            'rag_approved': True
                                        })
                                    else:
                                        should_buy = False
                                        rejection_reason = "포지션 사이징 실패"
                                        print(f"❌ 포지션 사이징 실패: total_cost={total_cost}, coin_amount={coin_amount}")
                            
                            # 거부된 경우 결과 기록
                            if not should_buy:
                                print(f"❌ 매수 거부: {rejection_reason if 'rejection_reason' in locals() else '통합 결정 거부'}")
                                
                                backtest_results.append({
                                    'date': timestamp_str,
                                    'datetime': timestamp,
                                    'price': price,
                                    'ai_decision': final_ai_decision,
                                    'actual_decision': 'HOLD_RAG_APPROVED',
                                    'profit_pct': 0.0,
                                    'confidence': final_confidence,
                                    'market_trend': market_trend,
                                    'balance': self.current_balance,
                                    'portfolio_value': self.current_balance,
                                    'rejection_reason': rejection_reason if 'rejection_reason' in locals() else "통합 결정 거부",
                                    'fear_greed_index': self.fear_greed_index,
                                    'integrated_score': integrated_decision['total_score'],
                                    'rag_approved': True
                                })
                    
                    else:
                        # ❌ RAG 거부된 경우
                        rag_rejected_count += 1
                        # print(f"🚫 RAG 트리거 거부 #{rag_rejected_count}: {rag_reason}")
                        
                        # RAG 거부 결과도 기록 (통계용)
                        backtest_results.append({
                            'date': timestamp_str,
                            'datetime': timestamp,
                            'price': price,
                            'ai_decision': 'NONE',
                            'actual_decision': 'RAG_REJECTED',
                            'profit_pct': 0.0,
                            'confidence': 0.0,
                            'balance': self.current_balance,
                            'portfolio_value': self.current_balance,
                            'rag_rejection_reason': rag_reason,
                            'rag_approved': False
                        })
            
            # 다음 날짜로 이동
            current_date += datetime.timedelta(days=1)
        
        # 백테스트 완료 후 최종 통계
        print(f"\n🎉 === RAG 기반 선별적 백테스트 완료 ===")
        print(f"처리 기간: {start_date} ~ {end_date}")
        print(f"RAG 승인: {rag_approved_count}회")
        print(f"RAG 거부: {rag_rejected_count}회")
        print(f"승인율: {rag_approved_count/(rag_approved_count+rag_rejected_count)*100:.1f}%")
        print(f"총 AI 호출: {ai_calls_count}회")
        print(f"강한 매수 신호: {strong_buy_signals}회")
        print(f"🚨 실제 매수 실행: {actual_buy_count}회")  # 🚨 중요 지표 추가
        print(f"컨펌된 신호: {confirmed_signals}회")
        print(f"총 수수료: ₩{getattr(self, 'total_fees_paid', 0):,.0f}")
        
        # 🚨 매수가 전혀 없는 경우 경고
        if actual_buy_count == 0:
            print(f"🚨🚨🚨 경고: 실제 매수가 전혀 실행되지 않았습니다!")
            print(f"  - 매수 조건이 너무 까다로울 수 있습니다")
            print(f"  - AI 신뢰도 임계값을 낮춰보세요")
            print(f"  - 잔고 부족 문제를 확인하세요")
        
        # 최종 포트폴리오 가치 계산
        final_price = price if 'price' in locals() else self.initial_balance / 1000000
        final_portfolio_value = self.current_balance + (self.coin_amount * final_price)
        total_return_pct = ((final_portfolio_value / self.initial_balance) - 1) * 100
        
        print(f"💰 최종 결과:")
        print(f"  ├─ 현금 잔고: ₩{self.current_balance:,.0f}")
        print(f"  ├─ 코인 보유: {self.coin_amount:.8f} BTC")
        print(f"  ├─ 최종 포트폴리오: ₩{final_portfolio_value:,.0f}")
        print(f"  └─ 총 수익률: {total_return_pct:.2f}%")
        
        # RAG 효과 분석
        if rag_approved_count + rag_rejected_count > 0:
            efficiency_pct = (rag_rejected_count/(rag_approved_count+rag_rejected_count))*100
            print(f"📊 RAG 선별 효과:")
            print(f"  ├─ 기존 방식: 모든 트리거에서 AI 호출")
            print(f"  ├─ 새 방식: {rag_approved_count}번만 AI 호출 ({rag_rejected_count}번 거부)")
            print(f"  └─ 효율성: {efficiency_pct:.1f}% 불필요한 호출 제거")
        
        # RAG 패턴 데이터 저장
        try:
            self.save_rag_patterns()
            print("✅ 강화된 RAG 패턴 데이터 저장 완료")
        except Exception as e:
            print(f"❌ RAG 패턴 저장 실패: {str(e)}")
        
        return backtest_results





    
    
    def calculate_holding_days(self, entry_date, exit_date):
        """
        두 날짜 사이의 일수를 계산하는 함수
        
        Args:
            entry_date (str): 진입 날짜 (YYYY-MM-DD 또는 YYYY-MM-DD HH:MM:SS 형식)
            exit_date (str): 종료 날짜 (YYYY-MM-DD 또는 YYYY-MM-DD HH:MM:SS 형식)
            
        Returns:
            int: 보유 기간(일)
        """
        try:
            # 날짜 포맷 정규화 (시간 부분이 있는 경우 처리)
            if isinstance(entry_date, str) and ' ' in entry_date:
                entry_date = entry_date.split(' ')[0]
            if isinstance(exit_date, str) and ' ' in exit_date:
                exit_date = exit_date.split(' ')[0]
            
            entry_dt = pd.to_datetime(entry_date)
            exit_dt = pd.to_datetime(exit_date)
            
            # 날짜 차이 계산
            delta = exit_dt - entry_dt
            return max(0, delta.days)
        except Exception as e:
            print(f"날짜 계산 오류: {str(e)}")
            return 0



    def _load_reference_data(self, start_date):
        """지표 계산용 과거 데이터만 로드 (백테스트 데이터와 분리)"""
        print("지표 계산용 과거 데이터 로드 중...")
        pre_start_date = start_date - datetime.timedelta(days=30)
        print(f"참조 데이터 기간: {pre_start_date.strftime('%Y-%m-%d')} ~ {start_date.strftime('%Y-%m-%d')}")
        
        try:
            pre_data = pyupbit.get_ohlcv(
                "KRW-BTC", 
                interval="day", 
                count=30, 
                to=start_date.strftime('%Y-%m-%d')
            )
            
            if pre_data is not None and not pre_data.empty:
                # historical_data 초기화
                self.historical_data = []
                
                # 과거 데이터를 historical_data에 추가
                for timestamp, row in pre_data.iterrows():
                    # 중요: 이 데이터는 참조용이므로 처리된 타임스탬프에 추가하지 않음
                    data_point = {
                        'date': timestamp.strftime('%Y-%m-%d'),
                        'datetime': timestamp,
                        'price': row['close'],
                        'close': row['close'],
                        'open': row['open'],
                        'high': row['high'],
                        'low': row['low'],
                        'volume': row['volume'],
                        'reference_only': True  # 참조용 플래그 추가
                    }
                    self.historical_data.append(data_point)
                
                print(f"참조용 과거 데이터 로드 완료: {len(self.historical_data)}일")
            else:
                print("참조용 과거 데이터 로드 실패")
                self.historical_data = []
        except Exception as e:
            print(f"참조용 과거 데이터 로드 오류: {str(e)}")
            self.historical_data = []    

    

    def _run_backtest_legacy(self, data, test_mode=False, llm_mode=True, initial_position=False):
        """
        기존 백테스트 로직 (호환성 유지)
        """
        import time  # 시간 측정용 추가
        
        print(f"Starting news-enhanced backtest with {len(data)} days of data...")
        print(f"LLM mode: {llm_mode}, Initial position: {initial_position}")
        
        # ===== NEW: 백테스트 시작 전 전체 기간 뉴스 수집 및 분석 =====
        if hasattr(data, 'index') and len(data) > 0:
            start_date = data.index[0] if isinstance(data.index[0], pd.Timestamp) else pd.to_datetime(data.iloc[0]['date'])
            end_date = data.index[-1] if isinstance(data.index[-1], pd.Timestamp) else pd.to_datetime(data.iloc[-1]['date'])
            
            print("Collecting news data for the entire backtest period...")
            self.collect_all_news_for_period(start_date, end_date)
            
            print("Analyzing news-price correlations...")
            # Convert DataFrame to list of dicts for correlation analysis
            minute_data_list = []
            for index, row in data.iterrows():
                minute_data_list.append({
                    'datetime': index if isinstance(index, pd.Timestamp) else pd.to_datetime(index),
                    'close': row['close'],
                    'open': row.get('open', row['close']),
                    'high': row.get('high', row['close']),
                    'low': row.get('low', row['close']),
                    'volume': row.get('volume', 0)
                })
            self.analyze_news_price_correlations(minute_data_list)
        
        # ===== 핵심 추가: 백테스트 시작 전 과거 30일 데이터 미리 로드 =====
        print("백테스트 시작 전 과거 데이터 로드 중...")
        
        # 백테스트 첫 날짜 확인
        first_date = data.index[0] if isinstance(data.index[0], pd.Timestamp) else pd.to_datetime(data.iloc[0]['date'])
        
        # 30일 전 날짜 계산
        pre_start_date = first_date - datetime.timedelta(days=35)  # 여유있게 35일
        
        # 과거 데이터 가져오기
        try:
            pre_data = pyupbit.get_ohlcv("KRW-BTC", interval="day", count=100, to=first_date.strftime('%Y-%m-%d'))  # 35 → 100으로 변경
            
            if pre_data is not None and not pre_data.empty:
                # historical_data 초기화
                self.historical_data = []
                
                # 과거 데이터를 historical_data에 추가
                for timestamp, row in pre_data.iterrows():
                    data_point = {
                        'date': timestamp.strftime('%Y-%m-%d'),
                        'datetime': timestamp,
                        'price': row['close'],
                        'close': row['close'],
                        'open': row['open'],
                        'high': row['high'],
                        'low': row['low'],
                        'volume': row['volume']
                    }
                    self.historical_data.append(data_point)
                
                print(f"과거 데이터 로드 완료: {len(self.historical_data)}일")
            else:
                print("과거 데이터 로드 실패, 빈 리스트로 초기화")
                self.historical_data = []
        except Exception as e:
            print(f"과거 데이터 로드 오류: {str(e)}")
            self.historical_data = []

        # 시뮬레이션 변수 초기화
        backtest_results = []
        in_position = False  # 초기 포지션은 항상 False로 시작 (중요 수정)
        entry_price = 0.0
        entry_date = None
        profit_target = 5.0
        stop_loss = -2.0
        trailing_stop = 1.0
        self.trailing_stop_price = 0.0
        
        # 시간 측정 초기화
        total_llm_time = 0
        llm_calls = 0
        
        # 연속 손실 관리를 위한 변수 초기화
        self.consecutive_losses = 0
        self.stop_loss_streak = 0
        self.cooldown_until = -1
        self.recovery_factor = 1.0
        
        # 이전 백테스트 결과 저장 (컨텍스트 제공용)
        self.backtest_results = []
        
        # 백테스트용 historical_data 관리
        original_historical_data = self.historical_data.copy() if hasattr(self, 'historical_data') else []
        self.historical_data = []  # 백테스트 진행 중 점진적으로 채워짐
        
        # 진행률 표시용 변수
        total_days = len(data)
        progress_step = max(1, int(total_days / 10))
        
        # 중간 저장 주기 (시간마다 결과 저장)
        last_save_time = time.time()
        save_interval = 3600  # 1시간마다 저장
        
        # 데이터 변환 - DataFrame이 아닌 경우 처리
        if not isinstance(data, pd.DataFrame):
            if isinstance(data, list) and len(data) > 0:
                try:
                    # 리스트를 DataFrame으로 변환
                    data = pd.DataFrame(data)
                except Exception as e:
                    print(f"Error converting data to DataFrame: {str(e)}")
                    return []
            else:
                print("Invalid data format. Expected DataFrame or list of dictionaries.")
                return []
        
        # 인덱스 리셋 - Timestamp 인덱스 문제 해결
        try:
            data = data.reset_index(drop=False)
        except Exception as e:
            print(f"Warning: Could not reset DataFrame index: {str(e)}")
        
        # 일별 데이터 처리
        for idx, (_, row) in enumerate(data.iterrows()):
            # 테스트 모드에서는 일부 데이터만 처리
            if test_mode and idx > 10:
                break
            
            # 진행률 출력
            if idx % progress_step == 0:
                progress = (idx / total_days) * 100
                print(f"Processing {progress:.1f}% complete... ({idx}/{total_days})")
                
                # 주기적 저장 (1시간마다)
                current_time = time.time()
                if current_time - last_save_time > save_interval:
                    try:
                        # 중간 결과 저장
                        temp_file = f"backtest_results/temp_results_{int(current_time)}.json"
                        print(f"Saving intermediate results to {temp_file}...")
                        
                        # 기본 정보만 저장 (용량 축소)
                        simplified_results = []
                        for day in backtest_results:
                            simplified_day = {k: v for k, v in day.items() if k not in ['technical_indicators', 'analysis']}
                            simplified_results.append(simplified_day)
                        
                        with open(temp_file, 'w', encoding='utf-8') as f:
                            json.dump(simplified_results, f, ensure_ascii=False, indent=2)
                        
                        last_save_time = current_time
                        print("Intermediate results saved successfully")
                    except Exception as e:
                        print(f"Error saving intermediate results: {str(e)}")
            
            # 날짜 및 가격 추출
            date = None
            price = None
            
            # 날짜 필드 확인 (수정: 실제 날짜 사용)
            if 'date' in row:
                date = row['date']
            elif 'Date' in row:
                date = row['Date']
            elif 'datetime' in row:
                date = row['datetime']
            elif 'index' in row and isinstance(row['index'], (pd.Timestamp, datetime.datetime)):
                date = row['index'].strftime('%Y-%m-%d')
            else:
                # 날짜 필드가 없는 경우 인덱스를 문자열로 변환
                date = str(idx)
            
            # 가격 필드 확인
            if 'close' in row:
                price = row['close']
            elif 'price' in row:
                price = row['price']
            elif 'Close' in row:
                price = row['Close']
            elif 'Price' in row:
                price = row['Price']
            else:
                print(f"Warning: No price data found for {date}, skipping...")
                continue
                    
            # 문자열로 저장된 가격 처리
            if isinstance(price, str):
                try:
                    price = float(price.replace(',', ''))
                except (ValueError, TypeError):
                    print(f"Error converting price to float: {price}")
                    continue
            
            # 현재 데이터를 historical_data에 추가
            current_data = {
                'date': date,
                'datetime': pd.to_datetime(date) if isinstance(date, str) else date,
                'price': price,
                'close': price,
                'open': row.get('open', price),
                'high': row.get('high', price),
                'low': row.get('low', price),
                'volume': row.get('volume', 0)
            }
            self.historical_data.append(current_data)
            
            # 기술적 지표 계산 추가 (중요 수정)
            if len(self.historical_data) > 14:  # RSI 등을 계산하기 위한 최소 데이터
                # self.historical_data를 DataFrame으로 변환하여 기술적 지표 계산
                temp_data = []
                for item in self.historical_data[-30:]:  # 최근 30일 데이터만 사용
                    temp_data.append({
                        'close': item['close'],
                        'open': item.get('open', item['close']),
                        'high': item.get('high', item['close']),
                        'low': item.get('low', item['close']),
                        'volume': item.get('volume', 0)
                    })
                temp_df = pd.DataFrame(temp_data)
                temp_df, tech_indicators = self.calculate_technical_indicators(temp_df)
            else:
                # 아직 충분한 데이터가 없는 경우 빈 기술적 지표 사용
                tech_indicators = {}
                    
            # 뉴스 데이터 수집
            current_date_obj = pd.to_datetime(date) if isinstance(date, str) else datetime.datetime.now()
            one_day_before = current_date_obj - datetime.timedelta(days=1)
            try:
                news_data = self.fetch_news("BTC", one_day_before, current_date_obj)
                news_count = len(news_data)
            except:
                news_data = []
                news_count = 0
            
            # 뉴스 감성 분석
            news_sentiment = self.analyze_news_sentiment(news_data)
            
            # LLM 항상 호출하도록 수정
            decision = "HOLD"
            confidence = 0.5
            profit_target_new = 5.0
            stop_loss_new = -2.0
            trailing_stop_new = 1.0
            market_trend = "Unknown"
            analysis = ""
            reasoning = ""
            
            if llm_mode:
                # 이전 컨텍스트를 백테스트 결과에 저장
                if len(backtest_results) > 0:
                    self.backtest_results = backtest_results.copy()
                
                try:
                    print(f"날짜 {date}: LLM 분석 중...")  # 로그 추가
                    start_time = time.time()  # 시간 측정 시작
                    
                    analysis_result = self.analyze_with_llm("BTC/KRW", price, tech_indicators, news_data, test_mode)
                    
                    elapsed = time.time() - start_time  # 소요 시간 계산
                    print(f"LLM 분석 완료: {elapsed:.2f}초 소요")
                    
                    # 시간 통계 업데이트
                    total_llm_time += elapsed
                    llm_calls += 1
                    
                    # 결과 처리
                    decision = analysis_result.get('signal', 'HOLD')
                    confidence = analysis_result.get('confidence', 0.5)
                    profit_target_new = analysis_result.get('profit_target', 5.0)
                    stop_loss_new = analysis_result.get('stop_loss', -2.0)
                    trailing_stop_new = analysis_result.get('trailing_stop', 1.0)
                    market_trend = analysis_result.get('market_trend', 'Unknown')
                    analysis = analysis_result.get('analysis', '')
                    reasoning = analysis_result.get('reasoning', '')
                    news_sentiment = analysis_result.get('news_sentiment', news_sentiment)
                    
                    print(f"AI 분석 결과: {decision} (신뢰도: {confidence:.2f})")
                    print(f"조정: 목표가={profit_target_new}%, 손절가={stop_loss_new}%, 트레일링={trailing_stop_new}%")
                    if reasoning:
                        print(f"추론: {reasoning[:1000]}...")
                except Exception as e:
                    print(f"Error in LLM analysis: {str(e)}")
                    decision = "HOLD"  # 오류 시 기본값 사용
            else:
                # LLM 모드가 아닌 경우 기존 로직 유지
                if 'decision' in row:
                    decision = row['decision']
                elif 'ai_decision' in row:
                    decision = row['ai_decision']
                elif 'signal' in row:
                    decision = row['signal']
                
                confidence = row.get('confidence', 0.5)
                profit_target_new = row.get('profit_target', 5.0)
                stop_loss_new = row.get('stop_loss', -2.0)
                trailing_stop_new = row.get('trailing_stop', 1.0)
                market_trend = row.get('market_trend', 'Unknown')
            
            # 매수/매도 결정
            should_buy = False
            should_sell = False
            
            # RSI 값 확인
            rsi = None
            if 'RSI(14)' in tech_indicators:
                try:
                    rsi = float(str(tech_indicators['RSI(14)']).replace(',', ''))
                except:
                    pass
            
            # 매수 조건 체크 (지지선 조건 포함)
            if not in_position and decision == "BUY":
                # 쿨다운 체크
                if hasattr(self, 'cooldown_until') and idx <= self.cooldown_until:
                    print(f"Skipping BUY signal on {date} due to cooldown period")
                # RSI 기반 과매수 체크 (85 → 90으로 완화)
                elif rsi is not None and rsi > 90:
                    print(f"Skipping BUY signal on {date} due to extreme overbought condition (RSI > 90)")
                # 연속 손실 체크 (조건 완화)
                elif hasattr(self, 'consecutive_losses') and self.consecutive_losses >= 4 and "strong downtrend" in market_trend.lower():  # 3 → 4로 변경
                    print(f"Skipping BUY signal on {date} during strong downtrend with {self.consecutive_losses} consecutive losses")
                # 신뢰도 필터링 (0.3 → 0.2로 완화)
                elif confidence < 0.2:
                    print(f"Skipping BUY signal on {date} due to very low confidence: {confidence}")
                # 지지선 조건 개선 - 다중 조건 사용
                else:
                    # 지지선 체크
                    support_analysis = self._check_near_support_level_enhanced("KRW-BTC", price)
                    
                    # 여러 조건 중 하나만 만족하면 매수
                    conditions_met = False
                    reasons = []
                    
                    # 조건 1: 지지선 근처 (강도 0.4 이상)
                    if support_analysis['is_near_support'] and support_analysis['strength'] >= 0.4:
                        conditions_met = True
                        reasons.append(f"Near support (strength: {support_analysis['strength']:.2f})")
                    
                    # 조건 2: RSI 과매도 (35 → 40으로 완화)
                    if rsi is not None and rsi < 40:
                        conditions_met = True
                        reasons.append(f"RSI oversold ({rsi:.1f})")
                    
                    # 조건 3: 높은 신뢰도 (0.7 → 0.6으로 완화)
                    if confidence >= 0.6:
                        conditions_met = True
                        reasons.append(f"High confidence ({confidence:.2f})")
                    
                    # 조건 4: 강한 상승 뉴스 (추가)
                    if news_sentiment['impact_level'] == "high" and news_sentiment['sentiment_score'] > 0.5:
                        conditions_met = True
                        reasons.append("Strong positive news")
                    
                    # 조건 5: 이전 지지선 근처 (추가)
                    if support_analysis['distance_percent'] is not None and support_analysis['distance_percent'] <= 3.0:
                        conditions_met = True
                        reasons.append(f"Close to support ({support_analysis['distance_percent']:.1f}%)")
                    
                    if conditions_met:
                        reason_str = " & ".join(reasons)
                        print(f"BUY signal approved: {reason_str}")
                        should_buy = True
                    else:
                        print(f"BUY signal rejected: No conditions met (support strength: {support_analysis.get('strength', 0):.2f}, RSI: {rsi}, confidence: {confidence:.2f})")
                        should_buy = False
                                
            if in_position and decision == "SELL":
                # 과매도 상태에서의 매도 신호 제한
                if rsi is not None and rsi < 15:
                    print(f"Considering SELL signal on {date} carefully due to extreme oversold condition (RSI < 15)")
                    # 신뢰도 낮은 경우 스킵
                    if confidence < 0.5:
                        should_sell = False
                    else:
                        should_sell = True
                # 뉴스 감성이 매우 긍정적인 경우 매도 신호 필터링 
                elif news_sentiment['impact_level'] == "high" and news_sentiment['sentiment_score'] > 0.6:
                    print(f"Skipping SELL signal on {date} due to highly positive news sentiment")
                    should_sell = False
                else:
                    should_sell = True
            
            # 포지션 관리
            if in_position:
                # 수익률 계산
                profit_pct = ((price / entry_price) - 1) * 100
                
                # 트레일링 스탑 체크
                if hasattr(self, 'trailing_stop_price') and self.trailing_stop_price > 0:
                    if price <= self.trailing_stop_price:
                        print(f"TRAILING STOP triggered on {date}: Sell at {price}, profit: {profit_pct:.2f}%")
                        in_position = False
                        
                        # 손익 카운터 업데이트
                        loss_state = self.manage_consecutive_losses(profit_pct, idx)
                        print(f"Loss management state: {loss_state}")
                        
                        # 지지선 정보 포함하여 결과 기록
                        support_analysis = self._check_near_support_level_enhanced("KRW-BTC", price)
                        backtest_results.append({
                            'date': date,
                            'price': price,
                            'ai_decision': decision,
                            'actual_decision': 'SELL_TRAILING',
                            'profit_pct': profit_pct,
                            'confidence': confidence,
                            'market_trend': market_trend,
                            'profit_target': profit_target,
                            'stop_loss': stop_loss,
                            'trailing_stop': trailing_stop,
                            'entry_price': entry_price,
                            'entry_date': entry_date,
                            'technical_indicators': tech_indicators,
                            'news_count': news_count,
                            'news_sentiment': news_sentiment,
                            'analysis': analysis,
                            'reasoning': reasoning,
                            'support_analysis': support_analysis,  # 새로 추가
                            'support_strength': support_analysis.get('strength', 0)  # 새로 추가
                        })
                        continue
                
                # 목표가 도달 체크
                if profit_pct >= profit_target:
                    print(f"PROFIT TARGET reached on {date}: Sell at {price}, profit: {profit_pct:.2f}%")
                    in_position = False
                    
                    # 손익 카운터 업데이트
                    loss_state = self.manage_consecutive_losses(profit_pct, idx)
                    print(f"Loss management state: {loss_state}")
                    
                    # 지지선 정보 포함하여 결과 기록
                    support_analysis = self._check_near_support_level_enhanced("KRW-BTC", price)
                    backtest_results.append({
                        'date': date,
                        'price': price,
                        'ai_decision': decision,
                        'actual_decision': 'SELL_PROFIT',
                        'profit_pct': profit_pct,
                        'confidence': confidence,
                        'market_trend': market_trend,
                        'profit_target': profit_target,
                        'stop_loss': stop_loss,
                        'trailing_stop': trailing_stop,
                        'entry_price': entry_price,
                        'entry_date': entry_date,
                        'technical_indicators': tech_indicators,
                        'news_count': news_count,
                        'news_sentiment': news_sentiment,
                        'analysis': analysis,
                        'reasoning': reasoning,
                        'support_analysis': support_analysis,  # 새로 추가
                        'support_strength': support_analysis.get('strength', 0)  # 새로 추가
                    })
                    continue
                    
                # 손절가 도달 체크
                if profit_pct <= stop_loss:
                    print(f"STOP LOSS triggered on {date}: Sell at {price}, loss: {profit_pct:.2f}%")
                    in_position = False
                    
                    # 손익 카운터 업데이트
                    loss_state = self.manage_consecutive_losses(profit_pct, idx)
                    print(f"Loss management state: {loss_state}")
                    
                    # 지지선 정보 포함하여 결과 기록
                    support_analysis = self._check_near_support_level_enhanced("KRW-BTC", price)
                    backtest_results.append({
                        'date': date,
                        'price': price,
                        'ai_decision': decision,
                        'actual_decision': 'SELL_STOPLOSS',
                        'profit_pct': profit_pct,
                        'confidence': confidence,
                        'market_trend': market_trend,
                        'profit_target': profit_target,
                        'stop_loss': stop_loss,
                        'trailing_stop': trailing_stop,
                        'entry_price': entry_price,
                        'entry_date': entry_date,
                        'technical_indicators': tech_indicators,
                        'news_count': news_count,
                        'news_sentiment': news_sentiment,
                        'analysis': analysis,
                        'reasoning': reasoning,
                        'support_analysis': support_analysis,  # 새로 추가
                        'support_strength': support_analysis.get('strength', 0)  # 새로 추가
                    })
                    continue
                
                # 트레일링 스탑 업데이트
                if hasattr(self, 'trailing_stop_price') and price > self.trailing_stop_price * (1 + trailing_stop/100):
                    # 적응형 트레일링 스탑 계산
                    volatility = self.calculate_volatility(backtest_results)
                    self.trailing_stop_price = self.set_adaptive_trailing_stop(price, market_trend, volatility)
                    
                    if hasattr(self, 'debug_mode') and self.debug_mode:
                        print(f"Trailing stop updated to {self.trailing_stop_price:.2f} on {date}")
            
            # 매수 실행
            if should_buy:
                in_position = True
                entry_price = price
                entry_date = date
                profit_target = profit_target_new
                stop_loss = stop_loss_new
                trailing_stop = trailing_stop_new
                
                # 회복 계수를 기반으로 한 리스크 조정
                if hasattr(self, 'recovery_factor'):
                    # 낮은 회복 계수는 더 엄격한 리스크 관리를 의미
                    if self.recovery_factor < 0.5:
                        profit_target = max(3.0, profit_target * 0.8)  # 더 빠른 수익 실현
                        stop_loss = max(-1.5, stop_loss * 0.8)  # 더 타이트한 손절매
                
                # 적응형 트레일링 스탑 설정
                volatility = self.calculate_volatility(backtest_results)
                self.trailing_stop_price = self.set_adaptive_trailing_stop(price, market_trend, volatility)
                
                print(f"BUY executed on {date} at {price} (confidence: {confidence})")
                print(f"  Profit target: {profit_target}%, Stop loss: {stop_loss}%, Trailing stop: {trailing_stop}%")
                print(f"  Recovery factor: {getattr(self, 'recovery_factor', 1.0)}")
                
                # 지지선 정보 포함하여 결과 기록
                support_analysis = self._check_near_support_level_enhanced("KRW-BTC", price)
                backtest_results.append({
                    'date': date,
                    'price': price,
                    'ai_decision': decision,
                    'actual_decision': 'BUY',
                    'profit_pct': 0.0,
                    'confidence': confidence,
                    'market_trend': market_trend,
                    'profit_target': profit_target,
                    'stop_loss': stop_loss,
                    'trailing_stop': trailing_stop,
                    'entry_price': entry_price,
                    'entry_date': entry_date,
                    'technical_indicators': tech_indicators,
                    'news_count': news_count,
                    'news_sentiment': news_sentiment,
                    'analysis': analysis,
                    'reasoning': reasoning,
                    'recovery_factor': getattr(self, 'recovery_factor', 1.0),
                    'support_analysis': support_analysis,  # 새로 추가
                    'support_strength': support_analysis.get('strength', 0)  # 새로 추가
                })
                continue
                
            # 매도 실행
            if should_sell:
                profit_pct = ((price / entry_price) - 1) * 100
                print(f"SELL executed on {date} at {price}, profit: {profit_pct:.2f}%")
                in_position = False
                
                # 손익 카운터 업데이트
                loss_state = self.manage_consecutive_losses(profit_pct, idx)
                print(f"Loss management state: {loss_state}")
                
                # 지지선 정보 포함하여 결과 기록
                support_analysis = self._check_near_support_level_enhanced("KRW-BTC", price)
                backtest_results.append({
                    'date': date,
                    'price': price,
                    'ai_decision': decision,
                    'actual_decision': 'SELL',
                    'profit_pct': profit_pct,
                    'confidence': confidence,
                    'market_trend': market_trend,
                    'profit_target': profit_target,
                    'stop_loss': stop_loss,
                    'trailing_stop': trailing_stop,
                    'entry_price': entry_price,
                    'entry_date': entry_date,
                    'technical_indicators': tech_indicators,
                    'news_count': news_count,
                    'news_sentiment': news_sentiment,
                    'analysis': analysis,
                    'reasoning': reasoning,
                    'support_analysis': support_analysis,  # 새로 추가
                    'support_strength': support_analysis.get('strength', 0)  # 새로 추가
                })
                continue
            
            # 그 외 일반 거래일 기록 (지지선 정보 포함)
            support_analysis = self._check_near_support_level_enhanced("KRW-BTC", price)
            backtest_results.append({
                'date': date,
                'price': price,
                'ai_decision': decision,
                'actual_decision': 'HOLD',
                'profit_pct': ((price / entry_price) - 1) * 100 if in_position else 0.0,
                'confidence': confidence,
                'market_trend': market_trend,
                'profit_target': profit_target if in_position else profit_target_new,
                'stop_loss': stop_loss if in_position else stop_loss_new,
                'trailing_stop': trailing_stop if in_position else trailing_stop_new,
                'entry_price': entry_price if in_position else 0.0,
                'entry_date': entry_date if in_position else None,
                'technical_indicators': tech_indicators,
                'news_count': news_count,
                'news_sentiment': news_sentiment,
                'analysis': analysis,
                'reasoning': reasoning,
                'in_position': in_position,
                'support_analysis': support_analysis,  # 새로 추가
                'support_strength': support_analysis.get('strength', 0)  # 새로 추가
            })
            
            # 적응형 트레일링 스탑 주기적 업데이트 (포지션 있는 경우)
            if in_position and idx % 3 == 0:  # 3일마다 업데이트
                volatility = self.calculate_volatility(backtest_results)
                new_trailing_stop = self.set_adaptive_trailing_stop(price, market_trend, volatility)
                
                # 새 트레일링 스탑이 현재보다 높을 경우에만 업데이트 (하락 방지)
                if new_trailing_stop > self.trailing_stop_price:
                    self.trailing_stop_price = new_trailing_stop
                    if hasattr(self, 'debug_mode') and self.debug_mode:
                        print(f"Periodic trailing stop update to {self.trailing_stop_price:.2f} on {date}")
        
        # 백테스트 완료 후 original_historical_data 복원
        if original_historical_data:
            self.historical_data = original_historical_data
        
        # 백테스트 마무리 - LLM 성능 통계 추가
        avg_llm_time = total_llm_time / llm_calls if llm_calls > 0 else 0
        print(f"Backtest complete. Processed {len(backtest_results)} days.")
        print(f"LLM 성능: 총 {llm_calls}회 호출, 평균 {avg_llm_time:.2f}초/호출, 총 처리 시간 {total_llm_time:.2f}초")
        
        # 뉴스 통계 출력 (NEW)
        if hasattr(self, 'news_database'):
            total_news = sum(len(news_list) for news_list in self.news_database.values())
            print(f"뉴스 활용: 총 {total_news}개 뉴스, {len(self.news_database)}일간 수집")
        
        # 현재 포지션 상태 출력
        if in_position:
            last_price = backtest_results[-1]['price'] if backtest_results else 0
            entry_profit = ((last_price / entry_price) - 1) * 100 if entry_price > 0 else 0
            print(f"Still in position at end of backtest: Entry price: {entry_price}, Current price: {last_price}")
            print(f"Unrealized P/L: {entry_profit:.2f}%")
        else:
            print("No open position at end of backtest.")
        
        # 인기있는 트레이딩 패턴 분석
        profitable_patterns = self.identify_profitable_patterns(backtest_results)
        if profitable_patterns:
            print("\n=== 수익성 높은 트레이딩 패턴 TOP 3 ===")
            for i, pattern in enumerate(profitable_patterns[:3]):
                print(f"{i+1}. {pattern['description']}")
                print(f"   평균 수익률: {pattern['avg_profit']:.2f}%, 거래 횟수: {pattern['trade_count']}")
        
        # LLM 통계 정보 추가
        backtest_summary = {
            'llm_calls': llm_calls,
            'avg_llm_time': avg_llm_time,
            'total_llm_time': total_llm_time,
            'days_processed': len(backtest_results),
            'news_articles_processed': total_news if hasattr(self, 'news_database') else 0,  # NEW
            'news_days_covered': len(self.news_database) if hasattr(self, 'news_database') else 0  # NEW
        }
        
        # 최종 백테스트 결과와 요약 정보 저장
        try:
            final_result_file = f"backtest_results/final_results_{int(time.time())}.json"
            with open(final_result_file, 'w', encoding='utf-8') as f:
                json.dump({
                    'summary': backtest_summary,
                    'patterns': profitable_patterns[:10] if profitable_patterns else [],
                    # 전체 결과는 용량 문제로 저장하지 않음
                }, f, ensure_ascii=False, indent=2)
            print(f"Final summary saved to {final_result_file}")
        except Exception as e:
            print(f"Error saving final summary: {str(e)}")
        
        return backtest_results

    
    
    def evaluate_backtest(self, backtest_results, initial_balance=10000000, initial_position=False):
        """
        🚨 필드명 불일치 문제 해결된 백테스트 평가 함수
        """
        import numpy as np
        import time
        
        if not backtest_results or len(backtest_results) == 0:
            print("No backtest results to evaluate")
            return None
        
        start_time = time.time()
        print(f"🔍 수정된 백테스트 평가 시작: {len(backtest_results)}개 데이터 포인트")
        
        # 포트폴리오 추적 변수 초기화
        current_balance = initial_balance
        coin_amount = 0.0
        peak_equity = initial_balance
        
        # 거래 분석을 위한 변수
        total_trades = 0
        winning_trades = 0
        losing_trades = 0
        trade_history = []
        current_position = None
        
        # 에퀴티 커브 추적
        equity_curve = []
        max_drawdown_pct = 0
        
        print(f"초기 설정: 잔고=₩{current_balance:,.0f}, 코인={coin_amount:.8f}")
        
        # 🚨 필드명 매핑 함수
        def get_investment_amount(result):
            """백테스트 결과에서 투자금액 추출 (여러 필드명 지원)"""
            return (result.get('total_cost', 0) or 
                    result.get('investment_amount', 0) or 
                    result.get('entry_amount_krw', 0))
        
        def get_fee_paid(result):
            """백테스트 결과에서 수수료 추출 (여러 필드명 지원)"""
            return (result.get('fees_paid', 0) or 
                    result.get('fee', 0) or 
                    result.get('entry_fee', 0))
        
        # 각 백테스트 결과 처리
        for i, result in enumerate(backtest_results):
            decision = result.get('actual_decision', 'HOLD')
            price = result.get('price', 0)
            date = result.get('date', '')
            
            # 🚨 수정된 매수 처리 - 다양한 필드명 지원
            if decision == 'BUY' and current_balance > 0:
                # ✅ 여러 필드명 시도해서 데이터 추출
                investment_amount = get_investment_amount(result)
                coin_bought = result.get('coin_amount', 0)
                fee_paid = get_fee_paid(result)
                
                print(f"🔍 매수 데이터 확인 [{i}]:")
                print(f"  ├─ investment_amount: {investment_amount}")
                print(f"  ├─ coin_amount: {coin_bought}")
                print(f"  ├─ fee_paid: {fee_paid}")
                print(f"  └─ total_cost 필드: {result.get('total_cost', 'NONE')}")
                
                # ✅ 실제 데이터가 있는 경우만 처리
                if investment_amount > 0 and coin_bought > 0:
                    current_position = {
                        'entry_date': date,
                        'entry_price': price,
                        'entry_amount_krw': investment_amount,
                        'coin_amount': coin_bought,
                        'fee_paid': fee_paid
                    }
                    
                    # ✅ 정확한 금액 차감
                    current_balance = current_balance - investment_amount
                    coin_amount = coin_bought
                    
                    print(f"✅ 매수 처리 완료: {date}")
                    print(f"  ├─ 가격: ₩{price:,.0f}")
                    print(f"  ├─ 투자금: ₩{investment_amount:,.0f}")
                    print(f"  ├─ 코인수량: {coin_bought:.8f}")
                    print(f"  ├─ 수수료: ₩{fee_paid:,.0f}")
                    print(f"  └─ 남은잔고: ₩{current_balance:,.0f}")
                else:
                    print(f"❌ 매수 데이터 부족: {date}")
                    print(f"  ├─ investment_amount: {investment_amount}")
                    print(f"  └─ coin_amount: {coin_bought}")
            
            # 🚨 수정된 매도 처리
            elif decision in ['SELL', 'SELL_PROFIT', 'SELL_TRAILING', 'SELL_STOPLOSS', 'SELL_TIMEOUT'] and coin_amount > 0:
                profit_pct = result.get('profit_pct', 0)
                profit_amount = result.get('profit_amount', 0)
                
                print(f"🔍 매도 데이터 확인 [{i}]:")
                print(f"  ├─ 결정: {decision}")
                print(f"  ├─ 수익률: {profit_pct:.2f}%")
                print(f"  ├─ 수익금: ₩{profit_amount:,.0f}")
                print(f"  └─ 보유코인: {coin_amount:.8f}")
                
                # current_position 정보로 거래 기록
                if current_position:
                    final_amount = current_position['entry_amount_krw'] + profit_amount
                    
                    trade_history.append({
                        'type': decision,
                        'entry_date': current_position['entry_date'],
                        'exit_date': date,
                        'entry_price': current_position['entry_price'],
                        'exit_price': price,
                        'profit_pct': profit_pct,
                        'profit_amount': profit_amount,
                        'entry_amount': current_position['entry_amount_krw'],
                        'exit_amount': final_amount,
                        'total_fees': current_position.get('fee_paid', 0)
                    })
                    
                    print(f"✅ 매도 처리 완료: {date}")
                    print(f"  ├─ 진입가: ₩{current_position['entry_price']:,.0f}")
                    print(f"  ├─ 매도가: ₩{price:,.0f}")
                    print(f"  ├─ 투자원금: ₩{current_position['entry_amount_krw']:,.0f}")
                    print(f"  ├─ 회수금액: ₩{final_amount:,.0f}")
                    print(f"  └─ 순수익: ₩{profit_amount:,.0f} ({profit_pct:.2f}%)")
                else:
                    print(f"❌ 매도 시 포지션 정보 없음: {date}")
                    # 기본 계산으로 처리
                    sell_amount_krw = coin_amount * price
                    fee = sell_amount_krw * 0.0005
                    final_amount = sell_amount_krw - fee
                    
                    trade_history.append({
                        'type': decision,
                        'entry_date': 'Unknown',
                        'exit_date': date,
                        'entry_price': 0,
                        'exit_price': price,
                        'profit_pct': profit_pct,
                        'profit_amount': final_amount,
                        'entry_amount': 0,
                        'exit_amount': final_amount,
                        'total_fees': fee
                    })
                
                # 포지션 정리
                current_balance += current_position['entry_amount_krw'] + profit_amount if current_position else final_amount
                coin_amount = 0
                current_position = None
                
                total_trades += 1
                if profit_pct > 0:
                    winning_trades += 1
                else:
                    losing_trades += 1
            
            # 현재 포트폴리오 가치 계산
            current_equity = current_balance + (coin_amount * price)
            
            # 최대 낙폭 계산
            if current_equity > peak_equity:
                peak_equity = current_equity
            elif peak_equity > 0:
                drawdown = ((current_equity / peak_equity) - 1) * 100
                max_drawdown_pct = min(max_drawdown_pct, drawdown)
            
            # 에퀴티 커브 기록
            if decision != 'HOLD' or len(equity_curve) == 0 or len(equity_curve) % 24 == 0:
                equity_curve.append({
                    'date': date,
                    'price': price,
                    'equity': current_equity,
                    'decision': decision,
                    'balance': current_balance,
                    'coin_amount': coin_amount
                })
        
        # 최종 계산
        if len(backtest_results) > 0:
            final_price = backtest_results[-1].get('price', 0)
            final_equity = current_balance + (coin_amount * final_price)
        else:
            final_equity = initial_balance
        
        # 미결제 포지션 처리
        unrealized_pnl = 0
        if coin_amount > 0 and current_position and final_price > 0:
            unrealized_pnl = ((final_price / current_position['entry_price']) - 1) * 100
            print(f"⚠️ 미결제 포지션 발견:")
            print(f"  ├─ 진입가: ₩{current_position['entry_price']:,.0f}")
            print(f"  ├─ 현재가: ₩{final_price:,.0f}")
            print(f"  └─ 미실현손익: {unrealized_pnl:.2f}%")
        
        # 성과 지표 계산
        win_rate = (winning_trades / total_trades * 100) if total_trades > 0 else 0
        total_return_pct = ((final_equity / initial_balance) - 1) * 100
        
        # 평균 수익/손실 계산
        avg_profit = 0
        avg_loss = 0
        if winning_trades > 0:
            winning_trades_data = [t for t in trade_history if t['profit_pct'] > 0]
            avg_profit = sum(t['profit_pct'] for t in winning_trades_data) / len(winning_trades_data)
        if losing_trades > 0:
            losing_trades_data = [t for t in trade_history if t['profit_pct'] <= 0]
            avg_loss = sum(t['profit_pct'] for t in losing_trades_data) / len(losing_trades_data)
        
        # 손익비 계산
        profit_factor = 0
        if trade_history:
            total_profit = sum(t['profit_amount'] for t in trade_history if t['profit_amount'] > 0)
            total_loss = abs(sum(t['profit_amount'] for t in trade_history if t['profit_amount'] < 0))
            if total_loss > 0:
                profit_factor = total_profit / total_loss
            elif total_profit > 0:
                profit_factor = float('inf')
        
        # 샤프 비율 계산
        sharpe_ratio = 0
        if len(trade_history) > 1:
            returns = [trade['profit_pct'] for trade in trade_history]
            if returns:
                mean_return = np.mean(returns)
                std_dev = np.std(returns) if len(returns) > 1 else 0.001
                if std_dev > 0:
                    sharpe_ratio = mean_return / std_dev
        
        execution_time = time.time() - start_time
        
        # 🚨 상세 거래 내역 출력
        print(f"\n📊 === 거래 내역 상세 ===")
        for i, trade in enumerate(trade_history, 1):
            print(f"거래 #{i}: {trade['entry_date']} → {trade['exit_date']}")
            print(f"  ├─ {trade['entry_price']:,.0f} → {trade['exit_price']:,.0f}")
            print(f"  ├─ 투자: ₩{trade['entry_amount']:,.0f}")
            print(f"  └─ 결과: ₩{trade['profit_amount']:,.0f} ({trade['profit_pct']:+.2f}%)")
        
        # 결과 출력
        print(f"\n💰 === 수정된 백테스트 평가 결과 ===")
        print(f"초기 자본: ₩{initial_balance:,.0f}")
        print(f"최종 자본: ₩{final_equity:,.0f}")
        print(f"현금 잔고: ₩{current_balance:,.0f}")
        print(f"코인 보유: {coin_amount:.8f} BTC (₩{coin_amount * final_price:,.0f})")
        print(f"총 수익률: {total_return_pct:.2f}%")
        print(f"최대 낙폭: {max_drawdown_pct:.2f}%")
        print(f"거래 횟수: {total_trades}")
        print(f"승률: {win_rate:.2f}%")
        print(f"평균 수익: {avg_profit:.2f}%")
        print(f"평균 손실: {avg_loss:.2f}%")
        print(f"손익비: {profit_factor:.2f}")
        print(f"샤프 비율: {sharpe_ratio:.2f}")
        
        return {
            'initial_balance': initial_balance,
            'final_balance': final_equity,
            'cash_balance': current_balance,
            'coin_amount': coin_amount,
            'final_price': final_price,
            'total_return': final_equity - initial_balance,
            'total_return_pct': total_return_pct,
            'max_drawdown_pct': max_drawdown_pct,
            'trade_count': total_trades,
            'winning_trades': winning_trades,
            'losing_trades': losing_trades,
            'win_rate': win_rate,
            'profit_factor': profit_factor,
            'sharpe_ratio': sharpe_ratio,
            'avg_profit': avg_profit,
            'avg_loss': avg_loss,
            'equity_curve': equity_curve,
            'trades': trade_history,
            'execution_time': execution_time,
            'unrealized_pnl_pct': unrealized_pnl
        }

    # 사용법:
    # 기존 함수 대신 이걸 사용하세요
    # results = trader.evaluate_backtest_fixed(backtest_results)

    
    import matplotlib.pyplot as plt
    import matplotlib.dates as mdates
    import pandas as pd
    import numpy as np
    from datetime import datetime
    import os

    def plot_backtest_results(results, trades_df=None, save_dir="backtest_results"):
        """
        백테스트 결과 시각화 함수 (수정된 버전)
        
        Parameters:
        - results: 백테스트 결과 딕셔너리
        - trades_df: 거래 내역 DataFrame (선택사항)
        - save_dir: 저장 디렉토리
        """
        try:
            # 저장 디렉토리 생성
            if not os.path.exists(save_dir):
                os.makedirs(save_dir)
            
            # Figure 설정
            plt.style.use('default')
            fig, axes = plt.subplots(2, 2, figsize=(16, 12))
            fig.suptitle(f'백테스트 결과 분석 - 수익률: {results.get("total_return", 0):.2f}%', 
                        fontsize=16, fontweight='bold')
            
            # 1. 포트폴리오 가치 변화 (좌상단)
            ax1 = axes[0, 0]
            if 'portfolio_values' in results and results['portfolio_values']:
                dates = results.get('dates', [])
                portfolio_values = results['portfolio_values']
                
                if dates and len(dates) == len(portfolio_values):
                    # 날짜 형식 변환
                    if isinstance(dates[0], str):
                        dates = [pd.to_datetime(date) for date in dates]
                    
                    ax1.plot(dates, portfolio_values, linewidth=2, color='blue', label='포트폴리오 가치')
                    ax1.axhline(y=results.get('initial_capital', 10000000), 
                            color='red', linestyle='--', alpha=0.7, label='초기 자본')
                    ax1.set_title('포트폴리오 가치 변화')
                    ax1.set_ylabel('포트폴리오 가치 (₩)')
                    ax1.legend()
                    ax1.grid(True, alpha=0.3)
                    ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
                    ax1.xaxis.set_major_locator(mdates.MonthLocator(interval=2))
                    plt.setp(ax1.xaxis.get_majorticklabels(), rotation=45)
                else:
                    ax1.text(0.5, 0.5, '포트폴리오 데이터 없음', ha='center', va='center', transform=ax1.transAxes)
            else:
                ax1.text(0.5, 0.5, '포트폴리오 데이터 없음', ha='center', va='center', transform=ax1.transAxes)
            
            # 2. 거래별 수익률 (우상단)
            ax2 = axes[0, 1]
            if trades_df is not None and len(trades_df) > 0:
                trade_returns = []
                trade_dates = []
                
                for _, trade in trades_df.iterrows():
                    if 'profit_pct' in trade:
                        trade_returns.append(trade['profit_pct'])
                        if 'sell_date' in trade:
                            trade_dates.append(pd.to_datetime(trade['sell_date']))
                        else:
                            trade_dates.append(pd.to_datetime(trade.get('exit_date', datetime.now())))
                
                if trade_returns:
                    colors = ['green' if r > 0 else 'red' for r in trade_returns]
                    bars = ax2.bar(range(len(trade_returns)), trade_returns, color=colors, alpha=0.7)
                    ax2.axhline(y=0, color='black', linestyle='-', alpha=0.3)
                    ax2.set_title(f'거래별 수익률 (총 {len(trade_returns)}회)')
                    ax2.set_ylabel('수익률 (%)')
                    ax2.set_xlabel('거래 번호')
                    ax2.grid(True, alpha=0.3)
                    
                    # 수익/손실 통계 표시
                    wins = [r for r in trade_returns if r > 0]
                    losses = [r for r in trade_returns if r < 0]
                    win_rate = len(wins) / len(trade_returns) * 100 if trade_returns else 0
                    ax2.text(0.02, 0.98, f'승률: {win_rate:.1f}%\n평균수익: {np.mean(wins):.2f}%\n평균손실: {np.mean(losses):.2f}%' if losses else f'승률: {win_rate:.1f}%\n평균수익: {np.mean(wins):.2f}%', 
                            transform=ax2.transAxes, verticalalignment='top', 
                            bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))
            else:
                ax2.text(0.5, 0.5, '거래 데이터 없음', ha='center', va='center', transform=ax2.transAxes)
            
            # 3. 월별 수익률 (좌하단)
            ax3 = axes[1, 0]
            if trades_df is not None and len(trades_df) > 0:
                monthly_returns = {}
                
                for _, trade in trades_df.iterrows():
                    if 'profit_pct' in trade and 'sell_date' in trade:
                        sell_date = pd.to_datetime(trade['sell_date'])
                        month_key = sell_date.strftime('%Y-%m')
                        
                        if month_key not in monthly_returns:
                            monthly_returns[month_key] = 0
                        monthly_returns[month_key] += trade['profit_pct']
                
                if monthly_returns:
                    months = sorted(monthly_returns.keys())
                    returns = [monthly_returns[month] for month in months]
                    colors = ['green' if r > 0 else 'red' for r in returns]
                    
                    ax3.bar(range(len(months)), returns, color=colors, alpha=0.7)
                    ax3.axhline(y=0, color='black', linestyle='-', alpha=0.3)
                    ax3.set_title('월별 수익률')
                    ax3.set_ylabel('수익률 (%)')
                    ax3.set_xlabel('월')
                    ax3.set_xticks(range(len(months)))
                    ax3.set_xticklabels(months, rotation=45)
                    ax3.grid(True, alpha=0.3)
            else:
                ax3.text(0.5, 0.5, '월별 데이터 없음', ha='center', va='center', transform=ax3.transAxes)
            
            # 4. 주요 통계 (우하단)
            ax4 = axes[1, 1]
            ax4.axis('off')
            
            # 통계 정보 준비
            stats_text = f"""
            🏆 백테스트 주요 결과
            
            📊 수익성 지표:
            • 총 수익률: {results.get('total_return', 0):.2f}%
            • 최종 자본: ₩{results.get('final_capital', 0):,.0f}
            • 초기 자본: ₩{results.get('initial_capital', 10000000):,.0f}
            
            📈 거래 성과:
            • 총 거래 횟수: {results.get('total_trades', 0)}회
            • 승률: {results.get('win_rate', 0):.1f}%
            • 평균 수익: {results.get('avg_profit', 0):.2f}%
            • 평균 손실: {results.get('avg_loss', 0):.2f}%
            
            ⚡ 리스크 지표:
            • 최대 낙폭: {results.get('max_drawdown', 0):.2f}%
            • 샤프 비율: {results.get('sharpe_ratio', 0):.2f}
            • 손익비: {results.get('profit_loss_ratio', 0):.2f}
            
            💰 수수료 정보:
            • 총 수수료: ₩{results.get('total_fees', 0):,.0f}
            """
            
            ax4.text(0.05, 0.95, stats_text, transform=ax4.transAxes, 
                    verticalalignment='top', fontsize=11, 
                    bbox=dict(boxstyle='round,pad=1', facecolor='lightblue', alpha=0.8))
            
            # 레이아웃 조정
            plt.tight_layout()
            
            # 파일 저장
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"backtest_results_{timestamp}.png"
            filepath = os.path.join(save_dir, filename)
            
            plt.savefig(filepath, dpi=300, bbox_inches='tight')
            print(f"✅ 백테스트 결과 차트가 저장되었습니다: {filepath}")
            
            # 차트 표시 (선택사항)
            plt.show()
            
            return filepath
            
        except Exception as e:
            print(f"❌ 시각화 오류: {e}")
            print(f"결과 데이터 구조: {list(results.keys()) if isinstance(results, dict) else type(results)}")
            return None

   
    
    def save_backtest_results(self, ticker, backtest_results, evaluation, output_dir="backtest_results", suffix=""):
        """최적화된 백테스트 결과 저장 - 메모리 효율성 개선"""
        print(f"저장 시작: {output_dir} 폴더에 백테스트 결과 저장 (OPTIMIZED)")
        
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        
        # 1. 핵심 결과만 저장 (용량 대폭 축소)
        essential_results = []
        
        # 거래 관련 날짜만 저장
        for result in backtest_results:
            decision = result.get('actual_decision', 'HOLD')
            
            # HOLD가 아닌 경우만 저장
            if decision != 'HOLD' or result.get('in_position', False):
                essential_data = {
                    'date': result.get('date'),
                    'price': result.get('price'),
                    'ai_decision': result.get('ai_decision'),
                    'actual_decision': decision,
                    'profit_pct': result.get('profit_pct', 0),
                    'confidence': result.get('confidence', 0),
                    'market_trend': result.get('market_trend', ''),
                    'news_count': result.get('news_count', 0),
                    'support_strength': result.get('support_strength', 0)
                }
                essential_results.append(essential_data)
        
        # 2. 압축 저장
        results_file = os.path.join(output_dir, f"{ticker}_backtest_essential{suffix}.json")
        
        try:
            with open(results_file, 'w', encoding='utf-8') as f:
                json.dump(essential_results, f, indent=1, ensure_ascii=False)
            print(f"Essential results saved ({len(essential_results)} records): {results_file}")
        except Exception as e:
            print(f"Error saving essential results: {str(e)}")
        
        # 3. 평가 결과 저장 (간소화)
        eval_file = os.path.join(output_dir, f"{ticker}_evaluation{suffix}.json")
        
        if evaluation:
            # 평가 결과에서 큰 데이터 제외
            compact_evaluation = {
                'initial_balance': evaluation.get('initial_balance'),
                'final_balance': evaluation.get('final_balance'),
                'total_return_pct': evaluation.get('total_return_pct'),
                'max_drawdown_pct': evaluation.get('max_drawdown_pct'),
                'trade_count': evaluation.get('trade_count'),
                'win_rate': evaluation.get('win_rate'),
                'profit_factor': evaluation.get('profit_factor'),
                'sharpe_ratio': evaluation.get('sharpe_ratio'),
                'avg_profit': evaluation.get('avg_profit'),
                'avg_loss': evaluation.get('avg_loss'),
                'execution_time': evaluation.get('execution_time'),
                # 거래 내역은 간소화
                'trade_summary': {
                    'total_trades': len(evaluation.get('trades', [])),
                    'profitable_trades': len([t for t in evaluation.get('trades', []) if t.get('profit_pct', 0) > 0])
                }
            }
            
            try:
                with open(eval_file, 'w', encoding='utf-8') as f:
                    json.dump(compact_evaluation, f, indent=2, ensure_ascii=False)
                print(f"Compact evaluation saved: {eval_file}")
            except Exception as e:
                print(f"Error saving evaluation: {str(e)}")
        
        print(f"최적화된 백테스트 결과 저장 완료")
        return (results_file, eval_file)
    
    def generate_sample_news(self, coin, date_from, date_to):
        """
        샘플 뉴스 데이터 생성 (뉴스 API 실패 시 사용)
        """
        sample_topics = [
            "Bitcoin price analysis",
            "Cryptocurrency market trends",
            "Bitcoin trading volume surges",
            "Institutional investors enter Bitcoin market",
            "Regulatory updates for cryptocurrencies",
            "Bitcoin technical analysis",
            "Blockchain technology developments",
            "Cryptocurrency adoption news",
            "Bitcoin mining difficulty adjustments",
            "Digital asset investment strategies"
        ]
        
        sample_sources = [
            "CoinDesk", "CryptoNews", "Bitcoin Magazine", 
            "Cointelegraph", "The Block", "Decrypt", 
            "Bitcoin.com", "CoinMarketCap", "BlockFi Blog"
        ]
        
        # 날짜 범위 내 랜덤 날짜 생성
        date_range = (date_to - date_from).days
        
        sample_news = []
        for i in range(10):  # 10개 샘플 뉴스
            random_days = random.randint(0, max(0, date_range))
            news_date = date_from + datetime.timedelta(days=random_days)
            
            news_item = {
                "title": f"{random.choice(sample_topics)} - {coin}",
                "description": f"This is a sample news article about {coin} generated for backtesting purposes.",
                "source": random.choice(sample_sources),
                "publishedAt": news_date.strftime("%Y-%m-%dT%H:%M:%SZ"),
                "url": f"https://example.com/news/{i+1}",
                "is_sample": True
            }
            sample_news.append(news_item)
        
        return sample_news

    
    def generate_backtest_report(self, ticker, backtest_results, evaluation, output_dir="backtest_results", suffix=""):
        """더 상세한 백테스트 보고서 생성 - KRW 표시 개선 및 오류 처리 추가"""
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        
        report_file = os.path.join(output_dir, f"{ticker}_backtest_report{suffix}.md")
        
        # 보고서 내용 생성
        report = f"""# AI-Driven Backtesting Report for {ticker}

    ## Overview
    - **Period**: {backtest_results[0]['date']} to {backtest_results[-1]['date']}
    - **Initial Investment**: ₩{evaluation['initial_balance']:,.0f} KRW
    - **Final Portfolio Value**: ₩{evaluation['final_balance']:,.0f} KRW
    - **Total Return**: {evaluation['total_return_pct']:.2f}%

    ## Performance Metrics
    - **Number of Trades**: {evaluation['trade_count']}
    - **Win Rate**: {evaluation['win_rate']:.2f}%
    - **Average Profit per Winning Trade**: ₩{evaluation['avg_profit']:,.0f} KRW
    - **Average Loss per Losing Trade**: ₩{evaluation['avg_loss']:,.0f} KRW
    - **Profit Factor**: {evaluation.get('profit_factor', 0):.2f}
    - **Sharpe Ratio**: {evaluation.get('sharpe_ratio', 0):.2f}%
    - **Max Drawdown**: {evaluation.get('max_drawdown_pct', 0):.2f}%

    ## Korean Market Specific Notes
    - All prices are in Korean Won (KRW)
    - All trading occurs on Upbit exchange
    - Markets operate 24/7 with different liquidity patterns
    - Korean market hours affect volume and volatility patterns

    ## RAG System Analysis

    ### Context Learning Effectiveness
    - **Total Context Entries**: {len(self.document_store) if hasattr(self, 'document_store') else 'N/A'}
    - **Vectorization Status**: {'Active' if hasattr(self, 'vectors') and self.vectors is not None else 'Inactive'}
    - **Pattern Recognition**: Enabled for similar market conditions

    ## News Data Source Summary
    - **Dataset Sources**: {len(self.news_handlers) if hasattr(self, 'news_handlers') else 0}
    - **Total News Articles Processed**: {sum(day.get('news_count', 0) for day in backtest_results)}

    ## Trade Details
    | # | Type | Reason | Entry Date | Exit Date | Entry Price (₩) | Exit Price (₩) | Profit % | Profit Amount (₩) |
    |---|------|--------|------------|-----------|----------------|----------------|----------|---------------------|
    """
        
        # 트레이드 테이블 작성 - 이 부분이 수정됨
        # 'trades'와 'trade_history' 키 모두 시도
        trades_data = evaluation.get('trades', evaluation.get('trade_history', []))
        
        if trades_data:
            for i, trade in enumerate(trades_data):
                try:
                    # 필드 접근 시 get 메서드로 안전하게 접근
                    trade_type = trade.get('type', trade.get('trade_type', 'Unknown'))
                    reason = trade.get('reason', '-')
                    entry_date = trade.get('entry_date', '-')
                    exit_date = trade.get('exit_date', '-')
                    entry_price = trade.get('entry_price', 0)
                    exit_price = trade.get('exit_price', 0)
                    profit_pct = trade.get('profit_pct', 0)
                    profit_amount = trade.get('profit_amount', 0)
                    
                    report += f"| {i+1} | {trade_type} | {reason} | {entry_date} | {exit_date} | ₩{entry_price:,.0f} | ₩{exit_price:,.0f} | {profit_pct:.2f}% | ₩{profit_amount:,.0f} |\n"
                except Exception as e:
                    print(f"Error processing trade #{i}: {str(e)}")
                    # 오류 발생 시 간단한 형태로 출력
                    report += f"| {i+1} | Error | Error | Error | Error | Error | Error | Error | Error |\n"
        else:
            report += "| - | No trades found | - | - | - | - | - | - | - |\n"
        
        # 일별 AI 결정과 뉴스 요약 추가
        report += "\n\n## Daily AI Decisions and News\n\n"
        
        for day in backtest_results[:10]:  # 처음 10일만 상세히 표시
            try:
                report += f"### {day['date']} - Price: ₩{day['price']:,.0f} - Decision: {day['ai_decision']}\n\n"
                
                # 기술적 지표 추가
                report += "#### Technical Indicators\n"
                tech_indicators = day.get('technical_indicators', {})
                if tech_indicators:
                    for indicator, value in tech_indicators.items():
                        report += f"- **{indicator}**: {value}\n"
                else:
                    report += "- No technical indicators available\n"
                
                # 뉴스 추가
                news_count = day.get('news_count', 0)
                if news_count > 0:
                    report += f"\n#### News ({news_count} articles)\n"
                    news_data = day.get('news_data', [])
                    if news_data:
                        for i, news in enumerate(news_data[:5]):  # 최대 5개만 표시
                            report += f"{i+1}. **{news.get('title', '')}** ({news.get('source', '')}, {news.get('publishedAt', '')})\n"
                            if 'description' in news and news['description']:
                                report += f"   {news['description'][:150]}...\n\n"
                    else:
                        report += "- News data not available\n"
                
                # AI 분석 추가
                report += f"\n#### AI Analysis (Confidence: {day.get('confidence', 0):.2f})\n"
                report += f"Market Trend: {day.get('market_trend', 'N/A')}\n\n"
                
                report += "---\n\n"
            except Exception as e:
                print(f"Error processing day report: {str(e)}")
                report += f"Error processing day data\n\n---\n\n"
        
        # 시장 상황별 성능 분석
        report += "\n## Market Condition Analysis\n\n"
        
        # 추세별 거래 성과 분석
        trend_analysis = {}
        for day in backtest_results:
            trend = day.get('market_trend', 'Unknown')
            if trend not in trend_analysis:
                trend_analysis[trend] = {'buy_signals': 0, 'sell_signals': 0, 'hold_signals': 0}
            
            if day.get('ai_decision') == 'BUY':
                trend_analysis[trend]['buy_signals'] += 1
            elif day.get('ai_decision') == 'SELL':
                trend_analysis[trend]['sell_signals'] += 1
            else:
                trend_analysis[trend]['hold_signals'] += 1
        
        report += "### Trading Signals by Market Trend\n\n"
        report += "| Market Trend | BUY Signals | SELL Signals | HOLD Signals |\n"
        report += "|--------------|------------|--------------|-------------|\n"
        for trend, signals in trend_analysis.items():
            report += f"| {trend} | {signals['buy_signals']} | {signals['sell_signals']} | {signals['hold_signals']} |\n"
        
        # 뉴스 영향 분석
        report += "\n### News Impact Analysis\n\n"
        
        # 일별 뉴스 수에 따른 의사결정 및 결과 분석
        news_impact = {
            "high_news_days": {"days": 0, "correct_decisions": 0},
            "low_news_days": {"days": 0, "correct_decisions": 0}
        }
        
        for i, day in enumerate(backtest_results):
            # 다음 날의 가격 변화 확인 (가능한 경우)
            if i < len(backtest_results) - 1:
                next_day = backtest_results[i + 1]
                price_change = ((next_day['price'] / day['price']) - 1) * 100
                
                # 뉴스가 많은 날과 적은 날 구분
                if day.get('news_count', 0) >= 3:  # 뉴스가 많은 날
                    news_impact["high_news_days"]["days"] += 1
                    
                    # AI 결정이 올바른지 확인
                    if (day['ai_decision'] == "BUY" and price_change > 0) or \
                    (day['ai_decision'] == "SELL" and price_change < 0) or \
                    (day['ai_decision'] == "HOLD" and abs(price_change) < 1.0):
                        news_impact["high_news_days"]["correct_decisions"] += 1
                else:  # 뉴스가 적은 날
                    news_impact["low_news_days"]["days"] += 1
                    
                    # AI 결정이 올바른지 확인
                    if (day['ai_decision'] == "BUY" and price_change > 0) or \
                    (day['ai_decision'] == "SELL" and price_change < 0) or \
                    (day['ai_decision'] == "HOLD" and abs(price_change) < 1.0):
                        news_impact["low_news_days"]["correct_decisions"] += 1
        
        # 뉴스 영향 분석 결과 추가
        if news_impact["high_news_days"]["days"] > 0:
            high_news_accuracy = (news_impact["high_news_days"]["correct_decisions"] / news_impact["high_news_days"]["days"]) * 100
            report += f"On days with 3+ news articles ({news_impact['high_news_days']['days']} days), AI decisions were correct {high_news_accuracy:.2f}% of the time.\n"
        
        if news_impact["low_news_days"]["days"] > 0:
            low_news_accuracy = (news_impact["low_news_days"]["correct_decisions"] / news_impact["low_news_days"]["days"]) * 100
            report += f"On days with fewer news articles ({news_impact['low_news_days']['days']} days), AI decisions were correct {low_news_accuracy:.2f}% of the time.\n"
        
        # 시스템 개선 제안
        report += "\n## System Improvement Recommendations\n\n"
        
        # 승률 기반 제안
        if evaluation['win_rate'] < 50:
            report += "1. **Signal Filtering**: Consider implementing stricter signal filtering to improve win rate\n"
            report += "2. **Position Sizing**: Implement dynamic position sizing based on confidence levels\n"
            report += "3. **Market Regime Detection**: Enhance market condition detection for better strategy adaptation\n"
        
        # 손익비 기반 제안
        if evaluation.get('profit_factor', 0) < 1.5:
            report += "4. **Risk Management**: Review stop-loss and trailing-stop parameters for better risk control\n"
            report += "5. **Target Optimization**: Optimize profit targets based on historical performance\n"
        
        # 샤프 비율 기반 제안
        if evaluation.get('sharpe_ratio', 0) < 1.0:
            report += "6. **Volatility Adjustment**: Implement volatility-based position sizing\n"
            report += "7. **Strategy Diversification**: Consider multiple strategies for different market conditions\n"
        
        # RAG 시스템 개선 제안
        report += "\n## RAG System Enhancement\n\n"
        report += "1. **Context Expansion**: Increase historical context window for pattern recognition\n"
        report += "2. **Similarity Metrics**: Implement more sophisticated similarity scoring beyond RSI comparison\n"
        report += "3. **Learning Feedback**: Add post-trade analysis to improve future decision making\n"
        report += "4. **Multi-Asset Context**: Consider cross-asset correlation in decision making\n"
        
        # 기술적 노트 추가
        report += "\n### Technical Note\n"
        report += "This backtest utilized an enhanced RAG (Retrieval-Augmented Generation) system that learns from historical patterns and adapts to market conditions. The system maintains a document store of past market contexts and uses similarity search to inform trading decisions.\n"
        
        # 보고서 저장
        try:
            with open(report_file, 'w', encoding='utf-8') as f:
                f.write(report)
            
            print(f"Backtest report saved to {report_file}")
        except Exception as e:
            print(f"Error saving backtest report: {str(e)}")
            report_file = None
        
        return report_file
    

class NewsDatasetHandler:
    """
    비트코인 뉴스 데이터셋을 처리하기 위한 클래스
    """
    def __init__(self, dataset_path, format_config=None):
        """
        format_config: 데이터셋 형식을 정의하는 딕셔너리
        """
        self.dataset_path = dataset_path
        # format_config가 없으면 detect_format() 호출, 있으면 사용
        self.format_config = format_config if format_config is not None else self.detect_format()
        self.news_data = None
        self.load_dataset()
        
    def load_dataset(self):
        try:
            # CSV 파일 로드
            self.news_data = pd.read_csv(self.dataset_path)
            
            # utc=True 파라미터 추가: 모든 날짜를 UTC 타임존으로 변환
            self.news_data['published_time'] = pd.to_datetime(self.news_data['published_time'], errors='coerce', utc=True)
            
            # 날짜가 없는 행 제거
            self.news_data = self.news_data.dropna(subset=['published_time'])
            
            # 날짜별로 정렬
            self.news_data = self.news_data.sort_values('published_time')
            
            print(f"Successfully loaded {len(self.news_data)} news articles from dataset.")
            print("Dataset time range:", 
                self.news_data['published_time'].min().strftime('%Y-%m-%d'),
                "to", 
                self.news_data['published_time'].max().strftime('%Y-%m-%d'))
        
        except Exception as e:
            print(f"Error loading news dataset: {str(e)}")
            self.news_data = pd.DataFrame()


    def detect_format(self):
        """첫 몇 줄을 읽어서 형식 자동 감지"""
        try:
            # 첫 10줄만 읽어서 분석
            df_sample = pd.read_csv(self.dataset_path, nrows=10)
            columns = df_sample.columns.tolist()
            
            # 열 이름 기반 패턴 매칭
            if 'url' in columns and 'text' in columns and 'title' in columns:
                return {
                    'type': 'cointelegraph',
                    'mappings': {
                        'title': 'title',
                        'description': 'text',
                        'url': 'url',
                        'published_time': 'published_time'
                    }
                }
            elif 'header' in columns and 'date' in columns and 'link' in columns:
                return {
                    'type': 'crypto_news',
                    'mappings': {
                        'title': 'header',
                        'url': 'link',
                        'published_time': 'date'
                    }
                }
            elif 'datetime' in columns and 'text' in columns:
                return {
                    'type': 'labeled_news',
                    'mappings': {
                        'description': 'text',
                        'url': 'url',
                        'published_time': 'datetime'
                    }
                }
            else:
                # 기본 형식
                return {
                    'type': 'default',
                    'mappings': {
                        'title': columns[0] if len(columns) > 0 else 'title',
                        'description': columns[1] if len(columns) > 1 else 'text',
                        'url': columns[2] if len(columns) > 2 else 'url'
                    }
                }
        except Exception as e:
            print(f"Error detecting format: {str(e)}")
            return {
            'type': 'default',
            'mappings': {
                'title': 'title',
                'description': 'text',
                'url': 'url',
                'published_time': 'published_time'
            }
        }
        
    def load_dataset(self):
        """데이터셋 로드 및 표준화"""
        try:
            self.news_data = pd.read_csv(self.dataset_path)
            
            # 복합 헤더 처리 (NFT market 형식)
            if 'header' in self.news_data.columns and '\n' in str(self.news_data['header'].iloc[0]):
                self.news_data['clean_header'] = self.news_data['header'].apply(
                    lambda x: x.split('\n')[0] if isinstance(x, str) else x
                )
                self.format_config['mappings']['title'] = 'clean_header'
            
            # 날짜 열 표준화
            date_columns = ['published_time', 'date', 'datetime']
            for col in date_columns:
                if col in self.news_data.columns:
                    self.news_data[col] = pd.to_datetime(
                        self.news_data[col], 
                        errors='coerce', 
                        utc=True
                    )
            
        except Exception as e:
            print(f"Error loading dataset: {str(e)}")
            self.news_data = pd.DataFrame()
    

    def get_news_cache_path(self, coin, date_from, date_to):
        """
        특정 날짜 범위의 뉴스에 대한 캐시 파일 경로 반환 - 수정된 버전
        """
        # 캐시 디렉토리 확인 및 생성
        if not hasattr(self, 'news_cache_dir') or not self.news_cache_dir:
            self.news_cache_dir = "news_cache"
        os.makedirs(self.news_cache_dir, exist_ok=True)
        
        # 코인 심볼 정리
        if isinstance(coin, str) and coin.startswith("KRW-"):
            symbol = coin.split("-")[1]
        else:
            symbol = str(coin)
        
        # 날짜 형식 변환
        if isinstance(date_from, (datetime.datetime, pd.Timestamp)):
            date_from_str = date_from.strftime("%Y%m%d")
        else:
            # 문자열인 경우 그대로 사용
            date_from_str = str(date_from).replace("-", "")[:8]
        
        if isinstance(date_to, (datetime.datetime, pd.Timestamp)):
            date_to_str = date_to.strftime("%Y%m%d")
        else:
            # 문자열인 경우 그대로 사용
            date_to_str = str(date_to).replace("-", "")[:8]
        
        return os.path.join(self.news_cache_dir, f"{symbol.lower()}_{date_from_str}_{date_to_str}.json")


    def get_news_for_date_range(self, start_date, end_date):
        """표준화된 형식으로 뉴스 반환"""
        if self.news_data is None or self.news_data.empty:
            return []
        
        try:
            # 날짜 열 찾기
            date_col = None
            for col in ['published_time', 'date', 'datetime']:
                if col in self.news_data.columns:
                    date_col = col
                    break
            
            if date_col is None:
                return []
            
            # 날짜 필터링
            start_date_ts = pd.Timestamp(start_date).tz_localize('UTC')
            end_date_ts = pd.Timestamp(end_date).tz_localize('UTC')
            
            mask = (self.news_data[date_col] >= start_date_ts) & \
                   (self.news_data[date_col] <= end_date_ts)
            
            filtered_news = self.news_data[mask]
            
            # 매핑을 통해 표준 형식으로 변환
            news_list = []
            mappings = self.format_config.get('mappings', {})
            
            for _, news in filtered_news.iterrows():
                news_dict = {
                    "title": news.get(mappings.get('title', ''), ''),
                    "url": news.get(mappings.get('url', ''), ''),
                    "description": news.get(mappings.get('description', ''), ''),
                    "source": f"Dataset-{self.format_config['type']}",
                    "publishedAt": news[date_col].strftime('%Y-%m-%dT%H:%M:%SZ') if pd.notna(news[date_col]) else ''
                }
                news_list.append(news_dict)
            
            return news_list
            
        except Exception as e:
            print(f"Error getting news for date range: {str(e)}")
            return []

    # 백테스트 결과 직접 확인하는 코드
def check_backtest_results_directly(backtest_results):
    """
    평가 함수 없이 백테스트 결과를 직접 분석
    """
    
    print("🔍 === 백테스트 결과 직접 분석 ===")
    print(f"총 데이터 포인트: {len(backtest_results)}")
    
    # 매수/매도 거래 추출
    buy_trades = []
    sell_trades = []
    
    for result in backtest_results:
        if result.get('actual_decision') == 'BUY':
            buy_trades.append(result)
        elif result.get('actual_decision') in ['SELL_PROFIT', 'SELL_STOPLOSS', 'SELL_TIMEOUT']:
            sell_trades.append(result)
    
    print(f"\n📈 매수 거래: {len(buy_trades)}건")
    for i, trade in enumerate(buy_trades, 1):
        print(f"  {i}. {trade['date']} - ₩{trade['price']:,.0f}")
        print(f"     투자금: ₩{trade.get('total_cost', trade.get('investment_amount', 0)):,.0f}")
        print(f"     코인량: {trade['coin_amount']:.8f} BTC")
    
    print(f"\n📉 매도 거래: {len(sell_trades)}건")
    for i, trade in enumerate(sell_trades, 1):
        print(f"  {i}. {trade['date']} - ₩{trade['price']:,.0f}")
        print(f"     수익: ₩{trade.get('profit_amount', 0):,.0f} ({trade.get('profit_pct', 0):.2f}%)")
        print(f"     사유: {trade.get('exit_reason', '불명')}")
    
    # 수익률 계산
    total_profit = sum(trade.get('profit_amount', 0) for trade in sell_trades)
    total_investment = sum(trade.get('total_cost', trade.get('investment_amount', 0)) for trade in buy_trades)
    
    if total_investment > 0:
        actual_return_pct = (total_profit / total_investment) * 100
    else:
        actual_return_pct = 0
    
    print(f"\n💰 실제 계산 결과:")
    print(f"  ├─ 총 투자금: ₩{total_investment:,.0f}")
    print(f"  ├─ 총 수익: ₩{total_profit:,.0f}")
    print(f"  ├─ 실제 수익률: {actual_return_pct:.2f}%")
    print(f"  └─ 거래 성공률: {len(sell_trades)}/{len(buy_trades)} = {(len(sell_trades)/max(1,len(buy_trades)))*100:.1f}%")
    
    # 각 거래 상세 분석
    print(f"\n📊 거래별 상세:")
    for i, buy in enumerate(buy_trades):
        buy_date = buy['date']
        buy_price = buy['price']
        investment = buy.get('total_cost', buy.get('investment_amount', 0))
        
        # 해당 매수에 대응하는 매도 찾기
        corresponding_sell = None
        for sell in sell_trades:
            if sell['entry_date'] == buy_date:
                corresponding_sell = sell
                break
        
        if corresponding_sell:
            profit = corresponding_sell.get('profit_amount', 0)
            profit_pct = corresponding_sell.get('profit_pct', 0)
            sell_date = corresponding_sell['date']
            exit_reason = corresponding_sell.get('exit_reason', '불명')
            
            print(f"  거래 #{i+1}:")
            print(f"    매수: {buy_date} @ ₩{buy_price:,.0f} (₩{investment:,.0f})")
            print(f"    매도: {sell_date} @ ₩{corresponding_sell['price']:,.0f}")
            print(f"    결과: ₩{profit:,.0f} ({profit_pct:+.2f}%) - {exit_reason}")
        else:
            print(f"  거래 #{i+1}: 매수만 있음 (매도 미완료)")
    
    return {
        'buy_count': len(buy_trades),
        'sell_count': len(sell_trades),
        'total_profit': total_profit,
        'total_investment': total_investment,
        'actual_return_pct': actual_return_pct
    }

# 사용법:
# results = check_backtest_results_directly(backtest_results)



from dotenv import load_dotenv
import os

    

def main():
    """메인 함수 - 새로운 효율적 백테스팅 적용"""
    load_dotenv()
    
    # 설정
    LLAMA_MODEL_PATH = "C:/work/Trading_AI/llama4-dolphin-8B/llama4-dolphin-8B.Q5_K_M.gguf"
    NEWS_API_KEY = os.getenv("NEWS_API_KEY")
    
    # 테스트 기간 - 정확한 2021년 2월 데이터만 사용
    TEST_PERIODS = [
        {"name": "efficient_test", "start": "2018-05-01", "end": "2025-05-30", 
         "desc": "효율적 백테스트 (rag1)10m", "method": "new"},
       
            ]
    
    # 다양한 시간프레임 테스트
    TIMEFRAMES = ['10m']  # '1m'은 API 부하가 커서 '1h'로 변경
    
    NEWS_DATASETS = [
        "C:\\work\\Data_Set\\dmitriykutsenko_bitcoin_news-train.csv",
        "C:\\work\\Data_Set\\FadedCalendula_cryptonews_srp_data-train.csv",
        "C:\\work\\Data_Set\\SahandNZ_cryptonews-articles-with-price-momentum-labels-train.csv"
    ]
    
    # 결과 저장 디렉토리 확인
    results_dir = "backtest_results"
    if not os.path.exists(results_dir):
        os.makedirs(results_dir)
        print(f"결과 저장 디렉토리 생성: {results_dir}")
    
    # 결과 저장
    test_results = {}
    
    for timeframe in TIMEFRAMES:
        for period in TEST_PERIODS:
            test_id = f"{period['name']}_{timeframe}_{period['method']}"
            
            print(f"\n{'='*60}")
            print(f"테스트 ID: {test_id}")
            print(f"설명: {period['desc']}")
            print(f"시간프레임: {timeframe}")
            print(f"방식: {period['method']}")
            print(f"{'='*60}")
            
            # 중요: 매 테스트마다 새 인스턴스 생성
            backtester = AIBacktester(
                llama_model_path=LLAMA_MODEL_PATH,
                n_gpu_layers=20,
                news_api_key=NEWS_API_KEY,
                news_datasets=NEWS_DATASETS,
                use_selenium=True,
                headless=True,
                timeframe=timeframe
            )
            
            # 테스트 실행 전 상태 초기화
            if hasattr(backtester, 'reset'):
                backtester.reset()
            else:
                # reset 메서드가 없는 경우 수동으로 초기화
                backtester.historical_data = []
                backtester.backtest_results = []
                backtester.document_store = []
                backtester.processed_timestamps = set() if hasattr(backtester, 'processed_timestamps') else set()
                backtester.consecutive_losses = 0
                backtester.stop_loss_streak = 0
                backtester.cooldown_until = -1
                backtester.recovery_factor = 1.0
            
            # 테스트 방식 선택
            try:
                if period['method'] == 'new':
                    # 새로운 방식
                    print(f"실행 중: 새로운 백테스트 방식 (지지선 트리거)")
                    backtest_results = backtester.run_backtest(
                        start_date=period['start'],
                        end_date=period['end'],
                        timeframe=timeframe,
                        test_mode=False,
                        llm_mode=True,
                        initial_position=False
                    )
                else:
                    # 기존 방식
                    print(f"실행 중: 기존 백테스트 방식 (전체 데이터)")
                    historical_data = backtester.fetch_historical_data(
                        ticker="KRW-BTC",
                        interval="day",
                        count=30,
                        to=period["end"]
                    )
                    
                    if historical_data is not None and not historical_data.empty:
                        backtest_results = backtester.run_backtest(
                            data=historical_data,
                            test_mode=False,
                            llm_mode=True,
                            initial_position=False
                        )
                    else:
                        print(f"Failed to fetch historical data for {test_id}")
                        continue
                
                # 백테스트 결과 평가
                if backtest_results and len(backtest_results) > 0:
                    print(f"백테스트 완료. 결과 평가 중...")
                    
                    try:
                        # calculate_holding_days 함수가 없는 경우 추가
                        if not hasattr(backtester, 'calculate_holding_days'):
                            backtester.calculate_holding_days = lambda entry_date, exit_date: 1  # 임시 기능
                            print("Warning: calculate_holding_days 함수가 없어 임시 함수로 대체합니다.")
                            
                        evaluation = backtester.evaluate_backtest(backtest_results)
                        
                        if evaluation:
                            # 결과 저장
                            test_results[test_id] = {
                                "method": period['method'],
                                "timeframe": timeframe,
                                "total_return": evaluation["total_return_pct"],
                                "trade_count": evaluation["trade_count"],
                                "win_rate": evaluation["win_rate"],
                                "max_drawdown": evaluation.get("max_drawdown_pct", 0),
                                "sharpe_ratio": evaluation.get("sharpe_ratio", 0),
                                "ai_calls": len([r for r in backtest_results if r.get('ai_decision') != 'NONE']),
                                "rag_patterns": len(backtester.document_store) if hasattr(backtester, 'document_store') else 0
                            }
                            
                            # 결과 시각화 및 저장
                            try:
                                print(f"결과 시각화 및 저장 중...")
                                backtester.plot_backtest_results("KRW-BTC", backtest_results, evaluation)
                                backtester.save_backtest_results("KRW-BTC", backtest_results, evaluation, suffix=f"_{test_id}")
                                backtester.generate_backtest_report("KRW-BTC", backtest_results, evaluation, suffix=f"_{test_id}")
                                print(f"결과가 {results_dir} 디렉토리에 저장되었습니다.")
                            except Exception as e:
                                print(f"결과 시각화/저장 오류: {str(e)}")
                            
                            print(f"\n--- 결과 요약: {test_id} ---")
                            print(f"총 수익률: {evaluation['total_return_pct']:.2f}%")
                            print(f"거래 횟수: {evaluation['trade_count']}")
                            print(f"승률: {evaluation['win_rate']:.2f}%")
                            print(f"최대 낙폭: {evaluation.get('max_drawdown_pct', 0):.2f}%")
                            print(f"샤프 비율: {evaluation.get('sharpe_ratio', 0):.2f}")
                    except Exception as e:
                        print(f"백테스트 평가 오류: {str(e)}")
                        import traceback
                        traceback.print_exc()
            except Exception as e:
                print(f"백테스트 실행 오류: {str(e)}")
                import traceback
                traceback.print_exc()
    
    # 결과 비교 출력
    if test_results:
        print(f"\n{'='*80}")
        print("테스트 결과 종합 비교")
        print(f"{'='*80}")
        print(f"{'테스트 ID':<30} {'방식':<10} {'시간프레임':<10} {'수익률':<10} {'거래수':<8} {'승률':<8} {'최대낙폭':<10} {'샤프비율':<10}")
        print("-" * 80)
        
        for test_id, result in test_results.items():
            print(f"{test_id:<30} {result['method']:<10} {result['timeframe']:<10} "
                  f"{result['total_return']:>8.2f}% {result['trade_count']:>6} "
                  f"{result['win_rate']:>6.2f}% {result['max_drawdown']:>8.2f}% "
                  f"{result['sharpe_ratio']:>8.2f}")
        
        # 결과 파일로 저장
        try:
            summary_file = os.path.join(results_dir, f"test_summary_{int(time.time())}.json")
            with open(summary_file, 'w', encoding='utf-8') as f:
                json.dump(test_results, f, indent=2, ensure_ascii=False)
            print(f"\n종합 결과가 {summary_file}에 저장되었습니다.")
        except Exception as e:
            print(f"결과 저장 오류: {str(e)}")

if __name__ == "__main__":
    main()
